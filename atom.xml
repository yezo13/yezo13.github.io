<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yezo13</title>
  
  <subtitle>2Vegetable</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-23T10:12:27.536Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yezo13</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>酸菜鱼的SLAM之旅（1）</title>
    <link href="http://yoursite.com/2019/03/23/SLAM/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/03/23/SLAM/ubuntu环境配置/</id>
    <published>2019-03-23T09:42:12.929Z</published>
    <updated>2019-03-23T10:12:27.536Z</updated>
    
    <content type="html"><![CDATA[<p>From：我是一条酸菜鱼。</p><a id="more"></a><hr><h2 id="2019年3月23日：Ubuntu环境配置"><a href="#2019年3月23日：Ubuntu环境配置" class="headerlink" title="2019年3月23日：Ubuntu环境配置"></a>2019年3月23日：Ubuntu环境配置</h2><p>###前言</p><blockquote><p>一开始我以为之前用ubuntu上过程设跑过C，配置过环境，应该没啥问题的，所以看了看十四讲的实践部分，感觉不就调两个库的事情吗，就直接跳过了。今天想起来，准备用自己的电脑run一遍，一用起来才发现关于ubuntu的知识都忘光了，环境居然只有gcc，cpp都编译不了，很难受。所以写点东西记录一下，下次要是又忘光了还可以看。</p></blockquote><hr><p>###Ubuntu基本命令</p><p>ubuntu的系统命令基本以<code>sudo apt-get</code>前缀，下面以我痛苦的安装过程记录一些可能有用的命令：</p><p>安装命令</p><pre><code>sudo apt-get install g++  //安装软件g++</code></pre><p>移除命令</p><pre><code>sudo apt-get remove g++  //卸载</code></pre><p>检查更新</p><pre><code>sudo apt-get update //好像是检查装了的软件和当前发行版本，拉下来一个软件列表</code></pre><p>升级</p><pre><code>sudo apt-get upgrade //升级软件</code></pre><p>切换到root用户（虽然我不知道为啥root还是有些文件夹会被拒绝访问？）</p><pre><code>sudo su -  //需要输密码 占个坑，以后看看关于root、777的内容</code></pre><hr><p>然后我insatll g++的时候，提示一堆什么破依赖关系不对，而且还不让我破坏。我真的吃柠檬了。然后上网疯狂搜，解决办法是【换源 + aptitude】</p><p>换源方法参考的是<a href="https://blog.csdn.net/fei20140908/article/details/78952341" target="_blank" rel="noopener">这个大佬</a>，反正大概就是系统设置 - 软件与更新 - 服务器选其他 - 查找最快源 - 找到之后设置成这个源，其实我也不知道有没有用，感觉迟早有用。</p><p>然后aptitude是一个提供解决依赖关系的程序</p><p>先安装一下</p><pre><code>sudo apt-get install aptitude</code></pre><p>然后用它来解决你的安装问题</p><pre><code>sudo aptitude install g++ //我是装g++啦</code></pre><p>然后会刷刷刷一大堆信息，最后给出一个提示办法，选择是[y/n/q]：</p><ul><li>选择y就是执行当前方案（它给我提供的第一个方案是啥也不做，然后告诉我解决问题啦，我：？？？）</li><li>n是拒绝当前方案，然后会提供下一个方案，反正我解决上面提到的sb依赖问题的方法是【降低装了的软件的版本】的那个方案，最后搞定了</li><li>q原来是quit的意思，我还以为是啥question的派生词，具体解释一下，还是太菜了…</li></ul><p>后面跟着流程走就搞定了</p><p>装完之后<code>-v</code> 看一下是不是装成功了 </p><hr><p>###编译&amp;MakeFile（占坑）</p><ul><li>以后更新点关于makefile的</li><li>awhca</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;From：我是一条酸菜鱼。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue学习笔记（1）</title>
    <link href="http://yoursite.com/2019/03/21/vueLearning/vueLearning1/"/>
    <id>http://yoursite.com/2019/03/21/vueLearning/vueLearning1/</id>
    <published>2019-03-21T03:06:42.426Z</published>
    <updated>2019-03-22T10:07:51.217Z</updated>
    
    <content type="html"><![CDATA[<p>我是一条酸菜鱼。</p><a id="more"></a><p><a href="http://http://www.runoob.com/w3cnote/vue2-start-coding.html" target="_blank" rel="noopener">环境配置教程</a></p><p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">官方教程</a></p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p><img src="http://www.runoob.com/wp-content/uploads/2016/10/1476690217-1155-854231-1d2947692fba4957.png" alt></p><p>配置淘宝镜像</p><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p>安装相关环境: node.js、cnpm、vue-cli </p><pre><code>npm -g install npm  //更新npm到最新版本cnpm install wekpack -g  npm install vue-cli -g </code></pre><h3 id="新建vue项目流程"><a href="#新建vue项目流程" class="headerlink" title="新建vue项目流程"></a>新建vue项目流程</h3><pre><code>vue init wekpack-simple &lt;name&gt;  //新建vue项目npm install //安装项目依赖cnpm install vue-router vue-resource --save //安装路由模块和网络请求模块npm run dev</code></pre><p>（webstorm好像有点牛逼?验证sysu邮箱可以免费用）</p><p>（感觉sublime + livereload好像也差不多）</p><hr><h3 id="Vue格式"><a href="#Vue格式" class="headerlink" title="Vue格式"></a>Vue格式</h3><pre><code>&lt;template&gt; -&gt; html&lt;script&gt; -&gt; js&lt;style&gt; -&gt; css</code></pre><hr><h3 id="简单语法"><a href="#简单语法" class="headerlink" title="简单语法"></a>简单语法</h3><p><a href="https://cn.vuejs.org/v2/guide/index.html" target="_blank" rel="noopener">官网教程</a></p><p>####vue文件</p><ul><li><p>html:</p><pre><code>&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;   //div的id属性，用于css编辑，与web一致&lt;div id=&quot;app-6&quot;&gt;&lt;p&gt;{{ abc }}&lt;/p&gt;   //第一种元素绑定方法，abc为变量名，script中可直接调用&lt;span v-bind:title=&quot;new2&quot;&gt; //第二种元素绑定方法，new2为变量名，script中直接调用put here&lt;/span&gt;&lt;br/&gt;&lt;button v-on:click=&quot;change&quot;&gt;click here&lt;/button&gt;//与方法绑定，跟C#差不多&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></li></ul><ul><li>script</li></ul><pre><code>export default {  name: &apos;app&apos;,  //给整个vue组件定义变量名，可调用  data () { //vue实例中引用到的变量名    return {      msg: &apos;Welcome to Your Vue.js App&apos;,      abc: &apos;something&apos;,      new2: &apos;currentTime: &apos; + new Date().toLocaleString()}  },  methods: { //vue实例中使用到的函数（方法）    change: function(){      this.abc = &quot;you&quot;    }  }}</code></pre><hr><h4 id="关于-new-vue-和-export-default-的区别"><a href="#关于-new-vue-和-export-default-的区别" class="headerlink" title="关于 new vue 和 export default 的区别"></a>关于 new vue 和 export default 的区别</h4><blockquote><hr><p>在main.js当中已经有一个new vue了。作为被main.js  import的APP.vue ，App.vue当中应当有export default，这样才能在main.js中引入（也就是import）APP.vue当中的内容。</p></blockquote><blockquote><p>new vue是生成Vue根实例，而export default则是用来导出的。export default相当于提供一个接口给外界，让外界（这里也就是main.js）来引入使用。</p></blockquote><blockquote><p>在不使用App.vue 文件时，我们是通过 Vue 构造函数（new vue）创建一个 Vue 根实例来启动vuejs 项目，Vue 构造函数接受一个对象，这个对象有一些配置属性 el, data, component, template 等，从而对整个应用提供支持。</p></blockquote><blockquote><p>而现在我们的vue项目建好之后，有.vue也有.js，此时，在App.vue文件中，export default 后面的对象就相当于 new Vue() 构造函数中的接受的对象。</p></blockquote><ul><li><p>style</p><pre><code>感觉跟css差不多</code></pre></li></ul><hr><h3 id="vue指令"><a href="#vue指令" class="headerlink" title="vue指令"></a>vue指令</h3><blockquote><p>vue指令可以直接嵌在html的元素里面中去，也就是直接在元素中加入这一条属性，使用demo如下：</p></blockquote><pre><code>&lt;div id=&quot;app-6&quot;&gt;  &lt;p&gt;{{ message }}&lt;/p&gt;  &lt;input v-model=&quot;message&quot;&gt; //双向绑定，vue指令在这里使用&lt;/div&gt;var app6 = new Vue({  el: &apos;#app-6&apos;,  data: {message: &apos;Hello Vue!&apos;  }})    </code></pre><p>一些vue指令：</p><pre><code>v-bind:title = &quot;abc&quot;  //将元素节点的title 绑定 data中变量名为abc的变量v-if=&quot;a&quot;  //通过控制a，可以控制元素v-for = &quot;i in a&quot;   //循环处理a数组中的元素i的属性v-on:click = &quot;method&quot;  //click操作调用method函数 click应该可以替换成其他操作v-model = &quot;abc&quot;  //实现表单输入(或其它元素）和应用状态之间的双向绑定</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是一条酸菜鱼。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>系统分析与设计—hw3</title>
    <link href="http://yoursite.com/2019/03/13/swsadHw/swsadhw3/"/>
    <id>http://yoursite.com/2019/03/13/swsadHw/swsadhw3/</id>
    <published>2019-03-13T02:04:00.010Z</published>
    <updated>2019-03-13T07:00:50.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【简答题】"><a href="#【简答题】" class="headerlink" title="【简答题】"></a>【简答题】</h3><p><strong>1.简述瀑布模型、增量模型、螺旋模型（含原型方法）的优缺点（从项目特点、风险特征、人力资源利用角度思考）</strong></p><a id="more"></a><ul><li><p>瀑布模型:</p><ul><li>简述：瀑布模型设置了一系列的阶段，按顺序进行开发，项目开发进程从一个阶段流动到下一个阶段，形式上与物理世界中的瀑布非常相像。同时，每个阶段都会产生循环反馈，对临近阶段进行影响。</li><li>优点：<ul><li>降低软件开发的复杂程度，提高软件开发过程的透明性；同时，由于开发的基本流程和活动都是易理解的，因此提高了软件开发过程的可管理性。</li><li>推迟软件实现，强调在软件实现前必须进行分析和设计工作。</li><li>以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，保证了阶段之间的正确衔接，能够及时发现并纠正开发过程中存在的缺陷，使产品达到预期的质量要求。</li></ul></li><li>缺点：<ul><li>强调过程活动的线性顺序，因此理论上需要保证需求明确，且短期内可获得，每个阶段是无差错的。</li><li>缺乏灵活性，尤其无法解决软件需求不明确或不准确的问题。同时，在后期发现需求问题，更改的工作量十分巨大。</li><li>风险控制能力较弱，当前面需求模糊/前方成果不完善，会对后阶段产生巨大影响。</li><li>瀑布模型中的软件活动是文档驱动的，当阶段之间规定过多的文档时，会极大地增加系统的工作量。</li><li>管理人员如果仅仅以文档的完成情况来评估项目完成进度，往往会产生错误的结论，容易被人为误导。</li></ul></li></ul></li><li><p>增量模型:</p><ul><li>简述：增量模型是把待开发的软件系统模块化，将每个模块作为一个增量组件，分批次地分析、设计、编码和测试这些组块，具有一个递增式的开发过程。</li><li>优点：<ul><li>将待开发的软件系统模块化，可以分批次地提交软件产品，进行迭代式的开发，遵循“先做出来可以用的软件，再把软件做好。”的原则，因此对开发方较友好。</li><li>由于软件产品模块化交付，因此用户可以及时了解软件项目的进展并给出反馈，使得用户可以及时了解到项目进展，提升其在软件开发阶段的参与度和对项目的信息。</li><li>开发顺序灵活，开发人员可以对组件的实现顺序进行选择和优先级排序，先完成需求稳定的核心组件。当组件的优先级发生变化时，还能及时地对实现顺序进行调整。</li><li>降低了软件开发的风险，出现在组件中的错误可以被灵活解决，而不会对整个软件系统造成巨大的影响。</li></ul></li><li>缺点:<ul><li>待开发的软件系统需要可以被模块化；使用增量模型对难以模块化的软件系统进行开发会导致很多的问题：如模块划分，功能交付等。</li><li>增量粒度难以选择。</li><li>为了将软件系统分成多个模块，需要增加额外的工作量。</li></ul></li></ul></li><li><p>螺旋模型（含原型方法）：</p><ul><li>简述：螺旋模型采用周期性的方法进行开发，以进化的开发方式为中心，在不断迭代的过程中完成开发，且强调风险分析。</li><li><p>优点：</p><ul><li>设计上具有灵活性，可以在项目的各个阶段中或是下一次迭代中完成变更，可以不需要在一开始就给出具体明确的需求。</li><li>以小的分段来构造大型的系统，易于计算成本。</li><li>进行了风险分析，使得项目具有更高的可靠性。</li><li>由于快速原型法需要客户使用并提供反馈，因此提升了客户的参与度，保证了项目与客户需求是一致的，项目是可控的。同时提升了客户对项目的信心，对开发团队的认可。</li></ul></li><li><p>缺点：</p><ul><li>没有明确的项目终点，需要根据项目的具体进度进行判断。</li><li>建设周期长，可能导致软件开发的需求或核心技术与现实产生差距，无法满足当前用户的需求。</li><li>需要使用户确信这种模型的开发方法的结果是可以控制的。</li></ul></li></ul></li></ul><p><strong>2.简述统一过程三大特点，与面向对象的方法有什么关系？</strong></p><p>统一过程（Unified Process，UP）是一种以用例驱动的、以体系结构为核心的、迭代和增量的软件过程模型。由UML方法和工具支持，广泛应用于各类面向对象项目。<br>统一过程的三大特点分别是：</p><ol><li>软件开发是一个迭代的过程，是一种受控的迭代和增量式开发。</li><li>软件开发是由用例（Use Case）驱动的，也就是通过测试来推动整个开发过程的进行，在测试中完成需求分析、设计、质量控制等过程。这为整个开发过程提供了高效的驱动力。</li><li>软件开发是以体系结构为核心的。</li></ol><p><strong>3.简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？</strong></p><p>UP项目将其工作和迭代组织为四个主要阶段： </p><ol><li>初始（Inception）：大体上的构想、业务案例、范围和模糊评估。 <ul><li>里程碑：生命周期目标里程碑，包括一些重要的文档，如：项目构想(Vision)、原始用例模型、原始业务风险评估、一个或者多个原型、原始业务案例等。需要对这些文档进行评审，以确定正确理解用例需求、项目风险评估合理、阶段计划可行等。 </li></ul></li><li>细化（Elaboration）：已精化的构想、核心架构的迭代实现、高风险的解决、确定大多数需求和范围以及进行更为实际的评估。 <ul><li>里程碑：生命周期体系结构(Lifecycle Architecture) 里程碑。包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等。通过评审确定软件体系结构已经稳定、高风险的业务需求和技术机制已经解决、修订的项目计划可行等。 </li></ul></li><li>构造（Construction）：对遗留下来的风险较低和比较简单的元素进行迭代实现，准备部署。 <ul><li>里程碑：初始运行能力(Initial Operational Capability) 里程碑。包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署。此刻，要确定软件、环境、用户是否可以开始系统的运行。 </li></ul></li><li>移交（Transition）：进行beta测试和部署。 <ul><li>里程碑：产品发布(Product Release) 里程碑。确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周期。在一些情况下这个里程碑可能与下一个周期的初始阶段的相重合。</li></ul></li></ol><p>下图提供了一个可视化的循环过程：<br><img src="https://img-blog.csdnimg.cn/20190313144706784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1llem8xMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>4.软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？</strong></p><p>当企业使用UP进行软件开发时，基于UP迭代式、增量式的开发特点，整个开发过程可以被划分为几个固定的阶段和多次迭代的过程。也就是说，整个开发过程被划分成了固定的开发周期，因此企业就可以按照固定的节奏进行软件生产，也可以得到预期的生产周期并以此来形成一个发布软件产品的固定周期。<br>UP本身的特性，使得其可应用于各种领域的软件开发和不同的项目规模。其带来的好处有：</p><ul><li>企业可以将项目格式化、流程化，并对每一个流程标定固定的工作内容，使得整个系统架构更具有鲁棒性。</li><li>项目管理者以及客户都可以更了解开发进度、存在的问题和预期的目标，有利于开发者和使用者的交流，使得项目开发不会与需求偏差过大</li><li>开发过程可以进行风险分析和需求理解，降低了项目失败的概率</li></ul><hr><p>###【实践题】</p><p>了解使用 TAPD 的最佳实践</p><ul><li>比较完善 backlog 支持（树结构）</li><li>迭代（sprint）安排</li><li>较好的缺陷管理</li><li>Kanban</li><li>统计</li></ul><p>###【大作业准备】</p><ul><li>按大作业要求组件团队、思考项目题目与内容</li><li>将团队暂时分为技术研究、业务调研两个部分<ul><li>技术团队初步确定技术方法，力争做一些技术原型，如 基于 MVC 框架的的用户登陆实现</li><li>业务调研团队调查竞争性产品，分析它们的基础、共性业务以及竞争优势</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【简答题】&quot;&gt;&lt;a href=&quot;#【简答题】&quot; class=&quot;headerlink&quot; title=&quot;【简答题】&quot;&gt;&lt;/a&gt;【简答题】&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.简述瀑布模型、增量模型、螺旋模型（含原型方法）的优缺点（从项目特点、风险特征、人力资源利用角度思考）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>系统分析与设计—hw2</title>
    <link href="http://yoursite.com/2019/03/09/swsadHw/swsadhw2/"/>
    <id>http://yoursite.com/2019/03/09/swsadHw/swsadhw2/</id>
    <published>2019-03-09T04:36:48.585Z</published>
    <updated>2019-03-18T02:21:47.558Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【简答题】"><a href="#【简答题】" class="headerlink" title="【简答题】"></a>【简答题】</h3><p><strong>1.用简短的语言给出对分析、设计的理解。</strong></p><p>分析就是对用户给出的软件功能等方面的需求进行系统的研究，识别出主号问题，确定待开发软件的功能、性能、接口、数据、界面等具体的细节要求。<br>设计就是基于需求分析中得到的需求，构造出目标系统的逻辑模型，最终得到一个可供编码过程参考的设计模型文档。</p><blockquote><p>软件分析不是发现更多的功能与需求，而是确认有效的功能与需求，去伪存真不断满足客户需要。软件设计也不是追求最先进技术，而是控制变化附加的成本，使得软件生产的预算、时间等能在掌控之中。</p></blockquote><a id="more"></a><hr><p><strong>2.用一句话描述面向对象的分析与设计的优势。</strong></p><p>面向对象的分析与设计能够通过分析现实世界中存在的问题，并构建相对应的问题模型，保持了他们的结构、关系和行为模式，具有易理解和易维护的特性。</p><hr><p><strong>3.简述 UML（统一建模语言）的作用。考试考哪些图？</strong></p><p>UML（Unified Modeling Language）用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品。 它可以将面向对象分析（OOA）和面向对象设计（OOD）使用统一定义的符号表示出来，并将对象自身的属性、对象与对象之间的关联关系可视化，提升项目结构的可读性。</p><p>考试的重点图形: </p><p>图形化的表示机制，十多种视图，分4类：</p><ul><li>用例图：用户角度：功能、执行者</li><li>静态图：系统静态结构<ul><li>类图：概念及关系</li><li>对象图：某种状态或时间段内，系统中活跃的对象及其关系</li><li>包图：描述系统的分解结构</li></ul></li><li>行为图：系统的动态行为<ul><li>交互图：描述对象间的消息传递<ul><li>顺序图：强调对象间消息发送的时序</li><li>合作图：强调对象间的动态协作关系</li></ul></li><li>状态图：对象的动态行为。状态-事件-状态迁移-响应动作</li><li>活动图：描述系统为完成某功能而执行的操作序列</li></ul></li><li>实现图：描述系统的组成和分布状况<ul><li>构件图：组成部件及其关系</li><li>部署图：物理体系结构及与软件单元的对应关系</li></ul></li></ul><hr><p><strong>4.从软件本质的角度，解释软件范围（需求）控制的可行性</strong></p><p>软件的本质包括复杂性、一致性、可变性和不可视性。基于IEEE中给出的软件特点：</p><blockquote><ul><li>Software requirements are prone to frequent change</li><li>In many cases, requirements allocated to software must be renegotiated and reprioritized</li><li>Small changes to software can have large negative effects（There are no small software changes） </li></ul></blockquote><p>对于软件的需求可能会因为不一致、不可使、易于变化的环境而更改，需求的更改会带来软件的改动，这就可能会产生巨大的负面影响，包括开发难度的增加，开发周期的增长等。为了尽可能避免以上情况的发生，我们必须对软件需求进行范围的划定和控制。即在需求分析与设计的过程中，我们必须在给定的范围内围绕软件开发的成本进行调控，允许范围内、不造成巨大影响的需求变更和迭代，最终保证软件开发周期和成本是可控的，在约定的时间内交付出可满足客户的软件成品。因此，软件范围需求控制是可行且必须的。</p><hr><p>###【看板使用练习】<br><a href="https://imgchr.com/i/AmZyQJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmZyQJ.jpg" alt="AmZyQJ.jpg"></a><br><a href="https://imgchr.com/i/AmZvY8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmZvY8.md.png" alt="AmZvY8.md.png"></a></p><p>###【UML绘图工具练习】</p><p>图选自  《UML和模式应用（中文第三版）》 P193  </p><p> <strong>图16-16 UML中的关联类</strong><br><a href="https://imgchr.com/i/AmVzrR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmVzrR.jpg" alt="AmVzrR.jpg"></a></p><p><strong>图16-17 表示单实例类</strong><br><a href="https://imgchr.com/i/AmZSq1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmZSq1.jpg" alt="AmZSq1.jpg"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【简答题】&quot;&gt;&lt;a href=&quot;#【简答题】&quot; class=&quot;headerlink&quot; title=&quot;【简答题】&quot;&gt;&lt;/a&gt;【简答题】&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.用简短的语言给出对分析、设计的理解。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分析就是对用户给出的软件功能等方面的需求进行系统的研究，识别出主号问题，确定待开发软件的功能、性能、接口、数据、界面等具体的细节要求。&lt;br&gt;设计就是基于需求分析中得到的需求，构造出目标系统的逻辑模型，最终得到一个可供编码过程参考的设计模型文档。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;软件分析不是发现更多的功能与需求，而是确认有效的功能与需求，去伪存真不断满足客户需要。软件设计也不是追求最先进技术，而是控制变化附加的成本，使得软件生产的预算、时间等能在掌控之中。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>系统分析与设计—hw1</title>
    <link href="http://yoursite.com/2019/03/06/swsadHw/swsadhw1/"/>
    <id>http://yoursite.com/2019/03/06/swsadHw/swsadhw1/</id>
    <published>2019-03-06T02:35:02.621Z</published>
    <updated>2019-03-10T10:40:04.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【简答题】"><a href="#【简答题】" class="headerlink" title="【简答题】"></a>【简答题】</h3><p><strong>1.软件工程的定义</strong></p><blockquote><p>Software engineering is “(1) the application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software, that is, the application of engineering to software,” and “(2) the study of approaches as in (1).” –– IEEE Standard 610.12</p></blockquote><p>软件工程的定义： </p><ul><li>(1) 将系统化、规范化、可度量的方法应用与软件的开发、运行和维护-的过程，即将工程化应用于软件中。 </li><li>(2) 对(1)中所述方法的研究。</li></ul><p>软件工程知识体系:</p><ul><li>以高质量为目标，研究软件生产的过程模型、方法和工具</li></ul><a id="more"></a><hr><p><strong>2.解释导致 software crisis 本质原因、表现，述说克服软件危机的方法</strong><br>软件危机（Software Crisis）是一个早期的计算机科学用语，指的是在给定时间内编写出可用和高效的程序的困难性。现在引申至指软件在开发和维护过程中出现的一系列严重的问题。<br>在1972年，Edsger Dijkstra 指出计算能力约强大，编程越是大问题。因此导致软件危机的本质原因是计算机计算能力的迅速增长，以及计算机能力增长而导致软件需要处理和解决的问题具有更大的复杂性。也就是计算机计算能力的提高超过了程序员能够高效利用计算机的能力。<br>软件危机的主要表现有：</p><ul><li>进行了超预算的项目</li><li>项目长期无法完成</li><li>软件非常低效</li><li>软件质量低下</li><li>软件经常与用户的需求不匹配</li><li>项目难以管理</li><li>程序代码的后期维护存在困难</li><li>软件无法完成并交付</li></ul><hr><p><strong>3.软件生命周期</strong></p><p>软件生命周期（Software Development LifeCycle）是指软件的产生直到成熟的全部过程。早期的软件生命周期受到瀑布模型的影响，因此通常定义为：</p><blockquote><p>软件从计划、需求开始，经历分析设计、实现、部署、维护，直到最后逐渐消亡的。</p></blockquote><p>因此，现在对软件生命周期及软件生命周期模型采用如下定义：</p><ul><li>软件生命周期是指软件的产生直到成熟的全部过程。</li><li>软件生命周期模型是指人们为开发更好的软件而归纳总结的软件生命周期的典型实践参考。</li></ul><p>根据GB/T 8567的定义，软件生命周期分为以下6个阶段：</p><ul><li>可行性分析与计划</li><li>需求分析</li><li>设计（概要设计和详细设计）</li><li>编码实现</li><li>测试</li><li>运行和维护</li></ul><p>常见的软件生命周期模型有原型模型、螺旋模型、迭代模型。</p><hr><p><strong>4.SWEBoK 的 15 个知识域（An Overview of the SWEBOK Guide 请中文翻译其名称与简短说明）</strong></p><p>SWEBOK V3中的15个知识域包括：</p><p><strong>11个软件工程实践知识域：</strong></p><ul><li><strong>软件需求 Software requirements</strong><br>真实世界问题而必须展示的特性。软件需求的知识域包括七个子域，即软件需求基础、需求过程、需求获取、需求分析、需求规格说明、需求确认和实践考虑。</li><li><strong>软件设计 Software design</strong><br>根据IEEE [ IEEE 610.12-90] ，设计既是”定义一个系统或组件的体系结构、组件、接口和其他特征的过程”，又是”这个过程的结果”。软件设计的知识域包括六个子域，即软件设计基础、软件设计关键问题、软件结构与体系结构、软件设计质量的分析与评价、软件设计符号、软件设计的策略与方法。</li><li><strong>软件构造 Software construction</strong><br>它指通过编码、验证、单元测试、集成测试和排错的组合，具体创建一个可以工作的、有意义的软件，其知识域包括软件构造基础、管理构造、实际考虑三个子域。</li><li><strong>软件测试 Software testing</strong><br>它是由在有限测试用例集合上，根据期望的行为，对程序的行为进行的动态验证组成， 测试用倒是实际上无限的执行域中适当选择出来的。软件测试包括五个子域，即软件测试基础和测试级别、测试技术、需求分析、与测试相关的度量、测试过程。</li><li><strong>软件维护 Software maintenance</strong><br>软件一旦投入运行，就可能出现异常，运行环境可能发生改变，用户会提出新的需求。生命周期软件维护阶段从软件交付时开始，但是维护活动出现得还要早。软件维护的知识域包括四个子域，即软件维护基础、软件维护的关键问题、维护过程、维护技术。</li><li><strong>软件配置管理 Software configuration management</strong><br>为了系统地控制配置的变更和维护在整个系统生命周期中的完整性和可追踪性，而标志软件在时间上不同点的配置的学科。软件配置管理包括六个子域，即软件配置管理过程管理、软件配置标志、软件配置控制、软件配置状态统计、软件配置审核、软件发行管理和交付。</li><li><strong>软件工程管理 Software engineering management</strong><br>处理软件工程的管理与度量，虽然度量是所有知识域的一个重要方面，但是这里涉及的是度量程序的专题。软件工程管理包括六个子域，即启动和范围定义、软件项目计划、软件项目实施、评审与评价、关闭、软件工程度量。前五个覆盖软件过程工程 管理，第六个描述软件度量的程序。</li><li><strong>软件工程过程 Software engineering process</strong><br>涉及软件工程过程本身的定义、实现、评定、度量、管理、变更和改进。软件工程过程包括四个子域，即过程实施与改变、过程定义、过程评定、过程和产品度量。</li><li><strong>软件工程模型和方法  Software engineering models and methods</strong><br>包括软件工程工具、软件工程方法两个子域。</li><li><strong>软件质量 Software quality</strong><br>处理跨越软件生命周期过程的软件质量的考虑，由于软件质量在软件工程中元处不在，其他知识域也涉及质量 问 题。软件质量包括三个子域，即软件质量基础、软件质量过程、实践考虑。</li><li><strong>软件工程职业实践 Software engineering professional practice</strong></li></ul><p><strong>4个软件工程教育基础知识域：</strong></p><ul><li><strong>软件工程经济学 Software engineering economics</strong></li><li><strong>计算基础 Computing foundations</strong></li><li><strong>数学基础 Mathematical foundations</strong></li><li><strong>工程基础 Engineering foundations</strong></li></ul><hr><p><strong>5.简单解释 CMMI 的五个级别。例如：Level 1 - Initial：无序，自发生产模式。</strong></p><p>能力成熟度模型集成（英语：Capability Maturity Model Integration，简称CMMI或“希迈”）是一种改进过程的方法，其目的是协助提升组织的绩效。</p><p><strong>Level 1 - Initial：初始级。</strong><br>软件过程是无序的，有时甚至是混乱的，对过程几乎没有定义，成功取决于个人努力。管理是反应式的。</p><p><strong>Level 2 - Managed：可管理级。</strong><br>建立了基本的项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。</p><p><strong>Level 3 - Defined：已定义级。</strong><br>已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。</p><p><strong>Level 4 - Quantitatively Managed：量化管理级。</strong><br>分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。</p><p><strong>Level 5 - Optimizing：优化管理级。</strong><br>过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。</p><hr><p><strong>6.用自己语言简述 SWEBok 或 CMMI （约200字）</strong></p><p>SWEBok即软件工程知识体系指南（Guide to the Software Engineering Body of Knowledge)，是一个得到普遍认可的共识性软件工程本体知识结构。（其历史可追溯到1999年4月由发表的《软件工程知识本体结构》报告。报告的发布使人们达成了共识，即建立软件工程本体知识结构是解决如何验证软件工程工程师的资格、如何设置并检验软件工程相关课程等难题的答案。）SWEBok的目的是为软件工程学科的范围提供一致的认识，为支持该学科的本体知识提供指导。SWEBOK V3将软件工程学科的本体知识分为15个知识域，并对每个知识域中的重要概念和区别加以阐述说明。也就是说，SWEBok最大的贡献是将原本混杂的软件工程知识体系化，将原本存在的知识分类整理，最后形成一个具有共识性和方向性的指南。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【简答题】&quot;&gt;&lt;a href=&quot;#【简答题】&quot; class=&quot;headerlink&quot; title=&quot;【简答题】&quot;&gt;&lt;/a&gt;【简答题】&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.软件工程的定义&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Software engineering is “(1) the application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software, that is, the application of engineering to software,” and “(2) the study of approaches as in (1).” –– IEEE Standard 610.12&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;软件工程的定义： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) 将系统化、规范化、可度量的方法应用与软件的开发、运行和维护-的过程，即将工程化应用于软件中。 &lt;/li&gt;
&lt;li&gt;(2) 对(1)中所述方法的研究。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;软件工程知识体系:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以高质量为目标，研究软件生产的过程模型、方法和工具&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BringMeFly</title>
    <link href="http://yoursite.com/2019/02/27/Personal/hello-world/"/>
    <id>http://yoursite.com/2019/02/27/Personal/hello-world/</id>
    <published>2019-02-27T09:14:41.217Z</published>
    <updated>2019-03-10T10:39:02.240Z</updated>
    
    <content type="html"><![CDATA[<p>Update it when i have time.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Update it when i have time.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
