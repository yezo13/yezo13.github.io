<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yezo13</title>
  
  <subtitle>2Vegetable</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-27T06:45:55.401Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yezo13</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue学习笔记（2）</title>
    <link href="http://yoursite.com/2019/03/27/vueLearning/vueLearning2/"/>
    <id>http://yoursite.com/2019/03/27/vueLearning/vueLearning2/</id>
    <published>2019-03-27T02:12:43.962Z</published>
    <updated>2019-03-27T06:45:55.401Z</updated>
    
    <content type="html"><![CDATA[<p>我是一条酸菜鱼。</p><a id="more"></a><h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><h3 id="创建Vue实例"><a href="#创建Vue实例" class="headerlink" title="创建Vue实例"></a>创建Vue实例</h3><ul><li>选项对象</li><li></li></ul><h3 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h3><p>Vue实例 - Vue的响应式系统：</p><ul><li>data对象中的属性值改变会带来视图的响应</li><li>只有实例创建时data中已存在的属性才是响应式的</li><li>Vue实例自带的实例属性与方法带有前缀$，与用户自定义的属性区分</li><li><p>阻止修改现有的属性 - Object.freeze()(下例）</p><pre><code>//js    var obj = {  foo: &apos;bar&apos;}Object.freeze(obj)new Vue({  el: &apos;#app&apos;,  data: obj})--------------------------------------------//html&lt;div id=&quot;app&quot;&gt;  &lt;p&gt;{{ foo }}&lt;/p&gt;  &lt;!-- 这里的 `foo` 不会更新！ --&gt;  &lt;button v-on:click=&quot;foo = &apos;baz&apos;&quot;&gt;Change it&lt;/button&gt;&lt;/div&gt;</code></pre></li></ul><h2 id="实例生命周期钩子"><a href="#实例生命周期钩子" class="headerlink" title="实例生命周期钩子"></a>实例生命周期钩子</h2><p>Vue的初始化过程：</p><p>生命周期钩子（在vue初始化过程某些阶段运行钩子对应的函数），函数中调用的 this 指向调用它的vue实例。</p><ul><li>created</li><li>mounted</li><li>updated</li><li>destroyed</li></ul><blockquote><p>不要在选项属性或回调上使用箭头函数，比如 created: () =console.log(this.a) 或 vm.$watch(‘a’, newValue =this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到位置，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。</p></blockquote><p>（假装此处有图）</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是一条酸菜鱼。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>酸菜鱼的梯度下降法学习</title>
    <link href="http://yoursite.com/2019/03/25/deepLearning/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2019/03/25/deepLearning/梯度下降法的简单应用/</id>
    <published>2019-03-25T06:47:44.653Z</published>
    <updated>2019-03-26T13:29:26.204Z</updated>
    
    <content type="html"><![CDATA[<p>From：我是一条酸菜鱼。</p><h2 id="2019年3月26日：梯度下降法求解多元线性模型"><a href="#2019年3月26日：梯度下降法求解多元线性模型" class="headerlink" title="2019年3月26日：梯度下降法求解多元线性模型"></a>2019年3月26日：梯度下降法求解多元线性模型</h2><a id="more"></a><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>探讨使用梯度下降法（随机梯度下降法）的多变量线性回归模型，损失函数、梯度下降法的收敛、过拟合问题和学习率等之间的关系。</p><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>请在文件夹“作业2”中下载文件名为<strong>“dataForTraining.txt”</strong>的文件。该文件包含广东省广州市海珠区的房价信息，里面包含<strong>50</strong>个训练样本数据。文件有三列，第一列对应<strong>房的面积</strong>（单位：平方米），第二列对应房子距离双鸭山职业技术学院的<strong>距离</strong>（单位：千米），第三列对应房子的<strong>销售价格</strong>（单位：万元）。</p><p>每一行对应一个训练样本。请使用提供的50个训练样本来训练多变量回归模型以便进行<strong>房价预测</strong>，请用（<strong>随机）梯度下降法</strong>的<strong>多变量线性回归模型</strong>进行建模。为了评估训练效果，请文件夹中下载测试数据集“dataForTesting.txt” （该测试文件里的数据跟训练样本具有相同的格式，即第一列对应房子面积，第二列对应距离，第三列对应房子总价）。</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><h3 id="梯度下降法（GD-Gradient-Descent）"><a href="#梯度下降法（GD-Gradient-Descent）" class="headerlink" title="梯度下降法（GD,Gradient Descent）"></a>梯度下降法（GD,Gradient Descent）</h3><p>梯度下降法（批量梯度下降法）的计算过程就是沿梯度下降的方向求解极小值或沿梯度上升方向求解极大值。由于GD在每次计算梯度时都需要遍历所有样本，因此一定保证每次迭代都能沿着极小值的方向迈进，比较稳定，缺点在于每一次迭代的计算量都一样且比较大。</p><h3 id="随机梯度下降法（SGD-Stochastic-Gradient-Descent"><a href="#随机梯度下降法（SGD-Stochastic-Gradient-Descent" class="headerlink" title="随机梯度下降法（SGD,Stochastic Gradient Descent)"></a>随机梯度下降法（SGD,Stochastic Gradient Descent)</h3><p>随机梯度下降法的计算过程与梯度下降法相仿，区别在于SGD每次计算梯度时，只随机的选取一个样本来计算梯度,这样就大大的减小了计算的复杂度。问题在于由于只选择一个样本进行每次的迭代，因此收敛不稳定，且有可能出现朝着反方向迭代的情况，即某一次迭代中出现了负优化。</p><h3 id="小批量梯度下降法（mini-batch）"><a href="#小批量梯度下降法（mini-batch）" class="headerlink" title="小批量梯度下降法（mini-batch）"></a>小批量梯度下降法（mini-batch）</h3><p>在每次迭代的时候选取一部分样本，与随机梯度下降法相比，增强了方向的稳定性。与批量梯度下降法相比，运算量大大减少，运行速度也更快。</p><h3 id="多变量线性回归"><a href="#多变量线性回归" class="headerlink" title="多变量线性回归"></a>多变量线性回归</h3><p>即具有多个自变量且可用线性方程式表达的模型，形如：</p><blockquote><p>h(x)=theta0+theta1<em>x1+theta2</em>x2+theta3*x3</p></blockquote><p>同时，我们可以认为函数的常数项是相当于系数（该常数）始终乘以一个（X<sub>0</sub> == 1),此时这个函数就可以表达成两个一维矩阵之间的相乘，即</p><blockquote><p>h<sub>θ</sub>(x) = θ<sup>T</sup>X</p></blockquote><p>其中θ为参数矩阵，X为系数矩阵</p><h3 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h3><p>均方误差（英语：mean-square error、MSE）是对于无法观察的参数 θ 的一个估计函数T；其定义为：</p><p>$$MSE(T) = E((T-θ²)) = \frac{1}{2N}\sum_{t=1}^{N}(Yestimate - Y)²$$ </p><h2 id="模型训练流程"><a href="#模型训练流程" class="headerlink" title="模型训练流程"></a>模型训练流程</h2><p> 训练流程如下:</p><ol><li><p>先定义训练的迭代次数、学习率、样本数目等训练过程中使用到的参数，在每一次的训练中，根据选择的梯度下降方法（GD/SGD/mini-batch GD）进行训练。</p></li><li><p>进入迭代过程，每一次的训练中，先将模型更新，计算出预测值，根据预测值可以计算出当前模型预测的损失情况，然后再回退到原来前进前的情况，并记录下损失值，由最后的输出可知随着模型的训练损失值下降。然后重新将模型更新，然后得到同样的预测值，然后使用这个预测值与之前定义好的训练集作比较，计算出当前模型判断的准确率（误差），由最后的输出可知这个准确率在训练的过程中逐步上升。这就完成了一次迭代。</p></li><li><p>重复进行n次训练（在上面的代码中训练次数为400次），得到最终的模型。</p></li><li><p>使用测试集对最终的模型进行测试，最后得到这个模型识别测试集的准确率，通过准确率判断训练出来的模型的质量。</p></li></ol><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>模型训练的核心在于两个函数，一个是代价函数，另一个是梯度下降函数。</p><ul><li><p>代价函数（MSE）：计算模型迭代完成后的均方误差作为误差</p><pre><code>def costFunc(X,Y,theta):    inner = np.power((X*theta.T)-Y,2)      return np.sum(inner)/(len(X))  </code></pre></li><li><p>梯度函数：定义了整个迭代的训练过程，输入参数包括（训练样本，初始误差，学习率（步长），迭代次数，使用参数进行训练并迭代，通过代价函数求出当前的误差并记录，完成给定次数的迭代后输出最终的模型参数，训练样本误差，测试样本误差等信息。</p><pre><code>def gradientDescent(X,Y,theta,lr,iters):    #初始化    temp = np.mat(np.zeros(theta.shape))    trainCost = []    testCost = []    index = []    thetaNums = int(theta.shape[1]) #系数的个数    #迭代过程    for i in range(iters):        error = (X*theta.T-Y) #计算误差        for j in range(thetaNums): #三个系数            #np.multiply：数组和矩阵对应位置相乘，输出与相乘数组/矩阵的大小一致            derivativeInner = np.multiply(error,X[:,j]) #求导数            #得到当前的参数            temp[0,j] = theta[0,j] - (lr*np.sum(derivativeInner)/len(X))        theta = temp #将参数更新        if(i % 100000 == 0):            index.append(i);            trainCost.append(costFunc(X,Y,theta))            testCost.append(costFunc(Xtest,Ytest,theta))    return theta,trainCost,testCost,index</code></pre></li></ul><p>-</p><p>其余如文件读写，作图等功能可见源码注释。</p><hr><h3 id="exercise1："><a href="#exercise1：" class="headerlink" title="exercise1："></a>exercise1：</h3><blockquote><p>你需要用多少个参数来训练该线性回归模型？请使用梯度下降方法训练。训练时，请把迭代次数设成1500000，学习率设成0.00015，参数都设成0.0。在训练的过程中，每迭代100000步，计算训练样本对应的误差，和使用当前的参数得到的测试样本对应的误差。请画图显示迭代到达100000步、200000步、… … 1500000时对应的训练样本的误差和测试样本对应的误差（图可以手画，或者用工具画图）。从画出的图中，你发现什么？请简单分析。</p></blockquote><h3 id="ANS1："><a href="#ANS1：" class="headerlink" title="ANS1："></a>ANS1：</h3><p>我定义的梯度下降模型使用了<strong>5个参数</strong>来训练这个线性模型（实际函数中有7个参数是因为我为了方便处理，将训练集和测试集的X和Y分开输入了），分别是：</p><ul><li>训练集（X，Y）</li><li>测试集（Xtest，Ytest）</li><li>初始系数（theta，都设为0）</li><li>学习率（lr，learning rate）</li><li>迭代次数（iters）</li></ul><p>同时，训练后的模型输出四个参数，分别是：</p><ul><li>最终系数（resultTheta)</li><li>一组训练集误差（trainCost）</li><li>一组测试集误差（testCost）</li><li>下标（按照题目要求用于记录误差所在的迭代次数，每十万次）</li></ul><p>按照给定的要求进行150W次的迭代，每10W次迭代对两种误差都进行一次记录，得到结果如下图（为了图显示的美观，因此将float格式的误差转换成了int的格式，即去掉了小数部分）：</p><p><img src="https://s2.ax1x.com/2019/03/26/AU4ryn.png" alt="AU4ryn.png"></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4wWQ.png" alt="AU4wWQ.png"></p><p>其中，第一张图是使用训练集计算出的误差，第二张图是使用测试集中训练得到的误差。通过数值可以看出，由于一开始设置的初始参数为【0，0，0】，因此得到的误差与其他误差相比十分大，导致整体图的结构看不出正确误差的走向，因此去掉第一个点重新作图，得到图像如下：</p><p><img src="https://s2.ax1x.com/2019/03/26/AU40zj.png" alt="AU40zj.png"><br><img src="https://s2.ax1x.com/2019/03/26/AU4aFS.png" alt="AU4aFS.png"></p><p>可以看到，对于训练集，其误差在每10W次迭代中是下降且趋于收敛，在50W次迭代的时候达到极小值3，而且之后迭代中一直保持这个误差不变，此时<strong>由图看到的训练效果较好</strong>，可以认为梯度下降法达到了<strong>收敛</strong>。同时，参考测试集，误差是在20W次迭代的时候达到一个低值（119），然后继续迭代后误差反而<strong>上升</strong>了，最后稳定在133左右。基于此，我认为以题目给定的数值作为参数输入，最后得到的模型是<strong>过拟合</strong>的，具体体现在<strong>训练集的表现很好，但测试集的表现一般</strong>。</p><hr><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2:"></a>Exercise 2:</h3><blockquote><p>现在，你改变学习率，比如把学习率改成0.0002（此时，你可以保持相同的迭代次数也可以改变迭代次数），然后训练该回归模型。你有什么发现？请简单分析。</p></blockquote><h3 id="ANS2"><a href="#ANS2" class="headerlink" title="ANS2:"></a>ANS2:</h3><p>改变学习率为0.0002后初始化模型并重新训练，得到的参数基本都是无意义的（除了第一个误差参数为10W+外，其余的均为NAN），显示运算的溢出。而修改学习率为更低的参数，效果不太明显，只能勉强看出学习率会影响训练的进度，对结果影响不大。后面经过讨论得知，这是由于训练过程中，参数没有进行正则化的原因，优化后得到更好的效果，可以看出，针对SD而言，当学习率上升时，模型训练速度提高。</p><p>同时，我使用了另外一门课《人工神经网络》中的作业作为例子，使用控制变量法对学习率进行了进一步的测试，得到结果如下图所示：（其中loss是损失函数，即误差；acc值则为得到的结果的准确率，计算方法相当于用模型得到的结果 <strong>Y<sub>cal</sub></strong> 除以正确结果<strong>Y<sub>correct</sub></strong>。</p><p><strong>可以看出，学习率会影响梯度下降法的性能，学习率数值大时可以使得模型迅速往理想模型移动，即误差值的收敛速率较快，系数在比较少的迭代次数中就会到达较好的数值，但同时过大的学习率会导致学习的不稳定，即两种数值都会出现较大幅度的波动，即学习的方式比较激进；即而学习率过小则导致训练需要的时间过长，即两种数值虽然往好的方向变化，但变化得很慢。</strong></p><p><strong>学习率设置为100（过高）</strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4WYF.png" alt="AU4WYF.png"><img src="https://s2.ax1x.com/2019/03/26/AU4goT.png" alt="AU4goT.png"></p><p><strong>学习率设置为e<sup>-10</sup>(过低）</strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU46e0.png" alt="AU46e0.png"><img src="https://s2.ax1x.com/2019/03/26/AU4RFU.png" alt="AU4RFU.png"></p><p><strong>学习率设置为e<sup>-1</sup></strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4DQs.png" alt="AU4DQs.png"><img src="https://s2.ax1x.com/2019/03/26/AU4dJg.png" alt="AU4dJg.png"></p><p><strong>学习率设置为e<sup>-2</sup></strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4cwV.png" alt="AU4cwV.png"><img src="https://s2.ax1x.com/2019/03/26/AU4sLq.png" alt="AU4sLq.png"></p><p>学习率的变化对loss值和accuracy值的影响都主要体现在这两种数值下降的加速度（幅度）以及出现波动的幅度与频率。以上面的训练为例子：</p><ol><li><p>当学习率过高时（100），loss的图像呈现了较大幅度上下震荡的现象，loss值方差较大，但此时loss值的单个数值和均值都较小，最高点在300左右而最低点在50左右；accuracy值则很快到达了接近0.9的高值，但同时出现大幅度震荡，数值的方差较大，且在趋于稳定的过程中仍然时常出现波动到数值为0.4这样的情况。导致这种现象的原因是因为学习率过高导致了学习的不稳定性，有时候会往错误方向快速前进，导致了极端情况的出现。</p></li><li><p>当学习率过低（1e-10）时，loss图像视觉上有较大幅度的震荡，但实际上震荡范围很小（1030-1060，方差小），而数值均值很大，在1145左右；accuracy值则一直没有变化。这种现象出现的原因是学习率过低导致模型的学习效率很低，往正确模型前进的速度过慢，模型识别能力没有明显提升，因此正确率没有提升，错误率一直很高。</p></li><li><p>当学习率适中（1e-1,1e-2,1e-3）时，学习率的上升会加快训练的进程，体现在两种曲线梯度的上升，更快地趋向稳定和理想，但偶尔会出现震荡的情况。根据参数调试，我认为1e-2是比较理想的学习率。同时，上面训练函数的定义部分注释掉了一个动态调整学习率的过程，具体表现为每经过一百次训练，学习率就变为原来的1/10，这有助于后期模型训练得到的结果趋于稳定。</p></li></ol><hr><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3:"></a>Exercise 3:</h3><blockquote><p>现在，我们使用其他方法来获得最优的参数。你是否可以用<strong>随机梯度下降法</strong>获得最优的参数？请使用随机梯度下降法画出迭代次数（每K次，这里的K你自己设定）与训练样本和测试样本对应的误差的图。比较Exercise 1中的实验图，请总结你的发现。</p></blockquote><h3 id="ANS3"><a href="#ANS3" class="headerlink" title="ANS3:"></a>ANS3:</h3><p>使用随机梯度下降法，即每次迭代只使用训练集中的一组数据作为输入参数来进行梯度的计算，得到的图像如下:</p><p><strong>迭代次数为15W，每1W求一次误差</strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU44SJ.png" alt="AU44SJ.png"></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4fW4.png" alt="AU4fW4.png"></p><p><strong>迭代次数为150W，每10W求一次误差</strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU45l9.png" alt="AU45l9.png"></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4IyR.png" alt="AU4IyR.png"></p><p>由图可得，使用随机梯度下降法（即每次只抽取一个样本），可以很快<strong>接近</strong>最优的参数（<strong>通过数值判定</strong>），但在接近最优解的同时，依然可能出现较大的波动，这是由于其“冒进”的特性决定的；由于只取一个值，因此随机性更大，很可能出现向着反方向前进的情况，此时误差值反而会上升。所以我认为，用随机梯度下降法可以很快获得<strong>接近最优的参数</strong>，但很可能是一个局部最优解，需要通过<strong>大量的迭代</strong>才能确定<strong>确切的全局最优解</strong>。</p><p>通过对比，我们不难看出不同的batchSize（每次迭代的取样个数）实际上对应着三种不同的梯度下降法，分别是：</p><ul><li>SD（梯度下降法，batchSize = 样本个数</li><li>小批量梯度下降法（mini-batch, batchSize in [1,max))</li><li>SGD（随机梯度下降法，batchSize = 1）</li></ul><p>这三种方法按照上面的顺序，对模型训练的影响分别为：训练速度递增，训练稳定性递减（即出现波动的可能性递增）。</p><ol><li><p>当batchSize上升时，计算复杂度上升，运行速度下降，运行稳定性很好；当batchSize的值取的是样本长度时，模型在运算过程中持续向最优解接近，几乎没有出现错误的前进时刻，但优化的速度较慢，而且可能出现停滞；这是因为SD（批量梯度下降法）一定能够沿着最小值的方向迈进，比较稳定，但每一次计算梯度都需要遍历所有的样本，计算量比较大。</p></li><li><p>当batchSize下降时，计算复杂度下降，运行速度上升，运行随机性增长；当batchSize的值取1时，模型在迭代的训练中快速接近理想状态，但在到达较优解时会出现较大幅度的波动；这是因为SGD（随机梯度下降法)虽然具有运算速度较快的优点，但有可能跳出局部最优解，每次迈向的方向不稳定，甚至有可能向反方向迈进。</p></li><li><p>基于这个变化特性，每次计算梯度的时候选取一部分样本来进行计算，在保证方向的基本稳定的同时又减少了计算量，提升了运行速度，也就是采用mini-batch GD是一个更优的选择。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;From：我是一条酸菜鱼。&lt;/p&gt;
&lt;h2 id=&quot;2019年3月26日：梯度下降法求解多元线性模型&quot;&gt;&lt;a href=&quot;#2019年3月26日：梯度下降法求解多元线性模型&quot; class=&quot;headerlink&quot; title=&quot;2019年3月26日：梯度下降法求解多元线性模型&quot;&gt;&lt;/a&gt;2019年3月26日：梯度下降法求解多元线性模型&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>酸菜鱼的SLAM之旅（3）</title>
    <link href="http://yoursite.com/2019/03/25/SLAM/ch6_%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/03/25/SLAM/ch6_非线性优化/</id>
    <published>2019-03-25T02:05:24.589Z</published>
    <updated>2019-03-25T05:05:12.471Z</updated>
    
    <content type="html"><![CDATA[<p>From：我是一条酸菜鱼。</p><h2 id="2019年3月24日：非线性优化"><a href="#2019年3月24日：非线性优化" class="headerlink" title="2019年3月24日：非线性优化"></a>2019年3月24日：非线性优化</h2><a id="more"></a><h2 id="状态估计问题"><a href="#状态估计问题" class="headerlink" title="状态估计问题"></a>状态估计问题</h2><h3 id="最大后验和最大似然"><a href="#最大后验和最大似然" class="headerlink" title="最大后验和最大似然"></a>最大后验和最大似然</h3><p>经典SLAM模型：</p><p><img src="ch6/61.jpg" alt></p><p>观测方程：</p><p><img src="ch6/62.jpg" alt></p><p>考虑数据受噪声影响:</p><p><img src="ch6/63.jpg" alt></p><p>状态估计问题：</p><ul><li>扩展卡尔曼滤波器（EKF）：关心当前时刻的状态估计X<sub>k</sub>,而对之前的状态则不多考虑。</li><li><p>非线性优化方法:使用所有时刻采集到的数据进行状态估计。（主流方法)</p><ul><li><p><strong>似然：在现在的位姿下，可能产生怎样的观测数据</strong></p></li><li><p><strong>最大似然估计（Maximize Likelihood Estimation,MLE)：在什么样的状态下，最可能产生现在观测到的数据</strong></p></li><li><p><strong>求解最大后验概率 - 最大化似然和先验的乘积</strong></p></li><li><strong>arg maxP(z|x) —— 最大似然估计</strong></li></ul></li></ul><p><img src="ch6/64.2.jpg" alt></p><h3 id="最小二乘"><a href="#最小二乘" class="headerlink" title="最小二乘"></a>最小二乘</h3><p><img src="ch6/65.png" alt></p><ul><li>最小化负对数：对等式两边同时取负对数 -ln(f(x))</li></ul><p><img src="ch6/66.png" alt></p><p><img src="ch6/67.jpg" alt></p><p><img src="ch6/68.jpg" alt></p><ul><li><p>总体意义下的最小二乘问题（Least Square Problem）</p><ul><li>最优解等价于状态的最大似然估计。</li><li>但由于噪声存在使得估计的轨迹和地图代入SLAM运动、观测方程时不会完美成立 —— 需要把状态的估计值进行微调，使得整体误差下降（有限度，会到达一个极小值）。</li></ul></li><li><p>SLAM中的最小二乘问题——(6.12)式为目标函数</p><ul><li>总体状态变量维数高，每个误差项简单（仅与一两个状态变量有关)</li><li>每个误差项是一个小规模的约束，称每个误差项对应的优化变量为参数块（Parameter Block)</li><li>线性近似、雅可比矩阵</li><li>稀疏性</li><li>李代数-无约束</li><li>平方形式（二范数）度量误差 - 欧氏空间中距离的平方</li></ul></li></ul><h2 id="非线性最小二乘"><a href="#非线性最小二乘" class="headerlink" title="非线性最小二乘"></a>非线性最小二乘</h2><p>不方便直接求解的最小二乘问题使用<strong>迭代</strong>优化：</p><p><img src="ch6/69.jpg" alt></p><p>问题： 确定增量<strong>ΔX<sub>k</sub></strong></p><h3 id="一阶和二阶梯度法"><a href="#一阶和二阶梯度法" class="headerlink" title="一阶和二阶梯度法"></a>一阶和二阶梯度法</h3><ol><li>最速下降法（一阶）、牛顿法（二阶）<ul><li>将目标函数在x附近进行泰勒展开</li><li>参数：雅可比矩阵J、海塞（Hessian）矩阵H、步长 λ</li><li>选择保留泰勒展开的一阶/二阶项 —— 对应一阶梯度法/二阶梯度法</li><li>问题：过于贪心，容易走出锯齿路线，增加迭代次数</li></ul></li></ol><h3 id="Gauss-Newtown（高斯-牛顿）"><a href="#Gauss-Newtown（高斯-牛顿）" class="headerlink" title="Gauss-Newtown（高斯-牛顿）"></a>Gauss-Newtown（高斯-牛顿）</h3><p>思想：将f（x)进行一阶的泰勒展开（不是目标函数f(x)²）</p><p><img src="ch6/610.png" alt><br><img src="ch6/611.png" alt><br><img src="ch6/612.jpg" alt></p><p>问题:</p><ul><li>原则上要求所用的近似H矩阵可逆且正定，但实际上（J<sup>T</sup>J）只有半正定性。</li><li>可能出现J<sup>T</sup>J为奇异矩阵或者病态（ill-condition)的情况，此时增量稳定性较差，导致算法不收敛。</li><li>求出来的步长Δx太大，会导致采用的局部近似不够准确，无法保证迭代的结果是收敛。</li></ul><h3 id="Levenberg-Marquadt"><a href="#Levenberg-Marquadt" class="headerlink" title="Levenberg-Marquadt"></a>Levenberg-Marquadt</h3><p>信赖区域方法（Trust Region Method）：在信赖区域里边，我们认为近似是有效的；出了这个区域，近似可能会出问题。</p><p>确认信赖区域的范围：根据近似模型和实际函数之间的差异来确定，差异小→范围尽可能大；差异大→近似范围缩小</p><p><img src="ch6/613.jpg" alt></p><p><strong>改良后的非线性优化框架:</strong></p><p><img src="ch6/614.jpg" alt></p><h2 id="实践（挖坑，且不打算填）"><a href="#实践（挖坑，且不打算填）" class="headerlink" title="实践（挖坑，且不打算填）"></a>实践（挖坑，且不打算填）</h2><h3 id="Ceres"><a href="#Ceres" class="headerlink" title="Ceres"></a>Ceres</h3><p>Ceres库面向通用的最小二乘问题的求解：</p><ul><li>用户定义优化问题，设置选项，输入至Ceres求解</li></ul><hr><h3 id="g2o（General-Graphic-Optimization"><a href="#g2o（General-Graphic-Optimization" class="headerlink" title="g2o（General Graphic Optimization)"></a>g2o（General Graphic Optimization)</h3><p>基于图优化的库。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;From：我是一条酸菜鱼。&lt;/p&gt;
&lt;h2 id=&quot;2019年3月24日：非线性优化&quot;&gt;&lt;a href=&quot;#2019年3月24日：非线性优化&quot; class=&quot;headerlink&quot; title=&quot;2019年3月24日：非线性优化&quot;&gt;&lt;/a&gt;2019年3月24日：非线性优化&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>酸菜鱼的SLAM之旅（2）</title>
    <link href="http://yoursite.com/2019/03/24/SLAM/ch5_%E7%9B%B8%E6%9C%BA%E4%B8%8E%E5%9B%BE%E5%83%8F/"/>
    <id>http://yoursite.com/2019/03/24/SLAM/ch5_相机与图像/</id>
    <published>2019-03-24T07:34:46.933Z</published>
    <updated>2019-03-25T02:06:37.693Z</updated>
    
    <content type="html"><![CDATA[<p>From：我是一条酸菜鱼。</p><h2 id="2019年3月24日：相机与图像"><a href="#2019年3月24日：相机与图像" class="headerlink" title="2019年3月24日：相机与图像"></a>2019年3月24日：相机与图像</h2><a id="more"></a><h2 id="相机模型"><a href="#相机模型" class="headerlink" title="相机模型"></a>相机模型</h2><p>keyword：针孔模型、畸变、内参数</p><hr><p>插一点小知识：</p><ul><li><p>Markdown语法上下标：</p><p>  H<sub>2</sub>O &amp; a<sup>T</sup></p><pre><code>H&lt;sub&gt;2&lt;/sub&gt;O  //下标a&lt;sup&gt;T&lt;/sup&gt;   //上标</code></pre></li><li><p><a href="https://www.jianshu.com/p/a0aa94ef8ab2" target="_blank" rel="noopener">MarkDown输入数学公式</a></p></li><li><p>让MarkdownPad显示数学公式</p></li></ul><p>在MarkdownPad中，点击”Tools &gt; Options &gt; Advanced &gt; HTML Head Editor”，这个是自定义头文件。添加下列内容：  </p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&apos;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&apos;&gt;&lt;/script&gt;</code></pre><p>此时需要【F6】进入浏览器模式才能够显示</p><p>离线的话就先把MathJax clone到本地，然后使用绝对路径引用，应该就可以了</p><p>绝对路径加到头文件中，demo如下:</p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;file:\\\D:\software\MathJax\MathJax.js?config=TeX-MML-AM_CHTML-full&quot;&gt;&lt;/script&gt;</code></pre><hr><h3 id="针孔相机模型"><a href="#针孔相机模型" class="headerlink" title="针孔相机模型"></a>针孔相机模型</h3><p><img src="ch5/51.jpg" alt></p><p>相机坐标系为O-x-y-z，习惯上z轴指向相机前方，x向右，y向下。（也就是这幅图相当于成像平面为相机的显示屏，光心O为相机的镜头。）</p><p>P为现实中的空间点，坐标为【X，Y，Z】<sup>T</sup>，（在相机坐标系中）</p><p>而P’为它在成像平面的坐标，【X’,Y’,Z’】<sup>T</sup>（在成像平面中，即图上的O-x’-y’-z’）</p><p>图上f为焦距，Z为P点在现实中的Z轴的位置</p><p>根据三角形相似关系得到两个坐标之间的关系（负号表示成像倒立）</p><blockquote><p>$$\frac{Z}{f} = - \frac{X}{X’} = -\frac{Y}{Y’}$$</p></blockquote><p>简化模型可以把成像平面对称到相机前方，也就是</p><p><img src="ch5/52.jpg" alt></p><p>此时式子变为</p><blockquote><p>$$\frac{Z}{f} = \frac{X}{X’} = -\frac{Y}{Y’}$$</p></blockquote><p>设在物理成像平面上固定着一个像素平面： o-u-v，像素平面上可以得到P’的像素坐标：[u,v]<sup>T</sup></p><p>像素坐标系通常的定义方式是：原点o′位于图像的左上角，u轴向右与x轴平行，v轴向下与y轴平行。像素坐标系与成像平面之间，相差了一个<strong>缩放</strong>和一个<strong>原点的平移</strong>。</p><p><img src="ch5/53.png" alt></p><p>（5.6）中的P - 相机坐标 - 相机的世界坐标（Pw） - 可以得到相机的位姿（由旋转矩阵<strong>R</strong> 和 平移向量 <strong>t</strong>来描述）</p><p>因此 <strong>外参</strong> 为相机的位姿 <strong>R</strong> ， <strong>t</strong></p><p><img src="ch5/54.jpg" alt></p><p>归一化处理：</p><p>归一化平面：</p><p>归一化坐标：</p><hr><h3 id="畸变"><a href="#畸变" class="headerlink" title="畸变"></a>畸变</h3><p>获得更好的成像效果 - 相机前方加透镜 - 对成像过程光线传播造成影响：</p><ol><li>透镜自身的形状对光线传播的影响</li><li>是在机械组装过程中，透镜和成像平面不可能完全平行，这也会使得光线穿过透镜投影到成像面时的位置发生变化。</li></ol><ul><li>径向畸变：由透镜形状引起的畸变<ul><li>桶形畸变：由于图像放大率随着离光轴的距离增加而减小</li><li>枕型畸变：由于图像放大率随着离光轴的距离增加而增加</li></ul></li></ul><p><img src="ch5/55.jpg" alt></p><p>径向畸变的纠正模型:用多项式函数来描述前后的坐标变化</p><p><img src="ch5/57.png" alt></p><ul><li>切向畸变：由于透镜和成像面没有严格平行</li></ul><p><img src="ch5/56.jpg" alt></p><p><img src="ch5/58.jpg" alt></p><p>可以合并进行同时纠正（也就是把两个纠正式相加），最理论的情况下用到了5个畸变项（径向<em>3 + 切向 </em> 2），实际情况下可以灵活选择其中几项。所有的纠正都在归一化平面上完成。</p><p><img src="ch5/59.jpg" alt></p><p><img src="ch5/510.jpg" alt></p><p>!仅通过一个像素无法确定空间点的具体位置，因为从相机光心到归一化平面连线上的所有点都可以投影到该像素上。只有P的深度确定时才能够知道确切的空间位置。</p><ul><li>能否知道确切的空间位置<ul><li>针孔相机模型    （X）</li><li>双目相机模型    （√）</li><li>RGB-D相机模型  （√）</li></ul></li></ul><h3 id="双目相机模型"><a href="#双目相机模型" class="headerlink" title="双目相机模型"></a>双目相机模型</h3><p>原理：根据左右眼看到的景物差异（<strong>视差</strong>）来判断物体与我们的距离</p><p><img src="ch5/511.png" alt></p><ul><li>基线：两个相机的光圈中心的距离（Baseline，用符号b表示)</li><li>视差：左右图横坐标之差（U<sub>L</sub> - U<sub>R</sub>)</li><li>视差越大，距离越近</li><li>双目深度理论上的最大值（当视差为1个像素） - f<sub>b</sub></li><li>基线越长，双目最大能测到的距离越远</li><li>反光可能会扰乱测距</li></ul><h3 id="RGB-D相机模型"><a href="#RGB-D相机模型" class="headerlink" title="RGB-D相机模型"></a>RGB-D相机模型</h3><p>原理*2：向探测目标发射红外光，根据返回的图案/飞行时间计算距离</p><ol><li>结构光原理：通过红外结构光返回的图案来测量像素距离</li><li>飞行时间法（Time-of-flight，ToF）原理：向目标发送脉冲光，根据发送到返回之间的光束飞行时间测量像素距离</li></ol><p><img src="ch5/513.jpg" alt></p><p>问题:</p><ol><li>使用范围有限制，会收到日光或者其他传感器发射的红外光干扰，因此不能在室外使用</li><li>同时使用多个RGB-D相机会互相干扰</li><li>投射材质的物体无法接受反射光，因此无法测量这些点的位置（玻璃）</li></ol><h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><p>###灰度图</p><p>每个像素位置（x,y）对应一个灰度值I，因此一张宽为w高为h的图像可以看成一个w*h的矩阵。常见的灰度图中，我们用0-255之间的整数（即一个 unsigned char，一个字节）来表达图像的灰度大小。即我们可以用一个二维数组来表示。</p><p>在图像中，数组的行数（二维数组的第一个下标）表示图像的高度，而列数（第二个下标）表示图像的宽度。</p><p><img src="ch5/514.jpg" alt></p><p>！！！以上图为例，这里要注意，图像的宽度/列数，对应的X轴；图像的行数/高度，对应Y轴。也就是说，取坐标应该是：</p><pre><code>unsigned char pixel = image[y][x] //位于（x,y)处的像素，对应I（x,y)的读数</code></pre><ul><li>灰度像素用八位整数记录（0-255）  unsigned char</li><li>RGB-D相机深度图记录距离，用十六位整数 unsigned short</li><li>彩色图像引入通道（channel）的概念，记录R,G,B三个数值，每一个数值称为一个通道。每个通道使用9位整数表示，也就是一个像素占据24位空间。</li><li>在OpenCV的彩色图像中，通道的默认顺序是B，G，R。前8位代表蓝色，中间8位代表绿色，后8位代表红色。</li><li>如果还需要表达图像的透明度，可以使用R,G,B,A四个通道表示</li></ul><hr><h2 id="OpenCV使用实践（占坑）"><a href="#OpenCV使用实践（占坑）" class="headerlink" title="OpenCV使用实践（占坑）"></a>OpenCV使用实践（占坑）</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;From：我是一条酸菜鱼。&lt;/p&gt;
&lt;h2 id=&quot;2019年3月24日：相机与图像&quot;&gt;&lt;a href=&quot;#2019年3月24日：相机与图像&quot; class=&quot;headerlink&quot; title=&quot;2019年3月24日：相机与图像&quot;&gt;&lt;/a&gt;2019年3月24日：相机与图像&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>酸菜鱼的SLAM之旅（1）</title>
    <link href="http://yoursite.com/2019/03/23/SLAM/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/03/23/SLAM/ubuntu环境配置/</id>
    <published>2019-03-23T09:42:12.929Z</published>
    <updated>2019-03-26T04:27:04.952Z</updated>
    
    <content type="html"><![CDATA[<p>From：我是一条酸菜鱼。</p><a id="more"></a><hr><h2 id="2019年3月23日：Ubuntu环境配置"><a href="#2019年3月23日：Ubuntu环境配置" class="headerlink" title="2019年3月23日：Ubuntu环境配置"></a>2019年3月23日：Ubuntu环境配置</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>一开始我以为之前用ubuntu上过程设跑过C，配置过环境，应该没啥问题的，所以看了看十四讲的实践部分，感觉不就调两个库的事情吗，就直接跳过了。今天想起来，准备用自己的电脑run一遍，一用起来才发现关于ubuntu的知识都忘光了，环境居然只有gcc，cpp都编译不了，很难受。所以写点东西记录一下，下次要是又忘光了还可以看。</p></blockquote><hr><h3 id="Ubuntu基本命令"><a href="#Ubuntu基本命令" class="headerlink" title="Ubuntu基本命令"></a>Ubuntu基本命令</h3><p>ubuntu的系统命令基本以<code>sudo apt-get</code>前缀，下面以我痛苦的安装过程记录一些可能有用的命令：</p><p>安装命令</p><pre><code>sudo apt-get install g++  //安装软件g++</code></pre><p>移除命令</p><pre><code>sudo apt-get remove g++  //卸载</code></pre><p>检查更新</p><pre><code>sudo apt-get update //好像是检查装了的软件和当前发行版本，拉下来一个软件列表</code></pre><p>升级</p><pre><code>sudo apt-get upgrade //升级软件</code></pre><p>切换到root用户（虽然我不知道为啥root还是有些文件夹会被拒绝访问？）</p><pre><code>sudo su -  //需要输密码 占个坑，以后看看关于root、777的内容</code></pre><p>查看当前系统版本</p><pre><code>lsb_release -a</code></pre><hr><p>然后我insatll g++的时候，提示一堆什么破依赖关系不对，而且还不让我破坏。我真的吃柠檬了。然后上网疯狂搜，解决办法是【换源 + aptitude】</p><p>换源方法参考的是<a href="https://blog.csdn.net/fei20140908/article/details/78952341" target="_blank" rel="noopener">这个大佬</a>，反正大概就是系统设置 - 软件与更新 - 服务器选其他 - 查找最快源 - 找到之后设置成这个源，其实我也不知道有没有用，感觉迟早有用。</p><p>然后aptitude是一个提供解决依赖关系的程序</p><p>先安装一下</p><pre><code>sudo apt-get install aptitude</code></pre><p>然后用它来解决你的安装问题</p><pre><code>sudo aptitude install g++ //我是装g++啦</code></pre><p>然后会刷刷刷一大堆信息，最后给出一个提示办法，选择是[y/n/q]：</p><ul><li>选择y就是执行当前方案（它给我提供的第一个方案是啥也不做，然后告诉我解决问题啦，我：？？？）</li><li>n是拒绝当前方案，然后会提供下一个方案，反正我解决上面提到的sb依赖问题的方法是【降低装了的软件的版本】的那个方案，最后搞定了</li><li>q原来是quit的意思，我还以为是啥question的派生词，具体解释一下，还是太菜了…</li></ul><p>后面跟着流程走就搞定了</p><p>装完之后<code>-v</code> 看一下是不是装成功了 </p><hr><h3 id="编译-amp-MakeFile（占坑）"><a href="#编译-amp-MakeFile（占坑）" class="headerlink" title="编译&amp;MakeFile（占坑）"></a>编译&amp;MakeFile（占坑）</h3><ul><li>以后更新点关于makefile的</li><li>被自己菜哭了</li></ul><p>我凉了..为什么cd到out文件的目录下，执行命令还是</p><pre><code>//已经cd到a.out的目录下了a.out //a.out：未找到命令./a.out  //fuck you g++</code></pre><hr><h4 id="编译运行过程"><a href="#编译运行过程" class="headerlink" title="编译运行过程"></a>编译运行过程</h4><p>先创建一个生成makeFile文件的文件(CMakeLists.txt)，内容如下（选择使用，非一定全部）:</p><pre><code># makeFile名字叫CMakeLists.txt  大小写敏感 名字后缀敏感# 声明要求的cmake 最低版本cmake_minimum_required( VERSION 2.8 )# 声明一个cmake 工程project( HelloSLAM )# 添加一个可执行程序# 语法：add_executable( 程序名源代码文件）add_executable( a a.cpp ) #a为生成的程序名，a.cpp为源文件# 添加一个库#hello为库名，iamlib是源文件，里面没有main函数，只有一些定义好的函数或者变量add_library(hello iamlib.cpp)  #静态库add_libray(hello_shared SHARED iamlib.cpp) #动态库#将生成的库hello链接到可执行程序a中，此时a就可以调用hello中的函数了target_link_libraries(a hello) </code></pre><p>这里插一段书里面对动态库和静态库的解释：</p><blockquote><p>在Linux 中，库文件分成静态库和共享库两种。静态库以.a 作为后缀名，共享库以.so结尾。所有库都是一些函数打包后的集合，差别在于静态库每次被调用都会生成一个副本，而共享库则只有一个副本，更省空间。</p></blockquote><p>同时，为了使用这些库，还需要自己定义一个头文件，头文件里就是库里面的函数名，demo如下：</p><pre><code>#ifndef LIBHELLOSLAM_H_#define LIBHELLOSLAM_H_    void printHello();#endif</code></pre><p>之后在cpp里面引入这个头文件好像就可以调用里面的函数了。</p><p>然后调用cmake分析当前工程，生成makefile</p><pre><code>cmake .  //先cd到代码的当前目录</code></pre><p>然后使用生成的makeFile生成可执行文件</p><pre><code>make  //就是这个指令</code></pre><p>然后就生成了一个可执行文件，（占坑： a 和 a.out 的区别）</p><pre><code>./a  //运行</code></pre><p>十四讲还给出一个大佬做法，用于快捷删除编译的中间文件。大概就是新建一个目录然后对目录上一层进行cmake，这样子中间文件就都生成在当前目录了，最后make完再删掉就是了。</p><pre><code>mkdir buildcd buildcmake ..make</code></pre><hr><h3 id="Kdevelop使用"><a href="#Kdevelop使用" class="headerlink" title="Kdevelop使用"></a>Kdevelop使用</h3><p>安装东西使用aptitude感觉会比较靠谱</p><pre><code>sudo aptitude install kdevelop //选择第二个降版本的解决方案</code></pre><p>然后用法跟普通IDE差不多，不过添加工程文件好像是自己先写好CmakeList.txt之后，从导入工程-&gt;导入这个CmakeList.txt就可以了，以这个文件夹为根目录创建cpp和h文件，然后好像会自动进里一个build文件夹，然后【F8】就可以把项目run起来了（前提是cpp和h，CMakeLists都是正确的。</p><p>如果想使用debug模式（可以单步执行），需要在CmakeLists里面加入这一句：</p><pre><code>set( CMAKE_BUILD_TYPE &quot;Debug&quot;) //我是加到了工程名下面</code></pre><p>然后想run起来程序，还需要配置，打开【运行】 - 【配置启动器】 - 【Add New-应用程序（左上角加号)】 - 【工程目标选到可执行文件下】 - 【配置相干参数】（我好像是按了F8之后就会提示要这样子做）</p><p>搞定上面那一步之后，主界面的【Execute】就是直接跑，【Debug】就是设置断点模式单步进入，断点需要自己设置在代码每一行的左侧，然后就可以使用【Debug】。在Debug模式中，【F10】是单步运行，【F11】是单步跟进，【F12】是单步跳出，左边还能看到属性的值（看变量值这个真的舒服)。</p><p>(PS:然后我查了查，发现所有的IDE都可以，DEV是调试过程中选中那个变量然后右边【查看变量】，然后左边的窗口就会显示这个变量当前的值了，虽然看多维数组的时候有点麻烦，但好歹能看?)</p><p>(PSS:在今天以前，我一直是用cout来查看变量的值的，dbq，我真的太菜了）</p><p><a href="https://imgchr.com/i/AYk1xI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/24/AYk1xI.jpg" alt="AYk1xI.jpg"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;From：我是一条酸菜鱼。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue学习笔记（1）</title>
    <link href="http://yoursite.com/2019/03/21/vueLearning/vueLearning1/"/>
    <id>http://yoursite.com/2019/03/21/vueLearning/vueLearning1/</id>
    <published>2019-03-21T03:06:42.426Z</published>
    <updated>2019-03-27T06:45:39.705Z</updated>
    
    <content type="html"><![CDATA[<p>我是一条酸菜鱼。</p><a id="more"></a><p><a href="http://http://www.runoob.com/w3cnote/vue2-start-coding.html" target="_blank" rel="noopener">环境配置教程</a></p><p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">官方教程</a></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><img src="http://www.runoob.com/wp-content/uploads/2016/10/1476690217-1155-854231-1d2947692fba4957.png" alt></p><h3 id="配置淘宝镜像"><a href="#配置淘宝镜像" class="headerlink" title="配置淘宝镜像"></a>配置淘宝镜像</h3><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><h3 id="安装相关环境-node-js、cnpm、vue-cli"><a href="#安装相关环境-node-js、cnpm、vue-cli" class="headerlink" title="安装相关环境: node.js、cnpm、vue-cli"></a>安装相关环境: node.js、cnpm、vue-cli</h3><pre><code>npm -g install npm  //更新npm到最新版本cnpm install wekpack -g  npm install vue-cli -g </code></pre><h3 id="新建vue项目流程"><a href="#新建vue项目流程" class="headerlink" title="新建vue项目流程"></a>新建vue项目流程</h3><pre><code>vue init wekpack-simple &lt;name&gt;  //新建vue项目npm install //安装项目依赖cnpm install vue-router vue-resource --save //安装路由模块和网络请求模块npm run dev</code></pre><p>（webstorm好像有点牛逼?验证sysu邮箱可以免费用）</p><p>（感觉sublime + livereload好像也差不多）</p><hr><h3 id="Vue格式"><a href="#Vue格式" class="headerlink" title="Vue格式"></a>Vue格式</h3><pre><code>&lt;template&gt; -&gt; html&lt;script&gt; -&gt; js&lt;style&gt; -&gt; css</code></pre><hr><h2 id="简单语法"><a href="#简单语法" class="headerlink" title="简单语法"></a>简单语法</h2><p><a href="https://cn.vuejs.org/v2/guide/index.html" target="_blank" rel="noopener">官网教程</a></p><ul><li>基于HTML语法</li><li>声明式地绑定DOM和底层Vue实例</li><li>模板编译成虚拟DOM渲染函数（render fun）</li></ul><p>###vue文件</p><ul><li><p>html:</p><pre><code>&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;   //div的id属性，用于css编辑，与web一致&lt;div id=&quot;app-6&quot;&gt;&lt;p&gt;{{ abc }}&lt;/p&gt;   //第一种元素绑定方法，abc为变量名，script中可直接调用（Mustache语法，双大括号）&lt;span v-bind:title=&quot;new2&quot;&gt; //第二种元素绑定方法，new2为变量名，script中直接调用put here&lt;/span&gt;&lt;br/&gt;&lt;button v-on:click=&quot;change&quot;&gt;click here&lt;/button&gt;//与方法绑定，跟C#差不多&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></li></ul><ul><li>script</li></ul><pre><code>export default {  name: &apos;app&apos;,  //给整个vue组件定义变量名，可调用  data () { //vue实例中引用到的变量名    return {      msg: &apos;Welcome to Your Vue.js App&apos;,      abc: &apos;something&apos;,      new2: &apos;currentTime: &apos; + new Date().toLocaleString()}  },  methods: { //vue实例中使用到的函数（方法）    change: function(){      this.abc = &quot;you&quot;    }  }}</code></pre><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>Mustache - 双大括号，绑定的数据对象上msg属性发生改变时，此处改变。</p><pre><code>&lt;span&gt;Message: {{ msg }}&lt;/span&gt;</code></pre><p>使用双大括号会将数据解释成普通文本（如代码)。需要输出真正的HTML，要用v-html指令</p><pre><code>&lt;p&gt;Using mustaches: {{ rawHtml }}&lt;/p&gt; //输出文本&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; //改变样式</code></pre><blockquote><p>你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。</p></blockquote><ul><li><p>ustache 语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令：</p>  <div v-bind:id="dynamicId"></div></li></ul><p>在布尔特性的情况下，它们的存在即暗示为 true，v-bind 工作起来略有不同，在这个例子中：</p><pre><code>&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;</code></pre><p>如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled 特性甚至不会被包含在渲染出来的<code>&lt;button&gt;</code>元素中。</p><p>（突然发现md好像可以支持部分html，<button> 比如这样 </button>)</p><h3 id="vue指令"><a href="#vue指令" class="headerlink" title="vue指令"></a>vue指令</h3><blockquote><p>指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式。vue指令可以直接嵌在html的元素里面中去，也就是直接在元素中加入这一条属性，使用demo如下：</p></blockquote><pre><code>&lt;div id=&quot;app-6&quot;&gt;  &lt;p&gt;{{ message }}&lt;/p&gt;  &lt;input v-model=&quot;message&quot;&gt; //双向绑定，vue指令在这里使用&lt;/div&gt;var app6 = new Vue({  el: &apos;#app-6&apos;,  data: {message: &apos;Hello Vue!&apos;  }})    </code></pre><p>指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p><p>一些vue指令：</p><pre><code>v-bind:title = &quot;abc&quot;  //将元素节点的title 绑定 data中变量名为abc的变量v-if=&quot;a&quot;  //通过控制a，可以控制元素v-for = &quot;i in a&quot;   //循环处理a数组中的元素i的属性v-on:click = &quot;method&quot;  //v-on用于监听DOM事件//click操作调用method函数 click应该可以替换成其他操作v-model = &quot;abc&quot;  //实现表单输入(或其它元素）和应用状态之间的双向绑定v-once //执行一次性地插值</code></pre><p><strong>动态参数</strong></p><p>应该就是v-指令后面可以连接一个用方括号括起来的JS表达式（变量名），使得绑定的参数可以更灵活地动态调整。</p><p>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p><pre><code>&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;</code></pre><p>这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data 属性 attributeName，其值为 “href”，那么这个绑定将等价于 v-bind:href 。</p><p>详见<a href="https://cn.vuejs.org/v2/guide/syntax.html" target="_blank" rel="noopener">教程</a></p><p><strong>一些约束</strong></p><ul><li>动态参数的值应该是一个字符串，异常状态下是 null。（赋值null可以移除绑定？）</li><li>语法约束，某些字符（空格、引号）可能无效</li><li>浏览器会把特性名全部强制转换为小写，使用大写变量可能会出现问题</li><li>修饰符（半角句号 . 指明的特殊后缀)</li></ul><p>E: .prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：</p><pre><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;</code></pre><ul><li><p>缩写: Vue 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写：</p><pre><code>&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;--------------------------&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</code></pre></li></ul><h3 id="Vue实例中js使用"><a href="#Vue实例中js使用" class="headerlink" title="Vue实例中js使用"></a>Vue实例中js使用</h3><ul><li>可以绑定简单的属性键值</li><li>包括单个表达式，非语句 </li></ul><pre><code> //不生效 * 2{{var a = 1}}  {{ if (ok) { return message } }}</code></pre><hr><h3 id="关于-new-vue-和-export-default-的区别"><a href="#关于-new-vue-和-export-default-的区别" class="headerlink" title="关于 new vue 和 export default 的区别"></a>关于 new vue 和 export default 的区别</h3><blockquote><hr><p>在main.js当中已经有一个new vue了。作为被main.js  import的APP.vue ，App.vue当中应当有export default，这样才能在main.js中引入（也就是import）APP.vue当中的内容。</p></blockquote><blockquote><p>new vue是生成Vue根实例，而export default则是用来导出的。export default相当于提供一个接口给外界，让外界（这里也就是main.js）来引入使用。</p></blockquote><blockquote><p>在不使用App.vue 文件时，我们是通过 Vue 构造函数（new vue）创建一个 Vue 根实例来启动vuejs 项目，Vue 构造函数接受一个对象，这个对象有一些配置属性 el, data, component, template 等，从而对整个应用提供支持。</p></blockquote><blockquote><p>而现在我们的vue项目建好之后，有.vue也有.js，此时，在App.vue文件中，export default 后面的对象就相当于 new Vue() 构造函数中的接受的对象。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是一条酸菜鱼。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>系统分析与设计—hw3</title>
    <link href="http://yoursite.com/2019/03/13/swsadHw/swsadhw3/"/>
    <id>http://yoursite.com/2019/03/13/swsadHw/swsadhw3/</id>
    <published>2019-03-13T02:04:00.010Z</published>
    <updated>2019-03-13T07:00:50.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【简答题】"><a href="#【简答题】" class="headerlink" title="【简答题】"></a>【简答题】</h3><p><strong>1.简述瀑布模型、增量模型、螺旋模型（含原型方法）的优缺点（从项目特点、风险特征、人力资源利用角度思考）</strong></p><a id="more"></a><ul><li><p>瀑布模型:</p><ul><li>简述：瀑布模型设置了一系列的阶段，按顺序进行开发，项目开发进程从一个阶段流动到下一个阶段，形式上与物理世界中的瀑布非常相像。同时，每个阶段都会产生循环反馈，对临近阶段进行影响。</li><li>优点：<ul><li>降低软件开发的复杂程度，提高软件开发过程的透明性；同时，由于开发的基本流程和活动都是易理解的，因此提高了软件开发过程的可管理性。</li><li>推迟软件实现，强调在软件实现前必须进行分析和设计工作。</li><li>以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，保证了阶段之间的正确衔接，能够及时发现并纠正开发过程中存在的缺陷，使产品达到预期的质量要求。</li></ul></li><li>缺点：<ul><li>强调过程活动的线性顺序，因此理论上需要保证需求明确，且短期内可获得，每个阶段是无差错的。</li><li>缺乏灵活性，尤其无法解决软件需求不明确或不准确的问题。同时，在后期发现需求问题，更改的工作量十分巨大。</li><li>风险控制能力较弱，当前面需求模糊/前方成果不完善，会对后阶段产生巨大影响。</li><li>瀑布模型中的软件活动是文档驱动的，当阶段之间规定过多的文档时，会极大地增加系统的工作量。</li><li>管理人员如果仅仅以文档的完成情况来评估项目完成进度，往往会产生错误的结论，容易被人为误导。</li></ul></li></ul></li><li><p>增量模型:</p><ul><li>简述：增量模型是把待开发的软件系统模块化，将每个模块作为一个增量组件，分批次地分析、设计、编码和测试这些组块，具有一个递增式的开发过程。</li><li>优点：<ul><li>将待开发的软件系统模块化，可以分批次地提交软件产品，进行迭代式的开发，遵循“先做出来可以用的软件，再把软件做好。”的原则，因此对开发方较友好。</li><li>由于软件产品模块化交付，因此用户可以及时了解软件项目的进展并给出反馈，使得用户可以及时了解到项目进展，提升其在软件开发阶段的参与度和对项目的信息。</li><li>开发顺序灵活，开发人员可以对组件的实现顺序进行选择和优先级排序，先完成需求稳定的核心组件。当组件的优先级发生变化时，还能及时地对实现顺序进行调整。</li><li>降低了软件开发的风险，出现在组件中的错误可以被灵活解决，而不会对整个软件系统造成巨大的影响。</li></ul></li><li>缺点:<ul><li>待开发的软件系统需要可以被模块化；使用增量模型对难以模块化的软件系统进行开发会导致很多的问题：如模块划分，功能交付等。</li><li>增量粒度难以选择。</li><li>为了将软件系统分成多个模块，需要增加额外的工作量。</li></ul></li></ul></li><li><p>螺旋模型（含原型方法）：</p><ul><li>简述：螺旋模型采用周期性的方法进行开发，以进化的开发方式为中心，在不断迭代的过程中完成开发，且强调风险分析。</li><li><p>优点：</p><ul><li>设计上具有灵活性，可以在项目的各个阶段中或是下一次迭代中完成变更，可以不需要在一开始就给出具体明确的需求。</li><li>以小的分段来构造大型的系统，易于计算成本。</li><li>进行了风险分析，使得项目具有更高的可靠性。</li><li>由于快速原型法需要客户使用并提供反馈，因此提升了客户的参与度，保证了项目与客户需求是一致的，项目是可控的。同时提升了客户对项目的信心，对开发团队的认可。</li></ul></li><li><p>缺点：</p><ul><li>没有明确的项目终点，需要根据项目的具体进度进行判断。</li><li>建设周期长，可能导致软件开发的需求或核心技术与现实产生差距，无法满足当前用户的需求。</li><li>需要使用户确信这种模型的开发方法的结果是可以控制的。</li></ul></li></ul></li></ul><p><strong>2.简述统一过程三大特点，与面向对象的方法有什么关系？</strong></p><p>统一过程（Unified Process，UP）是一种以用例驱动的、以体系结构为核心的、迭代和增量的软件过程模型。由UML方法和工具支持，广泛应用于各类面向对象项目。<br>统一过程的三大特点分别是：</p><ol><li>软件开发是一个迭代的过程，是一种受控的迭代和增量式开发。</li><li>软件开发是由用例（Use Case）驱动的，也就是通过测试来推动整个开发过程的进行，在测试中完成需求分析、设计、质量控制等过程。这为整个开发过程提供了高效的驱动力。</li><li>软件开发是以体系结构为核心的。</li></ol><p><strong>3.简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？</strong></p><p>UP项目将其工作和迭代组织为四个主要阶段： </p><ol><li>初始（Inception）：大体上的构想、业务案例、范围和模糊评估。 <ul><li>里程碑：生命周期目标里程碑，包括一些重要的文档，如：项目构想(Vision)、原始用例模型、原始业务风险评估、一个或者多个原型、原始业务案例等。需要对这些文档进行评审，以确定正确理解用例需求、项目风险评估合理、阶段计划可行等。 </li></ul></li><li>细化（Elaboration）：已精化的构想、核心架构的迭代实现、高风险的解决、确定大多数需求和范围以及进行更为实际的评估。 <ul><li>里程碑：生命周期体系结构(Lifecycle Architecture) 里程碑。包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等。通过评审确定软件体系结构已经稳定、高风险的业务需求和技术机制已经解决、修订的项目计划可行等。 </li></ul></li><li>构造（Construction）：对遗留下来的风险较低和比较简单的元素进行迭代实现，准备部署。 <ul><li>里程碑：初始运行能力(Initial Operational Capability) 里程碑。包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署。此刻，要确定软件、环境、用户是否可以开始系统的运行。 </li></ul></li><li>移交（Transition）：进行beta测试和部署。 <ul><li>里程碑：产品发布(Product Release) 里程碑。确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周期。在一些情况下这个里程碑可能与下一个周期的初始阶段的相重合。</li></ul></li></ol><p>下图提供了一个可视化的循环过程：<br><img src="https://img-blog.csdnimg.cn/20190313144706784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1llem8xMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>4.软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？</strong></p><p>当企业使用UP进行软件开发时，基于UP迭代式、增量式的开发特点，整个开发过程可以被划分为几个固定的阶段和多次迭代的过程。也就是说，整个开发过程被划分成了固定的开发周期，因此企业就可以按照固定的节奏进行软件生产，也可以得到预期的生产周期并以此来形成一个发布软件产品的固定周期。<br>UP本身的特性，使得其可应用于各种领域的软件开发和不同的项目规模。其带来的好处有：</p><ul><li>企业可以将项目格式化、流程化，并对每一个流程标定固定的工作内容，使得整个系统架构更具有鲁棒性。</li><li>项目管理者以及客户都可以更了解开发进度、存在的问题和预期的目标，有利于开发者和使用者的交流，使得项目开发不会与需求偏差过大</li><li>开发过程可以进行风险分析和需求理解，降低了项目失败的概率</li></ul><hr><p>###【实践题】</p><p>了解使用 TAPD 的最佳实践</p><ul><li>比较完善 backlog 支持（树结构）</li><li>迭代（sprint）安排</li><li>较好的缺陷管理</li><li>Kanban</li><li>统计</li></ul><p>###【大作业准备】</p><ul><li>按大作业要求组件团队、思考项目题目与内容</li><li>将团队暂时分为技术研究、业务调研两个部分<ul><li>技术团队初步确定技术方法，力争做一些技术原型，如 基于 MVC 框架的的用户登陆实现</li><li>业务调研团队调查竞争性产品，分析它们的基础、共性业务以及竞争优势</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【简答题】&quot;&gt;&lt;a href=&quot;#【简答题】&quot; class=&quot;headerlink&quot; title=&quot;【简答题】&quot;&gt;&lt;/a&gt;【简答题】&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.简述瀑布模型、增量模型、螺旋模型（含原型方法）的优缺点（从项目特点、风险特征、人力资源利用角度思考）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>系统分析与设计—hw2</title>
    <link href="http://yoursite.com/2019/03/09/swsadHw/swsadhw2/"/>
    <id>http://yoursite.com/2019/03/09/swsadHw/swsadhw2/</id>
    <published>2019-03-09T04:36:48.585Z</published>
    <updated>2019-03-18T02:21:47.558Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【简答题】"><a href="#【简答题】" class="headerlink" title="【简答题】"></a>【简答题】</h3><p><strong>1.用简短的语言给出对分析、设计的理解。</strong></p><p>分析就是对用户给出的软件功能等方面的需求进行系统的研究，识别出主号问题，确定待开发软件的功能、性能、接口、数据、界面等具体的细节要求。<br>设计就是基于需求分析中得到的需求，构造出目标系统的逻辑模型，最终得到一个可供编码过程参考的设计模型文档。</p><blockquote><p>软件分析不是发现更多的功能与需求，而是确认有效的功能与需求，去伪存真不断满足客户需要。软件设计也不是追求最先进技术，而是控制变化附加的成本，使得软件生产的预算、时间等能在掌控之中。</p></blockquote><a id="more"></a><hr><p><strong>2.用一句话描述面向对象的分析与设计的优势。</strong></p><p>面向对象的分析与设计能够通过分析现实世界中存在的问题，并构建相对应的问题模型，保持了他们的结构、关系和行为模式，具有易理解和易维护的特性。</p><hr><p><strong>3.简述 UML（统一建模语言）的作用。考试考哪些图？</strong></p><p>UML（Unified Modeling Language）用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品。 它可以将面向对象分析（OOA）和面向对象设计（OOD）使用统一定义的符号表示出来，并将对象自身的属性、对象与对象之间的关联关系可视化，提升项目结构的可读性。</p><p>考试的重点图形: </p><p>图形化的表示机制，十多种视图，分4类：</p><ul><li>用例图：用户角度：功能、执行者</li><li>静态图：系统静态结构<ul><li>类图：概念及关系</li><li>对象图：某种状态或时间段内，系统中活跃的对象及其关系</li><li>包图：描述系统的分解结构</li></ul></li><li>行为图：系统的动态行为<ul><li>交互图：描述对象间的消息传递<ul><li>顺序图：强调对象间消息发送的时序</li><li>合作图：强调对象间的动态协作关系</li></ul></li><li>状态图：对象的动态行为。状态-事件-状态迁移-响应动作</li><li>活动图：描述系统为完成某功能而执行的操作序列</li></ul></li><li>实现图：描述系统的组成和分布状况<ul><li>构件图：组成部件及其关系</li><li>部署图：物理体系结构及与软件单元的对应关系</li></ul></li></ul><hr><p><strong>4.从软件本质的角度，解释软件范围（需求）控制的可行性</strong></p><p>软件的本质包括复杂性、一致性、可变性和不可视性。基于IEEE中给出的软件特点：</p><blockquote><ul><li>Software requirements are prone to frequent change</li><li>In many cases, requirements allocated to software must be renegotiated and reprioritized</li><li>Small changes to software can have large negative effects（There are no small software changes） </li></ul></blockquote><p>对于软件的需求可能会因为不一致、不可使、易于变化的环境而更改，需求的更改会带来软件的改动，这就可能会产生巨大的负面影响，包括开发难度的增加，开发周期的增长等。为了尽可能避免以上情况的发生，我们必须对软件需求进行范围的划定和控制。即在需求分析与设计的过程中，我们必须在给定的范围内围绕软件开发的成本进行调控，允许范围内、不造成巨大影响的需求变更和迭代，最终保证软件开发周期和成本是可控的，在约定的时间内交付出可满足客户的软件成品。因此，软件范围需求控制是可行且必须的。</p><hr><p>###【看板使用练习】<br><a href="https://imgchr.com/i/AmZyQJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmZyQJ.jpg" alt="AmZyQJ.jpg"></a><br><a href="https://imgchr.com/i/AmZvY8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmZvY8.md.png" alt="AmZvY8.md.png"></a></p><p>###【UML绘图工具练习】</p><p>图选自  《UML和模式应用（中文第三版）》 P193  </p><p> <strong>图16-16 UML中的关联类</strong><br><a href="https://imgchr.com/i/AmVzrR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmVzrR.jpg" alt="AmVzrR.jpg"></a></p><p><strong>图16-17 表示单实例类</strong><br><a href="https://imgchr.com/i/AmZSq1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmZSq1.jpg" alt="AmZSq1.jpg"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【简答题】&quot;&gt;&lt;a href=&quot;#【简答题】&quot; class=&quot;headerlink&quot; title=&quot;【简答题】&quot;&gt;&lt;/a&gt;【简答题】&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.用简短的语言给出对分析、设计的理解。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分析就是对用户给出的软件功能等方面的需求进行系统的研究，识别出主号问题，确定待开发软件的功能、性能、接口、数据、界面等具体的细节要求。&lt;br&gt;设计就是基于需求分析中得到的需求，构造出目标系统的逻辑模型，最终得到一个可供编码过程参考的设计模型文档。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;软件分析不是发现更多的功能与需求，而是确认有效的功能与需求，去伪存真不断满足客户需要。软件设计也不是追求最先进技术，而是控制变化附加的成本，使得软件生产的预算、时间等能在掌控之中。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>系统分析与设计—hw1</title>
    <link href="http://yoursite.com/2019/03/06/swsadHw/swsadhw1/"/>
    <id>http://yoursite.com/2019/03/06/swsadHw/swsadhw1/</id>
    <published>2019-03-06T02:35:02.621Z</published>
    <updated>2019-03-10T10:40:04.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【简答题】"><a href="#【简答题】" class="headerlink" title="【简答题】"></a>【简答题】</h3><p><strong>1.软件工程的定义</strong></p><blockquote><p>Software engineering is “(1) the application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software, that is, the application of engineering to software,” and “(2) the study of approaches as in (1).” –– IEEE Standard 610.12</p></blockquote><p>软件工程的定义： </p><ul><li>(1) 将系统化、规范化、可度量的方法应用与软件的开发、运行和维护-的过程，即将工程化应用于软件中。 </li><li>(2) 对(1)中所述方法的研究。</li></ul><p>软件工程知识体系:</p><ul><li>以高质量为目标，研究软件生产的过程模型、方法和工具</li></ul><a id="more"></a><hr><p><strong>2.解释导致 software crisis 本质原因、表现，述说克服软件危机的方法</strong><br>软件危机（Software Crisis）是一个早期的计算机科学用语，指的是在给定时间内编写出可用和高效的程序的困难性。现在引申至指软件在开发和维护过程中出现的一系列严重的问题。<br>在1972年，Edsger Dijkstra 指出计算能力约强大，编程越是大问题。因此导致软件危机的本质原因是计算机计算能力的迅速增长，以及计算机能力增长而导致软件需要处理和解决的问题具有更大的复杂性。也就是计算机计算能力的提高超过了程序员能够高效利用计算机的能力。<br>软件危机的主要表现有：</p><ul><li>进行了超预算的项目</li><li>项目长期无法完成</li><li>软件非常低效</li><li>软件质量低下</li><li>软件经常与用户的需求不匹配</li><li>项目难以管理</li><li>程序代码的后期维护存在困难</li><li>软件无法完成并交付</li></ul><hr><p><strong>3.软件生命周期</strong></p><p>软件生命周期（Software Development LifeCycle）是指软件的产生直到成熟的全部过程。早期的软件生命周期受到瀑布模型的影响，因此通常定义为：</p><blockquote><p>软件从计划、需求开始，经历分析设计、实现、部署、维护，直到最后逐渐消亡的。</p></blockquote><p>因此，现在对软件生命周期及软件生命周期模型采用如下定义：</p><ul><li>软件生命周期是指软件的产生直到成熟的全部过程。</li><li>软件生命周期模型是指人们为开发更好的软件而归纳总结的软件生命周期的典型实践参考。</li></ul><p>根据GB/T 8567的定义，软件生命周期分为以下6个阶段：</p><ul><li>可行性分析与计划</li><li>需求分析</li><li>设计（概要设计和详细设计）</li><li>编码实现</li><li>测试</li><li>运行和维护</li></ul><p>常见的软件生命周期模型有原型模型、螺旋模型、迭代模型。</p><hr><p><strong>4.SWEBoK 的 15 个知识域（An Overview of the SWEBOK Guide 请中文翻译其名称与简短说明）</strong></p><p>SWEBOK V3中的15个知识域包括：</p><p><strong>11个软件工程实践知识域：</strong></p><ul><li><strong>软件需求 Software requirements</strong><br>真实世界问题而必须展示的特性。软件需求的知识域包括七个子域，即软件需求基础、需求过程、需求获取、需求分析、需求规格说明、需求确认和实践考虑。</li><li><strong>软件设计 Software design</strong><br>根据IEEE [ IEEE 610.12-90] ，设计既是”定义一个系统或组件的体系结构、组件、接口和其他特征的过程”，又是”这个过程的结果”。软件设计的知识域包括六个子域，即软件设计基础、软件设计关键问题、软件结构与体系结构、软件设计质量的分析与评价、软件设计符号、软件设计的策略与方法。</li><li><strong>软件构造 Software construction</strong><br>它指通过编码、验证、单元测试、集成测试和排错的组合，具体创建一个可以工作的、有意义的软件，其知识域包括软件构造基础、管理构造、实际考虑三个子域。</li><li><strong>软件测试 Software testing</strong><br>它是由在有限测试用例集合上，根据期望的行为，对程序的行为进行的动态验证组成， 测试用倒是实际上无限的执行域中适当选择出来的。软件测试包括五个子域，即软件测试基础和测试级别、测试技术、需求分析、与测试相关的度量、测试过程。</li><li><strong>软件维护 Software maintenance</strong><br>软件一旦投入运行，就可能出现异常，运行环境可能发生改变，用户会提出新的需求。生命周期软件维护阶段从软件交付时开始，但是维护活动出现得还要早。软件维护的知识域包括四个子域，即软件维护基础、软件维护的关键问题、维护过程、维护技术。</li><li><strong>软件配置管理 Software configuration management</strong><br>为了系统地控制配置的变更和维护在整个系统生命周期中的完整性和可追踪性，而标志软件在时间上不同点的配置的学科。软件配置管理包括六个子域，即软件配置管理过程管理、软件配置标志、软件配置控制、软件配置状态统计、软件配置审核、软件发行管理和交付。</li><li><strong>软件工程管理 Software engineering management</strong><br>处理软件工程的管理与度量，虽然度量是所有知识域的一个重要方面，但是这里涉及的是度量程序的专题。软件工程管理包括六个子域，即启动和范围定义、软件项目计划、软件项目实施、评审与评价、关闭、软件工程度量。前五个覆盖软件过程工程 管理，第六个描述软件度量的程序。</li><li><strong>软件工程过程 Software engineering process</strong><br>涉及软件工程过程本身的定义、实现、评定、度量、管理、变更和改进。软件工程过程包括四个子域，即过程实施与改变、过程定义、过程评定、过程和产品度量。</li><li><strong>软件工程模型和方法  Software engineering models and methods</strong><br>包括软件工程工具、软件工程方法两个子域。</li><li><strong>软件质量 Software quality</strong><br>处理跨越软件生命周期过程的软件质量的考虑，由于软件质量在软件工程中元处不在，其他知识域也涉及质量 问 题。软件质量包括三个子域，即软件质量基础、软件质量过程、实践考虑。</li><li><strong>软件工程职业实践 Software engineering professional practice</strong></li></ul><p><strong>4个软件工程教育基础知识域：</strong></p><ul><li><strong>软件工程经济学 Software engineering economics</strong></li><li><strong>计算基础 Computing foundations</strong></li><li><strong>数学基础 Mathematical foundations</strong></li><li><strong>工程基础 Engineering foundations</strong></li></ul><hr><p><strong>5.简单解释 CMMI 的五个级别。例如：Level 1 - Initial：无序，自发生产模式。</strong></p><p>能力成熟度模型集成（英语：Capability Maturity Model Integration，简称CMMI或“希迈”）是一种改进过程的方法，其目的是协助提升组织的绩效。</p><p><strong>Level 1 - Initial：初始级。</strong><br>软件过程是无序的，有时甚至是混乱的，对过程几乎没有定义，成功取决于个人努力。管理是反应式的。</p><p><strong>Level 2 - Managed：可管理级。</strong><br>建立了基本的项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。</p><p><strong>Level 3 - Defined：已定义级。</strong><br>已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。</p><p><strong>Level 4 - Quantitatively Managed：量化管理级。</strong><br>分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。</p><p><strong>Level 5 - Optimizing：优化管理级。</strong><br>过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。</p><hr><p><strong>6.用自己语言简述 SWEBok 或 CMMI （约200字）</strong></p><p>SWEBok即软件工程知识体系指南（Guide to the Software Engineering Body of Knowledge)，是一个得到普遍认可的共识性软件工程本体知识结构。（其历史可追溯到1999年4月由发表的《软件工程知识本体结构》报告。报告的发布使人们达成了共识，即建立软件工程本体知识结构是解决如何验证软件工程工程师的资格、如何设置并检验软件工程相关课程等难题的答案。）SWEBok的目的是为软件工程学科的范围提供一致的认识，为支持该学科的本体知识提供指导。SWEBOK V3将软件工程学科的本体知识分为15个知识域，并对每个知识域中的重要概念和区别加以阐述说明。也就是说，SWEBok最大的贡献是将原本混杂的软件工程知识体系化，将原本存在的知识分类整理，最后形成一个具有共识性和方向性的指南。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【简答题】&quot;&gt;&lt;a href=&quot;#【简答题】&quot; class=&quot;headerlink&quot; title=&quot;【简答题】&quot;&gt;&lt;/a&gt;【简答题】&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.软件工程的定义&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Software engineering is “(1) the application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software, that is, the application of engineering to software,” and “(2) the study of approaches as in (1).” –– IEEE Standard 610.12&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;软件工程的定义： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) 将系统化、规范化、可度量的方法应用与软件的开发、运行和维护-的过程，即将工程化应用于软件中。 &lt;/li&gt;
&lt;li&gt;(2) 对(1)中所述方法的研究。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;软件工程知识体系:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以高质量为目标，研究软件生产的过程模型、方法和工具&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BringMeFly</title>
    <link href="http://yoursite.com/2019/02/27/Personal/hello-world/"/>
    <id>http://yoursite.com/2019/02/27/Personal/hello-world/</id>
    <published>2019-02-27T09:14:41.217Z</published>
    <updated>2019-03-10T10:39:02.240Z</updated>
    
    <content type="html"><![CDATA[<p>Update it when i have time.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Update it when i have time.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
