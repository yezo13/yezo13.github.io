<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>酸菜鱼的SLAM之旅（5）</title>
      <link href="/2019/03/27/SLAM/ch8_%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A12/"/>
      <url>/2019/03/27/SLAM/ch8_%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A12/</url>
      
        <content type="html"><![CDATA[<h2 id="2019年3月27日：视觉里程计-直接法"><a href="#2019年3月27日：视觉里程计-直接法" class="headerlink" title="2019年3月27日：视觉里程计 - 直接法"></a>2019年3月27日：视觉里程计 - 直接法</h2><a id="more"></a><p>keyword：直接法、光流法、g2o</p><h2 id="直接法"><a href="#直接法" class="headerlink" title="直接法"></a>直接法</h2><h3 id="特征点法的一些问题"><a href="#特征点法的一些问题" class="headerlink" title="特征点法的一些问题:"></a>特征点法的一些问题:</h3><ul><li>关键点的提取和描述子的计算很耗时</li><li>只使用特征点丢弃了大部分可能有用的图像信息</li><li>相机有时候会运动到特征缺失的地方，找不到足够的匹配点来计算相机的运动</li></ul><h3 id="解决问题的思路："><a href="#解决问题的思路：" class="headerlink" title="解决问题的思路："></a>解决问题的思路：</h3><ul><li>保留特征点，但只计算关键点，不计算描述子，使用<strong>光流法（Optical Flow）</strong>来跟踪特征点的运动。这样仍然使用特征点，只是将匹配描述子替换成光流跟踪，估计相机运动使用与特征点法<strong>相同</strong>的算法（对极几何、PnP或ICP）。</li><li>只计算关键点，不计算描述子，使用<strong>直接法（Direct Method）</strong>来计算特征点在下一时刻图像的位置。</li><li>不计算关键点和描述子，直接根据图像灰度的差异，<strong>直接</strong>计算相机运动。</li></ul><p>后两种方法都根据图像的<strong>像素灰度信息</strong>来计算相机运动，称为<strong>直接法</strong>。</p><h3 id="两种方法特性比较"><a href="#两种方法特性比较" class="headerlink" title="两种方法特性比较"></a>两种方法特性比较</h3><ul><li>特征点法：<ul><li>特征点看作固定在三维空间的不动点</li><li>根据投影位置，最小化重投影误差（Reprojection error）来优化相机运动</li><li>需要知道空间点在两个相机中投影的精确像素位置（对特征进行匹配和跟踪）</li><li>计算量大，精确</li><li>只能重构稀疏特征点（稀疏地图）</li></ul></li></ul><hr><ul><li>直接法：<ul><li>通过最小化光度误差（Photometric error）求点与点之间的对应关系，不计算关键点和描述子</li><li>根据像素的亮度信息（场景中的明暗变化）估计相机的运动</li><li>分为稀疏、稠密、半稠密三种，具有恢复稠密或半稠密结构的能力</li><li>避免了特征的计算时间和特征缺失的情况，但不够精确</li></ul></li></ul><h2 id="光流"><a href="#光流" class="headerlink" title="光流"></a>光流</h2><blockquote><p>光流是一种描述像素随着时间，在图像之间运动的方法。计算部分像素运动的称为稀疏光流，计算所有像素的称为稠密光流。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>酸菜鱼的SLAM之旅（4）</title>
      <link href="/2019/03/27/SLAM/ch7_%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A11/"/>
      <url>/2019/03/27/SLAM/ch7_%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A11/</url>
      
        <content type="html"><![CDATA[<h2 id="2019年3月27日：视觉里程计-特征点法"><a href="#2019年3月27日：视觉里程计-特征点法" class="headerlink" title="2019年3月27日：视觉里程计 - 特征点法"></a>2019年3月27日：视觉里程计 - 特征点法</h2><a id="more"></a><p>keyword：图像特征点、极几何、PNP问题、ICP问题、三角化</p><h2 id="特征点法"><a href="#特征点法" class="headerlink" title="特征点法"></a>特征点法</h2><p>视觉SLAM主要分为视觉前端和优化后端，前端也称为<strong>视觉里程计（VO）</strong>。它根据相邻图像的信息，估计出粗略的相机运动，给后端提供较好的初始值。</p><ul><li>按照是否需要提取特征区分VO的实现方法:<ul><li>需要提取特征：特征点法的前端（主流方法)<ul><li>运行稳定</li><li>对光照、动态物体不敏感</li></ul></li><li>不提取特征：直接法前端</li></ul></li></ul><h3 id="特征点"><a href="#特征点" class="headerlink" title="特征点"></a>特征点</h3><p>VO的主要问题是如何根据图像来估计相机运动。由于图像本身是一个由<strong>亮度和色度组成的矩阵</strong>，因此<strong>很难</strong>直接从矩阵层面考虑运动估计。因此，常见做法如下:</p><ol><li>从图像中选取比较<strong>有代表性</strong>的点，主要体现在这些点在相机视角发生<strong>少量变化</strong>后<strong>保持不变</strong>，即我们在<strong>连续</strong>的各个图像中都能找到<strong>相同的点。</strong></li><li>在这些点的基础上讨论相机的位姿估计问题和这些点的定位问题。</li><li>在经典SLAM模型中，这些有代表性的点称为<strong>路标</strong>；在视觉SLAM中，路标则是指<strong>图像特征（Features）</strong>。</li></ol><blockquote><p>图像特征是一组与计算任务相关的信息，计算任务取决于具体的应用。   —— 维基百科</p></blockquote><ul><li>特征是图像信息的另一种数字表达形式（如单个图像像素也是一种“特征”)</li><li>在OV中，希望特征点在相机运动之后保持稳定。而灰度值（像素)受外界因素影响严重，在不同图像之间变化很大。因此我们需要对图像提取特征点（图像里一些特别的地方）。</li><li>特征点：从不同的图像间存在更强的辨识度，如角点。一种直观的提取特征的方式就是在不同图像间辨认角点（不满足视觉SLAM的需求），确定它们的对应关系。在这种做法中，角点就是所谓的特征。</li></ul><hr><p>CV中设计了比角点更稳定的局部图像特征，需要拥有以下特性：</p><ol><li>可重复性（Repeatability）：相同的“区域”可以在不同的图像中被找到。</li><li>可区别性（Distinctiveness）：不同的“区域”有不同的表达。</li><li>高效率（Efficiency）：同一图像中，特征点的数量应远小于像素的数量。</li><li>本地性（Locality）：特征仅与一小片图像区域相关。</li></ol><p>e.g. SIFT[30], SURF[31], ORB[32]</p><hr><p>特征点由<strong>关键点（Key-point）</strong>和<strong>描述子（Descriptor）</strong>两部分组成。比方说，当我们<br>谈论 SIFT 特征时，是指“提取 SIFT 关键点，并计算 SIFT 描述子”两件事情。</p><p>具体结构如下:</p><ul><li>特征点：<ul><li>关键点 (Key-point)：该特征点在图像里的<strong>位置</strong>，可能包括朝向、大小等信息</li><li>描述子 (Descriptor)：按照某种人为设计的方式描述该关键点<strong>周围像素的信息</strong>。    <ul><li>原则：外观相似的特征应该有相似的描述子</li><li>两个特征点的描述子在<strong>向量空间上的距离相近</strong>，就可以认为它们是<strong>同样</strong>的特征点</li></ul></li></ul></li></ul><p>一些图像特征：</p><ul><li>尺度不变特征转换(SIFT)<ul><li>Scale-invariant feature transform</li><li>是一种机器视觉的算法用来侦测与描述影像中的局部性特征，它在空间尺度中寻找极值点，并提取出其位置、尺度、旋转不变数。</li><li>它充分考虑了在图像变换过程中出现的光照，尺度，旋转等变化，但随之而来的是<strong>极大</strong>的计算量。</li><li>普通PC的CPU还无法实时地计算SIFT特征，进行定位与建图。所以在SLAM中我们甚少使用这种“奢侈”的图像特征。</li><li>通过GPU加速的SIFT可以满足实时计算要求，但成本提升。</li></ul></li></ul><hr><ul><li>FAST<strong>关键点</strong><ul><li>属于计算特别快的一种特征点</li><li>没有描述子，因此不具有方向性</li></ul></li></ul><hr><ul><li>ORB特征<ul><li>Oriented FAST and Rotated BRIEF</li><li>非常具有代表性的实时图像特征，对于实时性要求很高的SLAM来说是一个很好的选择。</li><li>它改进了FAST 检测子[33] 不具有方向性的问题，并采用速度极快的二进制描述子BRIEF，使整个图像特征提取的环节大大加速。</li><li>保持了特征子具有旋转、尺度不变性的同时，速度方面提升明显，是质量与性能之间较号的折中。</li></ul></li></ul><h3 id="ORB特征"><a href="#ORB特征" class="headerlink" title="ORB特征"></a>ORB特征</h3><p>ORB特征的结构如下:</p><ul><li><p>ORB特征</p><ul><li><p>关键点：Oriented FAST， 是一种改进的Fast角点</p></li><li><p>描述子：BRIEF（Binary Robust Independent Elementary Features）</p></li></ul></li></ul><p>提取ORB 特征分为两个步骤：</p><ol><li>FAST 角点提取：找出图像中的” 角点”。相较于原版的FAST, ORB 中计算了特征点的主方向，为后续的BRIEF 描述子增加了旋转不变特性。</li><li>BRIEF 描述子：对前一步提取出特征点的周围图像区域进行描述。</li></ol><h4 id="FAST特征点："><a href="#FAST特征点：" class="headerlink" title="FAST特征点："></a>FAST特征点：</h4><p>(图中显示的就是检测一个像素点P是否FAST点的过程）<br><img src="https://s2.ax1x.com/2019/03/27/Adde1O.png" alt="Adde1O.png"></p><p>FAST是一种角点：</p><ul><li><strong>思想</strong>：如果一个像素与它的邻域的像素差别过大（过亮/过暗），那么它更可能是角点</li><li><strong>方法</strong>：主要检测局部像素灰度变化明显的地方</li><li><strong>优势</strong>：只需要比较像素亮度的大小，速度快</li><li>测试过程前可以进行<strong>预测试操作</strong>，<strong>快速排除绝大多数不是角点的元素</strong>：<ul><li>对于每个像素，直接检测邻域圆上的第1，5，9，13 个像素的亮度。只有当这四个像素中有三个同时大于Ip + T 或小于Ip - T 时，当前像素才有可能是一个角点，否则应该直接排除。</li></ul></li><li><strong>正常检测过程:</strong><ol><li>在图像中选取像素p，假设它的亮度为Ip。</li><li>设置一个阈值T(比如Ip 的20%)。</li><li>以像素p为中心, 选取半径为3的圆上的16 个像素点。</li><li>假如选取的圆上，有连续的N个点的亮度大于Ip + T 或小于Ip - T，那么像素p可以被认为是特征点(N 通常取12，即为FAST-12。其它常用的N取值为9和11，他们分别被称为FAST-9，FAST-11)。</li><li>循环以上四步，对每一个像素执行相同的操作。</li></ol></li><li><strong>FAST角点的一些原始问题:</strong><ul><li>原始Fast角点经常出现“扎堆”现象，即同一片区域出现多个角点，因此需要使用非极大值抑制（Non-maximal suppression），在一定区域内仅保留响应极大值的角点，避免角点集中的问题。</li><li>FAST特征点数量很大且不确定</li><li>FAST角点不具有方向信息</li><li>固定取半径为3的圆，存在尺度问题：远处看着像是角点的地方，接近后看可能就不是角点了</li></ul></li><li><strong>ORB对原始FAST算法的改进</strong><ul><li>先指定最终要提取的角点数量N，对原始FAST角点分别计算Harris响应值，然后选取前N个具有最大响应值的角点，作为最终的角点集合。</li><li>ORB 添加了尺度和旋转的描述。尺度不变性由构建图像金字塔，并在金字塔的每一层上检测角点来实现。</li></ul></li></ul><p><img src="https://s2.ax1x.com/2019/03/27/AddCnJ.jpg" alt="AddCnJ.jpg"></p><hr><h4 id="BRIEF-描述子"><a href="#BRIEF-描述子" class="headerlink" title="BRIEF 描述子"></a>BRIEF 描述子</h4><blockquote><p>BRIEF 是一种二进制描述子，它的描述向量由许多个 0 和 1 组成，这里的 0 和 1 编码了关键点附近两个像素（比如说 p 和q ）的大小关系：如果 p 比 q 大，则取1，反之就取0。如果我们取了128个这样的p，q，最后就得到128维由 0，1 组成的向量。</p></blockquote><ul><li>BRIEF使用了随机选点比较，速度快</li><li>使用二进制表达，存储方便，适用于实时的图像匹配</li><li>原始的BIRIEF描述子不具有旋转不变性，在图像发生旋转时容易丢失</li><li>ORB在FAST特征点提取阶段计算了关键点的方向，所以可以利用方向信息，计算旋转之后的“steer BRIEF”特征，使得ORB的描述子具有较好的旋转不变性</li></ul><h3 id="特征匹配"><a href="#特征匹配" class="headerlink" title="特征匹配"></a>特征匹配</h3><blockquote><p>宽泛地说，特征匹配解决了SLAM中的数据关联问题（data association），即确定当前看到的路标与之前看到的路标之间的对应关系。</p></blockquote><p>考虑两个时刻的图像的匹配问题：</p><ol><li>从两幅图像中分别提取到特征点的集合</li><li>寻找这两个集合元素的对应关系，即特征匹配<ul><li>暴力匹配（Brute-Force Matcher）：对于集合A中的所有元素，依次与集合B中的所有元素进行遍历测量描述子的距离（表示了两个特征点之间的相似程度），排序，选择最近的一个作为匹配点。<ul><li>浮点类型的描述子：使用欧式距离</li><li>二进制的描述子:使用汉明距离（两个二进制串之间不同位数的个数）</li></ul></li><li>快速近似最优邻算法（FLANN）<ul><li>适合匹配点数量极多的情况（暴匹运算量太大）</li></ul></li></ul></li></ol><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><ul><li>待填</li></ul><h2 id="2D-2D-对极几何"><a href="#2D-2D-对极几何" class="headerlink" title="2D-2D:对极几何"></a>2D-2D:对极几何</h2><h3 id="对极约束"><a href="#对极约束" class="headerlink" title="对极约束"></a>对极约束</h3><p><img src="https://s2.ax1x.com/2019/03/27/AddAtx.png" alt="AddAtx.png"><br><img src="https://s2.ax1x.com/2019/03/27/AddpX4.jpg" alt="AddpX4.jpg"></p><p>代数角度解释几何关系的过程：<br><img src="https://s2.ax1x.com/2019/03/27/AddScF.jpg" alt="AddScF.jpg"><br><img src="https://s2.ax1x.com/2019/03/27/AddPB9.jpg" alt="AddPB9.jpg"><br><img src="https://s2.ax1x.com/2019/03/27/Addi7R.jpg" alt="Addi7R.jpg"><br><img src="https://s2.ax1x.com/2019/03/27/AddkA1.jpg" alt="AddkA1.jpg"></p><h3 id="本质矩阵（E，Essential-Matrix）"><a href="#本质矩阵（E，Essential-Matrix）" class="headerlink" title="本质矩阵（E，Essential Matrix）"></a>本质矩阵（E，Essential Matrix）</h3><p><img src="https://s2.ax1x.com/2019/03/27/AddEh6.jpg" alt="AddEh6.jpg"><br><img src="https://s2.ax1x.com/2019/03/27/AddZ9K.jpg" alt="AddZ9K.jpg"><br>求解方法略</p><h3 id="基础矩阵（F，Fundamental-Matrix）"><a href="#基础矩阵（F，Fundamental-Matrix）" class="headerlink" title="基础矩阵（F，Fundamental Matrix）"></a>基础矩阵（F，Fundamental Matrix）</h3><p>求解方法略</p><h3 id="单应矩阵（H，Homography-Matrix）"><a href="#单应矩阵（H，Homography-Matrix）" class="headerlink" title="单应矩阵（H，Homography Matrix）"></a>单应矩阵（H，Homography Matrix）</h3><p>除了基本矩阵和本质矩阵，我们还有一种称为单应矩阵（Homography）H 的东西，它描述了两个平面之间的映射关系。若场景中的特征点都落在同一平面上（比如墙，地面等），则可以通过单应性来进行运动估计。这种情况在无人机携带的俯视相机，或扫地机携带的顶视相机中比较常见。单应矩阵通常描述处于共同平面上的一些点，在两张图像之间的变换关系。</p><p>单应性在SLAM 中具重要意义。当特征点共面，或者相机发生纯旋转的时候，基础矩阵的自由度下降，这就出现了所谓的退化（degenerate）。现实中的数据总包含一些噪声，这时候如果我们继续使用八点法求解基础矩阵，基础矩阵多余出来的自由度将会主要由噪声决定。为了能够避免退化现象造成的影响，通常我们会同时估计基础矩阵F和单应矩阵H，选择重投影误差比较小的那个作为最终的运动估计矩阵。</p><h3 id="实践：通过Essential矩阵求解相机运动"><a href="#实践：通过Essential矩阵求解相机运动" class="headerlink" title="实践：通过Essential矩阵求解相机运动"></a>实践：通过Essential矩阵求解相机运动</h3><ul><li>待填</li></ul><p>程序输出分解得到R，t的四种可能，并使用三角检测角点的深度是否为正选出正确的解。</p><p>（R，t）即从第一个图到第二个图的坐标变换矩阵的参数。</p><ul><li>E（本质矩阵)本身具有<strong>尺度等价性</strong>，认为分解得到的t，R也有尺度等价性。认为t具有一个<strong>尺度</strong>。通常对t进行<strong>归一化</strong>，使它的长度等于1。</li><li>对t的长度的归一化导致了单目视觉的尺度不确定性（Scale Ambiguity)</li><li>在单目视觉中，对两张图像的t归一化，相当于固定了尺度，但不知道实际长度为多少，以此时的t为单位1。这称为单目SLAM的初始化。</li><li>除了对t进行归一化之外，另一种方法是令初始化时所有的特征点平均深度为1，也可以固定一个尺度。</li><li><strong>单目初始化不能只有纯旋转，必须要有一定程度的平移。</strong>如果没有平移，单目将无法初始化。在实践当中，如果初始化时平移太小，会使得位姿求解与三角化结果不稳定，从而导致失败。相对的，如果把相机左右移动而不是原地旋转，就容易让单目SLAM 初始化。因而有经验的SLAM 研究人员，在单目SLAM 情况下，经常选择让相机进行左右平移以顺利地进行初始化。</li><li>给定的点数多于8对时，计算最小二乘解。当可能存在误匹配的情况时，我们会更倾向于使用随机采样一致性（Random Sample Concensus, RANSAC）来求，而不是最小二乘。<ul><li>RANSAC 是一种通用的做法，适用于很多带错误数据的情况，可以处理带有错误匹配的数据。</li></ul></li></ul><h2 id="三角测量（三角化）"><a href="#三角测量（三角化）" class="headerlink" title="三角测量（三角化）"></a>三角测量（三角化）</h2><blockquote><p>三角测量是指，通过在两处观察同一个点的夹角，确定该点的距离。在SLAM中，我们主要用三角化来估计像素点的距离。</p></blockquote><p>三角测量由<strong>平移</strong>得到，纯旋转无法使用三角测量。</p><h2 id="3D-2D：PnP"><a href="#3D-2D：PnP" class="headerlink" title="3D-2D：PnP"></a>3D-2D：PnP</h2><blockquote><p>PnP（Perspective-n-Point）是求解3D 到2D 点对运动的方法。它描述了当我们知道 n 个3D空间点以及它们的投影位置时，如何估计相机所在的位姿。</p></blockquote><p>求解方法:（跳过了）</p><ul><li>P3P:用三对点估计位姿</li><li>DLT：直接线性变换</li><li>EPnp（Efficient PnP）</li><li>UPnP</li><li>BA、非线性优化：构建最小二乘问题并迭代求解（Bundle Adjustment）</li></ul><h2 id="3D-3D：ICP"><a href="#3D-3D：ICP" class="headerlink" title="3D-3D：ICP"></a>3D-3D：ICP</h2><blockquote><p>这个问题可以用<strong>迭代最近点（Iterative Closest Point, ICP）</strong>求解。读者应该注意到，3D-3D 位姿估计问题中，并没有出现相机模型，也就是说，仅考虑两组3D点之间的变换时，和相机并没有关系。</p></blockquote><p>求解方法：</p><ul><li>SVD方法</li><li>非线性优化方法（类似于BA）</li></ul><h2 id="特征点法的缺点："><a href="#特征点法的缺点：" class="headerlink" title="特征点法的缺点："></a>特征点法的缺点：</h2><ol><li>关键点的提取与描述子的计算非常耗时。实践当中，SIFT目前在CPU 上是无法实时计算的，而ORB也需要近20毫秒的计算。如果整个SLAM 以30毫秒/帧的速度运行，那么一大半时间都花在计算特征点上。</li><li>使用特征点时，忽略了除特征点以外的所有信息。一张图像有几十万个像素，而特征点只有几百个。只使用特征点丢弃了大部分可能有用的图像信息。</li><li>相机有时会运动到特征缺失的地方，往往这些地方没有明显的纹理信息。例如，有时我们会面对一堵白墙，或者一个空荡荡的走廓。这些场景下特征点数量会明显减少，我们可能找不到足够的匹配点来计算相机运动。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>支持向量机（SVM)</title>
      <link href="/2019/03/27/deepLearning/SVM/"/>
      <url>/2019/03/27/deepLearning/SVM/</url>
      
        <content type="html"><![CDATA[<p>keyword：SVM（Support Vector Machines），超平面，逻辑回归</p><a id="more"></a><ul><li>向量机的目的：</li><li>超平面：</li><li><p>下确界（lower bound）：S是一个偏序集合（S，≤），存在一个数值l属于K，这个数值l小于或等于S中的任意一个元素的值，则称这个值为S的一个下确界。</p><ul><li>如果l在S中，则称该元素为infimum，（greatest lower bound，最大下确界）</li><li>同理有上确界（supremum)和最小上确界</li></ul></li><li><p>凸函数和凹函数</p></li><li><p>函数对偶（duality）</p><ul><li>通过对偶函数使得求解原函数的最大值/最小值更简单</li><li>对偶函数与原函数的最大值P和最小值D相对应</li><li>可能存在间隔（即P = D）(Duality gap），称为这两个函数是弱对偶成立（weak duality holds)</li><li>同理可得，P - D = 0的两个对偶函数称为强对偶成立（srong duality holds)</li></ul></li></ul><p>（简写英文小课堂:</p><blockquote><p>. E.g. stands for exempli gratia and means “for example.” I.e. is the abbreviation for id est and means “in other words.” </p></blockquote><ul><li><p>objective function 目标函数f（损失函数)</p><ul><li>找出x，满足 f 最小</li><li>同时满足约束(subject to constraints)<ul><li>简写（s.t.)</li></ul></li></ul></li><li><p>feasible region 可行解</p></li><li>拉格朗日乘数<ul><li>Coutour Lines 等高线<ul><li>等高线上的任意一个点的函数取值都是一样的</li><li>the darker the area is，the smaller the value is </li></ul></li><li>vector field 向量场<ul><li>可视化一个函数每一点上的梯度（gradient）</li><li>箭头指向函数在该点增长得最快的方向</li></ul></li><li>将约束函数和原函数的向量场放在同一个图像中，当两个函数的某些向量是方向平行的，</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记（2）</title>
      <link href="/2019/03/27/vueLearning/vueLearning2/"/>
      <url>/2019/03/27/vueLearning/vueLearning2/</url>
      
        <content type="html"><![CDATA[<p>我是一条酸菜鱼。</p><a id="more"></a><h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><h3 id="创建Vue实例"><a href="#创建Vue实例" class="headerlink" title="创建Vue实例"></a>创建Vue实例</h3><ul><li>待补充</li></ul><h3 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h3><p>Vue实例 - Vue的响应式系统：</p><ul><li>data对象中的属性值改变会带来视图的响应</li><li>只有实例创建时data中已存在的属性才是响应式的</li><li>Vue实例自带的实例属性与方法带有前缀$，与用户自定义的属性区分</li><li><p>阻止修改现有的属性 - Object.freeze()(下例）</p><pre><code>//js    var obj = {  foo: &apos;bar&apos;}Object.freeze(obj)new Vue({  el: &apos;#app&apos;,  data: obj})--------------------------------------------//html&lt;div id=&quot;app&quot;&gt;  &lt;p&gt;{{ foo }}&lt;/p&gt;  &lt;!-- 这里的 `foo` 不会更新！ --&gt;  &lt;button v-on:click=&quot;foo = &apos;baz&apos;&quot;&gt;Change it&lt;/button&gt;&lt;/div&gt;</code></pre></li></ul><h2 id="实例生命周期钩子"><a href="#实例生命周期钩子" class="headerlink" title="实例生命周期钩子"></a>实例生命周期钩子</h2><p>Vue的初始化过程：</p><p>生命周期钩子（在vue初始化过程某些阶段运行钩子对应的函数），函数中调用的 this 指向调用它的vue实例。</p><ul><li>created</li><li>mounted</li><li>updated</li><li>destroyed</li></ul><blockquote><p>不要在选项属性或回调上使用箭头函数，比如 created: () =console.log(this.a) 或 vm.$watch(‘a’, newValue =this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到位置，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。</p></blockquote><p>（假装此处有图）</p><hr><h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><ul><li>尽可能使得模板内的表达式是简单的声明式逻辑</li><li>使用计算属性来表达复杂逻辑</li><li>计算属性放在Vue的 computed 分类中，后接一个getter函数用于得到/更新属性的值</li><li>计算属性的使用方法与普通属性一致，可以在模板中绑定</li><li>计算属性基于它们的响应式依赖进行缓存。大概就是计算属性是一个属性（变量），同时由一个函数f得到它的值。当f中使用到的变量（可能是data中的）发生改变时，计算属性就会响应式地更新。类似的，跳过计算属性，在模板绑定一个方法也可以得到同样的效果。区别在于:<ul><li>计算属性依赖于f中的变量，会缓存当前结果，如果f中的变量没有更新，多次访问计算属性会返回缓存的结果，而不需要重新执行计算函数</li><li>函数每次调用都会重新计算，无缓存</li><li>大概是性能开销和空间开销之间的选择</li></ul></li></ul><h4 id="计算属性实例："><a href="#计算属性实例：" class="headerlink" title="计算属性实例："></a>计算属性实例：</h4><pre><code>使用计算属性/使用方法可以达到同样的效果，区别在于有无缓存&lt;div id=&quot;example&quot;&gt;  &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;  &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;  &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage1() }}&quot;&lt;/p&gt;    &lt;/div&gt;var vm = new Vue({  el: &apos;#example&apos;,  data: {    message: &apos;Hello&apos;  },  computed: {    // 计算属性的 getter    reversedMessage: function () {      // `this` 指向 vm 实例      // message不更新，则reversedMessage这个计算属性返回的会是缓存的值      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)    }  }，  methods: {  reversedMessage1: function () {    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)  }}})</code></pre><h4 id="计算属性另一种实例"><a href="#计算属性另一种实例" class="headerlink" title="计算属性另一种实例"></a>计算属性另一种实例</h4><p>在计算属性中加入setter，此时可以使用赋值</p><pre><code>// ...computed: {  fullName: {    // getter    get: function () {      return this.firstName + &apos; &apos; + this.lastName    },    // setter    set: function (newValue) {      var names = newValue.split(&apos; &apos;)      this.firstName = names[0]      this.lastName = names[names.length - 1]    }  }}// ...</code></pre><p>现在再运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。</p><h3 id="侦听属性"><a href="#侦听属性" class="headerlink" title="侦听属性"></a>侦听属性</h3><ul><li>用于观察和响应Vue实例上的数据变动，watch分类中的数据都随着其他数据变动而变动。（容易滥用?)</li><li>更通用的方法来响应数据的变化。</li><li>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</li></ul><p>使用方法与计算属性类似，在watch:{}中添加</p><p>VUE文档中给出的DEMO有一个有意思的API：yesOrNo</p><p>代码在<a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener">这里</a>（拉到最后）</p><hr><h2 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h2><ul><li>组件是可复用的Vue实例，且带有变量名</li><li>每使用一次组件，就创建一个新的实例</li><li>组件中的data需要是一个函数，因此复用时，每个实例维护一个独立的拷贝</li></ul><p>组件的注册：</p><ul><li>局部注册</li><li><p>全局注册：可以用在其被注册之后的任何（通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。</p><pre><code>//一个全局注册的demo //定义一个名为 button-counter 的新组件Vue.component(&apos;button-counter&apos;, {  data: function () {    return {      count: 0    }  },  template: &apos;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me {{ count }} times.&lt;/button&gt;&apos;})</code></pre></li></ul><hr><p><strong>插一段软件测试的笔记</strong></p><p>（以表达我对蔡老师课堂的热爱</p><p>软件缺陷记录的5C原则：</p><ul><li>Correct（准确）：每个组成部分的描述准确，不会引起误解； </li><li>Clear（清晰）：每个组成部分的描述清晰，易于理解； </li><li>Concise（简洁）：只包含必不可少的信息，不包括任何多余的内容； </li><li>Complete（完整）：包含复现该缺陷的完整步骤和其他本质信息； </li><li>Consistent（一致）：按照一致的格式书写全部缺陷报告。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>酸菜鱼的梯度下降法学习</title>
      <link href="/2019/03/25/deepLearning/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
      <url>/2019/03/25/deepLearning/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="2019年3月26日：梯度下降法求解多元线性模型"><a href="#2019年3月26日：梯度下降法求解多元线性模型" class="headerlink" title="2019年3月26日：梯度下降法求解多元线性模型"></a>2019年3月26日：梯度下降法求解多元线性模型</h2><a id="more"></a><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>探讨使用梯度下降法（随机梯度下降法）的多变量线性回归模型，损失函数、梯度下降法的收敛、过拟合问题和学习率等之间的关系。</p><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>请在文件夹“作业2”中下载文件名为<strong>“dataForTraining.txt”</strong>的文件。该文件包含广东省广州市海珠区的房价信息，里面包含<strong>50</strong>个训练样本数据。文件有三列，第一列对应<strong>房的面积</strong>（单位：平方米），第二列对应房子距离双鸭山职业技术学院的<strong>距离</strong>（单位：千米），第三列对应房子的<strong>销售价格</strong>（单位：万元）。</p><p>每一行对应一个训练样本。请使用提供的50个训练样本来训练多变量回归模型以便进行<strong>房价预测</strong>，请用（<strong>随机）梯度下降法</strong>的<strong>多变量线性回归模型</strong>进行建模。为了评估训练效果，请文件夹中下载测试数据集“dataForTesting.txt” （该测试文件里的数据跟训练样本具有相同的格式，即第一列对应房子面积，第二列对应距离，第三列对应房子总价）。</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><h3 id="梯度下降法（GD-Gradient-Descent）"><a href="#梯度下降法（GD-Gradient-Descent）" class="headerlink" title="梯度下降法（GD,Gradient Descent）"></a>梯度下降法（GD,Gradient Descent）</h3><p>梯度下降法（批量梯度下降法）的计算过程就是沿梯度下降的方向求解极小值或沿梯度上升方向求解极大值。由于GD在每次计算梯度时都需要遍历所有样本，因此一定保证每次迭代都能沿着极小值的方向迈进，比较稳定，缺点在于每一次迭代的计算量都一样且比较大。</p><h3 id="随机梯度下降法（SGD-Stochastic-Gradient-Descent"><a href="#随机梯度下降法（SGD-Stochastic-Gradient-Descent" class="headerlink" title="随机梯度下降法（SGD,Stochastic Gradient Descent)"></a>随机梯度下降法（SGD,Stochastic Gradient Descent)</h3><p>随机梯度下降法的计算过程与梯度下降法相仿，区别在于SGD每次计算梯度时，只随机的选取一个样本来计算梯度,这样就大大的减小了计算的复杂度。问题在于由于只选择一个样本进行每次的迭代，因此收敛不稳定，且有可能出现朝着反方向迭代的情况，即某一次迭代中出现了负优化。</p><h3 id="小批量梯度下降法（mini-batch）"><a href="#小批量梯度下降法（mini-batch）" class="headerlink" title="小批量梯度下降法（mini-batch）"></a>小批量梯度下降法（mini-batch）</h3><p>在每次迭代的时候选取一部分样本，与随机梯度下降法相比，增强了方向的稳定性。与批量梯度下降法相比，运算量大大减少，运行速度也更快。</p><h3 id="多变量线性回归"><a href="#多变量线性回归" class="headerlink" title="多变量线性回归"></a>多变量线性回归</h3><p>即具有多个自变量且可用线性方程式表达的模型，形如：</p><blockquote><p>h(x)=theta0+theta1<em>x1+theta2</em>x2+theta3*x3</p></blockquote><p>同时，我们可以认为函数的常数项是相当于系数（该常数）始终乘以一个（X<sub>0</sub> == 1),此时这个函数就可以表达成两个一维矩阵之间的相乘，即</p><blockquote><p>h<sub>θ</sub>(x) = θ<sup>T</sup>X</p></blockquote><p>其中θ为参数矩阵，X为系数矩阵</p><h3 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h3><p>均方误差（英语：mean-square error、MSE）是对于无法观察的参数 θ 的一个估计函数T；其定义为：</p><p>$$MSE(T) = E((T-θ²)) = \frac{1}{2N}\sum_{t=1}^{N}(Yestimate - Y)²$$ </p><h2 id="模型训练流程"><a href="#模型训练流程" class="headerlink" title="模型训练流程"></a>模型训练流程</h2><p> 训练流程如下:</p><ol><li><p>先定义训练的迭代次数、学习率、样本数目等训练过程中使用到的参数，在每一次的训练中，根据选择的梯度下降方法（GD/SGD/mini-batch GD）进行训练。</p></li><li><p>进入迭代过程，每一次的训练中，先将模型更新，计算出预测值，根据预测值可以计算出当前模型预测的损失情况，然后再回退到原来前进前的情况，并记录下损失值，由最后的输出可知随着模型的训练损失值下降。然后重新将模型更新，然后得到同样的预测值，然后使用这个预测值与之前定义好的训练集作比较，计算出当前模型判断的准确率（误差），由最后的输出可知这个准确率在训练的过程中逐步上升。这就完成了一次迭代。</p></li><li><p>重复进行n次训练（在上面的代码中训练次数为400次），得到最终的模型。</p></li><li><p>使用测试集对最终的模型进行测试，最后得到这个模型识别测试集的准确率，通过准确率判断训练出来的模型的质量。</p></li></ol><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>模型训练的核心在于两个函数，一个是代价函数，另一个是梯度下降函数。</p><ul><li><p>代价函数（MSE）：计算模型迭代完成后的均方误差作为误差</p><pre><code>def costFunc(X,Y,theta):    inner = np.power((X*theta.T)-Y,2)      return np.sum(inner)/(len(X))  </code></pre></li><li><p>梯度函数：定义了整个迭代的训练过程，输入参数包括（训练样本，初始误差，学习率（步长），迭代次数，使用参数进行训练并迭代，通过代价函数求出当前的误差并记录，完成给定次数的迭代后输出最终的模型参数，训练样本误差，测试样本误差等信息。</p><pre><code>def gradientDescent(X,Y,theta,lr,iters):    #初始化    temp = np.mat(np.zeros(theta.shape))    trainCost = []    testCost = []    index = []    thetaNums = int(theta.shape[1]) #系数的个数    #迭代过程    for i in range(iters):        error = (X*theta.T-Y) #计算误差        for j in range(thetaNums): #三个系数            #np.multiply：数组和矩阵对应位置相乘，输出与相乘数组/矩阵的大小一致            derivativeInner = np.multiply(error,X[:,j]) #求导数            #得到当前的参数            temp[0,j] = theta[0,j] - (lr*np.sum(derivativeInner)/len(X))        theta = temp #将参数更新        if(i % 100000 == 0):            index.append(i);            trainCost.append(costFunc(X,Y,theta))            testCost.append(costFunc(Xtest,Ytest,theta))    return theta,trainCost,testCost,index</code></pre></li></ul><p>-</p><p>其余如文件读写，作图等功能可见源码注释。</p><hr><h3 id="exercise1："><a href="#exercise1：" class="headerlink" title="exercise1："></a>exercise1：</h3><blockquote><p>你需要用多少个参数来训练该线性回归模型？请使用梯度下降方法训练。训练时，请把迭代次数设成1500000，学习率设成0.00015，参数都设成0.0。在训练的过程中，每迭代100000步，计算训练样本对应的误差，和使用当前的参数得到的测试样本对应的误差。请画图显示迭代到达100000步、200000步、… … 1500000时对应的训练样本的误差和测试样本对应的误差（图可以手画，或者用工具画图）。从画出的图中，你发现什么？请简单分析。</p></blockquote><h3 id="ANS1："><a href="#ANS1：" class="headerlink" title="ANS1："></a>ANS1：</h3><p>我定义的梯度下降模型使用了<strong>5个参数</strong>来训练这个线性模型（实际函数中有7个参数是因为我为了方便处理，将训练集和测试集的X和Y分开输入了），分别是：</p><ul><li>训练集（X，Y）</li><li>测试集（Xtest，Ytest）</li><li>初始系数（theta，都设为0）</li><li>学习率（lr，learning rate）</li><li>迭代次数（iters）</li></ul><p>同时，训练后的模型输出四个参数，分别是：</p><ul><li>最终系数（resultTheta)</li><li>一组训练集误差（trainCost）</li><li>一组测试集误差（testCost）</li><li>下标（按照题目要求用于记录误差所在的迭代次数，每十万次）</li></ul><p>按照给定的要求进行150W次的迭代，每10W次迭代对两种误差都进行一次记录，得到结果如下图（为了图显示的美观，因此将float格式的误差转换成了int的格式，即去掉了小数部分）：</p><p><img src="https://s2.ax1x.com/2019/03/26/AU4ryn.png" alt="AU4ryn.png"></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4wWQ.png" alt="AU4wWQ.png"></p><p>其中，第一张图是使用训练集计算出的误差，第二张图是使用测试集中训练得到的误差。通过数值可以看出，由于一开始设置的初始参数为【0，0，0】，因此得到的误差与其他误差相比十分大，导致整体图的结构看不出正确误差的走向，因此去掉第一个点重新作图，得到图像如下：</p><p><img src="https://s2.ax1x.com/2019/03/26/AU40zj.png" alt="AU40zj.png"><br><img src="https://s2.ax1x.com/2019/03/26/AU4aFS.png" alt="AU4aFS.png"></p><p>可以看到，对于训练集，其误差在每10W次迭代中是下降且趋于收敛，在50W次迭代的时候达到极小值3，而且之后迭代中一直保持这个误差不变，此时<strong>由图看到的训练效果较好</strong>，可以认为梯度下降法达到了<strong>收敛</strong>。同时，参考测试集，误差是在20W次迭代的时候达到一个低值（119），然后继续迭代后误差反而<strong>上升</strong>了，最后稳定在133左右。基于此，我认为以题目给定的数值作为参数输入，最后得到的模型是<strong>过拟合</strong>的，具体体现在<strong>训练集的表现很好，但测试集的表现一般</strong>。</p><hr><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2:"></a>Exercise 2:</h3><blockquote><p>现在，你改变学习率，比如把学习率改成0.0002（此时，你可以保持相同的迭代次数也可以改变迭代次数），然后训练该回归模型。你有什么发现？请简单分析。</p></blockquote><h3 id="ANS2"><a href="#ANS2" class="headerlink" title="ANS2:"></a>ANS2:</h3><p>改变学习率为0.0002后初始化模型并重新训练，得到的参数基本都是无意义的（除了第一个误差参数为10W+外，其余的均为NAN），显示运算的溢出。而修改学习率为更低的参数，效果不太明显，只能勉强看出学习率会影响训练的进度，对结果影响不大。后面经过讨论得知，这是由于训练过程中，参数没有进行正则化的原因，优化后得到更好的效果，可以看出，针对SD而言，当学习率上升时，模型训练速度提高。</p><p>同时，我使用了另外一门课《人工神经网络》中的作业作为例子，使用控制变量法对学习率进行了进一步的测试，得到结果如下图所示：（其中loss是损失函数，即误差；acc值则为得到的结果的准确率，计算方法相当于用模型得到的结果 <strong>Y<sub>cal</sub></strong> 除以正确结果<strong>Y<sub>correct</sub></strong>。</p><p><strong>可以看出，学习率会影响梯度下降法的性能，学习率数值大时可以使得模型迅速往理想模型移动，即误差值的收敛速率较快，系数在比较少的迭代次数中就会到达较好的数值，但同时过大的学习率会导致学习的不稳定，即两种数值都会出现较大幅度的波动，即学习的方式比较激进；即而学习率过小则导致训练需要的时间过长，即两种数值虽然往好的方向变化，但变化得很慢。</strong></p><p><strong>学习率设置为100（过高）</strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4WYF.png" alt="AU4WYF.png"><img src="https://s2.ax1x.com/2019/03/26/AU4goT.png" alt="AU4goT.png"></p><p><strong>学习率设置为e<sup>-10</sup>(过低）</strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU46e0.png" alt="AU46e0.png"><img src="https://s2.ax1x.com/2019/03/26/AU4RFU.png" alt="AU4RFU.png"></p><p><strong>学习率设置为e<sup>-1</sup></strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4DQs.png" alt="AU4DQs.png"><img src="https://s2.ax1x.com/2019/03/26/AU4dJg.png" alt="AU4dJg.png"></p><p><strong>学习率设置为e<sup>-2</sup></strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4cwV.png" alt="AU4cwV.png"><img src="https://s2.ax1x.com/2019/03/26/AU4sLq.png" alt="AU4sLq.png"></p><p>学习率的变化对loss值和accuracy值的影响都主要体现在这两种数值下降的加速度（幅度）以及出现波动的幅度与频率。以上面的训练为例子：</p><ol><li><p>当学习率过高时（100），loss的图像呈现了较大幅度上下震荡的现象，loss值方差较大，但此时loss值的单个数值和均值都较小，最高点在300左右而最低点在50左右；accuracy值则很快到达了接近0.9的高值，但同时出现大幅度震荡，数值的方差较大，且在趋于稳定的过程中仍然时常出现波动到数值为0.4这样的情况。导致这种现象的原因是因为学习率过高导致了学习的不稳定性，有时候会往错误方向快速前进，导致了极端情况的出现。</p></li><li><p>当学习率过低（1e-10）时，loss图像视觉上有较大幅度的震荡，但实际上震荡范围很小（1030-1060，方差小），而数值均值很大，在1145左右；accuracy值则一直没有变化。这种现象出现的原因是学习率过低导致模型的学习效率很低，往正确模型前进的速度过慢，模型识别能力没有明显提升，因此正确率没有提升，错误率一直很高。</p></li><li><p>当学习率适中（1e-1,1e-2,1e-3）时，学习率的上升会加快训练的进程，体现在两种曲线梯度的上升，更快地趋向稳定和理想，但偶尔会出现震荡的情况。根据参数调试，我认为1e-2是比较理想的学习率。同时，上面训练函数的定义部分注释掉了一个动态调整学习率的过程，具体表现为每经过一百次训练，学习率就变为原来的1/10，这有助于后期模型训练得到的结果趋于稳定。</p></li></ol><hr><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3:"></a>Exercise 3:</h3><blockquote><p>现在，我们使用其他方法来获得最优的参数。你是否可以用<strong>随机梯度下降法</strong>获得最优的参数？请使用随机梯度下降法画出迭代次数（每K次，这里的K你自己设定）与训练样本和测试样本对应的误差的图。比较Exercise 1中的实验图，请总结你的发现。</p></blockquote><h3 id="ANS3"><a href="#ANS3" class="headerlink" title="ANS3:"></a>ANS3:</h3><p>使用随机梯度下降法，即每次迭代只使用训练集中的一组数据作为输入参数来进行梯度的计算，得到的图像如下:</p><p><strong>迭代次数为15W，每1W求一次误差</strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU44SJ.png" alt="AU44SJ.png"></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4fW4.png" alt="AU4fW4.png"></p><p><strong>迭代次数为150W，每10W求一次误差</strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU45l9.png" alt="AU45l9.png"></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4IyR.png" alt="AU4IyR.png"></p><p>由图可得，使用随机梯度下降法（即每次只抽取一个样本），可以很快<strong>接近</strong>最优的参数（<strong>通过数值判定</strong>），但在接近最优解的同时，依然可能出现较大的波动，这是由于其“冒进”的特性决定的；由于只取一个值，因此随机性更大，很可能出现向着反方向前进的情况，此时误差值反而会上升。所以我认为，用随机梯度下降法可以很快获得<strong>接近最优的参数</strong>，但很可能是一个局部最优解，需要通过<strong>大量的迭代</strong>才能确定<strong>确切的全局最优解</strong>。</p><p>通过对比，我们不难看出不同的batchSize（每次迭代的取样个数）实际上对应着三种不同的梯度下降法，分别是：</p><ul><li>SD（梯度下降法，batchSize = 样本个数</li><li>小批量梯度下降法（mini-batch, batchSize in [1,max))</li><li>SGD（随机梯度下降法，batchSize = 1）</li></ul><p>这三种方法按照上面的顺序，对模型训练的影响分别为：训练速度递增，训练稳定性递减（即出现波动的可能性递增）。</p><ol><li><p>当batchSize上升时，计算复杂度上升，运行速度下降，运行稳定性很好；当batchSize的值取的是样本长度时，模型在运算过程中持续向最优解接近，几乎没有出现错误的前进时刻，但优化的速度较慢，而且可能出现停滞；这是因为SD（批量梯度下降法）一定能够沿着最小值的方向迈进，比较稳定，但每一次计算梯度都需要遍历所有的样本，计算量比较大。</p></li><li><p>当batchSize下降时，计算复杂度下降，运行速度上升，运行随机性增长；当batchSize的值取1时，模型在迭代的训练中快速接近理想状态，但在到达较优解时会出现较大幅度的波动；这是因为SGD（随机梯度下降法)虽然具有运算速度较快的优点，但有可能跳出局部最优解，每次迈向的方向不稳定，甚至有可能向反方向迈进。</p></li><li><p>基于这个变化特性，每次计算梯度的时候选取一部分样本来进行计算，在保证方向的基本稳定的同时又减少了计算量，提升了运行速度，也就是采用mini-batch GD是一个更优的选择。</p></li></ol><h2 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h2><h3 id="批归一化（BN-Batch-Normalization）"><a href="#批归一化（BN-Batch-Normalization）" class="headerlink" title="批归一化（BN,Batch Normalization）"></a>批归一化（BN,Batch Normalization）</h3><p><a href="https://www.cnblogs.com/skyfsm/p/8453498.html" target="_blank" rel="noopener">原文在这</a></p><blockquote><p>BN是由Google于2015年提出，这是一个深度神经网络训练的技巧，它不仅可以加快了模型的收敛速度，而且更重要的是在一定程度缓解了深层网络中“梯度弥散”的问题，从而使得训练深层网络模型更加容易和稳定。</p></blockquote><h4 id="what"><a href="#what" class="headerlink" title="what"></a>what</h4><p>BN就是对每一批数据进行归一化（把数据映射到0～1范围之内处理），就是对训练的每一批数据先进行标准的归一化（减均值除方差）得到0-1分布，然后再进行尺度变换和偏移，使得样本效果更好。</p><h4 id="when"><a href="#when" class="headerlink" title="when"></a>when</h4><p>我们可以在网络中任意一层进行归一化处理</p><h4 id="how"><a href="#how" class="headerlink" title="how"></a>how</h4><p><img src="https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180219084749642-1647361064.png" alt></p><p>BN步骤主要分为4步：</p><ol><li>求每一个训练批次数据的均值</li><li>求每一个训练批次数据的方差</li><li>使用求得的均值和方差对该批次的训练数据做归一化，获得0-1分布。其中ε是为了避免除数为0时所使用的微小正数。</li><li>尺度变换和偏移：将xi乘以γ调整数值大小，再加上β增加偏移后得到yi，这里的γ是尺度因子，β是平移因子。这一步是BN的精髓，由于归一化后的xi基本会被限制在正态分布下，使得网络的表达能力下降。为解决该问题，我们引入两个新的参数：γ,β。 γ和β是在训练时网络自己学习得到的。</li></ol><h4 id="why"><a href="#why" class="headerlink" title="why"></a>why</h4><p><img src="https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180219084810095-616879424.png" alt><br><img src="https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180219084820533-1615172856.png" alt></p><ul><li>标准的归一化操作将可能处于梯度很小的区域的数据移动到梯度更大的区域中，可以对抗梯度消失的现象。对每一层数据都进行这样的操作，那么数据总是分布在变化敏感的区域，使得训练效率提升。</li><li>由于归一化操作得到的分布是正态分布，对某些训练样本的特征分布表现不好，即削弱了网络的性能；因此此加入BN中第四步的尺度变换和偏移，利用优化变一下方差大小和均值位置，使得新的分布更切合数据的真实分布，保证模型的非线性表达能力。</li></ul><h4 id="CNN中的BN"><a href="#CNN中的BN" class="headerlink" title="CNN中的BN"></a>CNN中的BN</h4><p>注意前面写的都是对于一般情况，对于卷积神经网络有些许不同。因为卷积神经网络的特征是对应到一整张特征响应图上的，所以做BN时也应以响应图为单位而不是按照各个维度。比如在某一层，batch大小为m，响应图大小为w×h，则做BN的数据量为m×w×h。</p><p>BN在深层神经网络的作用非常明显：若神经网络训练时遇到收敛速度较慢，或者“梯度爆炸”等无法训练的情况发生时都可以尝试用BN来解决。同时，常规使用情况下同样可以加入BN来加速模型训练，甚至提升模型精度</p><h3 id="GN-Group-normalization"><a href="#GN-Group-normalization" class="headerlink" title="(GN,Group normalization)"></a>(GN,Group normalization)</h3><h4 id="BN的一些问题："><a href="#BN的一些问题：" class="headerlink" title="BN的一些问题："></a>BN的一些问题：</h4><ul><li>BN全名是Batch Normalization，见名知意，其是一种归一化方式，而且是以batch的维度做归一化，那么问题就来了，此归一化方式对batch是independent的，过小的batch size会导致其性能下降，一般来说每GPU上batch设为32最合适，但是对于一些其他深度学习任务batch size往往只有1-2，比如目标检测，图像分割，视频分类上，输入的图像数据很大，较大的batchsize显存吃不消。</li><li>另外，Batch Normalization是在batch这个维度上Normalization，但是这个维度并不是固定不变的，比如训练和测试时一般不一样，一般都是训练的时候在训练集上通过滑动平均预先计算好平均-mean，和方差-variance参数，在测试的时候，不在计算这些值，而是直接调用这些预计算好的来用，但是，当训练数据和测试数据分布有差别是时，训练机上预计算好的数据并不能代表测试数据，这就导致在训练，验证，测试这三个阶段存在inconsistency。</li></ul><p>GN将所有channel进行分组，如下图就是将6个channel分成了2个group，1个group有3个channel。</p><p><img src="https://pic4.zhimg.com/80/v2-fad3333df9a87c1c4f1db4b20557da6f_hd.jpg" alt></p><blockquote><p>从左到右一次是BN，LN，IN，GN<br>众所周知，深度网络中的数据维度一般是[N, C, H, W]或者[N, H, W，C]格式，N是batch size，H/W是feature的高/宽，C是feature的channel，压缩H/W至一个维度，其三维的表示如上图，假设单个方格的长度是1，那么其表示的是[6, 6，<em>, </em> ]</p></blockquote><ul><li>BN在batch的维度上norm，归一化维度为[N，H，W]，对batch中对应的channel归一化；</li><li>LN避开了batch维度，归一化的维度为[C，H，W]；</li><li>IN 归一化的维度为[H，W]；</li><li>而GN介于LN和IN之间，其首先将channel分为许多组（group），对每一组做归一化，及先将feature的维度由[N, C, H, W]reshape为[N, G，C//G , H, W]，归一化的维度为[C//G , H, W]</li></ul><p><strong>主要优点</strong></p><ul><li>卷积提取的特征本身分类，并不是完全独立的，某些特征具有相同的分布，因此可以使用group分割样本。</li><li>GN对batch size的鲁棒性更强，GN的归一化方式避开了batch size对模型的影响。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/35005794" target="_blank" rel="noopener">解读原文</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>酸菜鱼的SLAM之旅（3）</title>
      <link href="/2019/03/25/SLAM/ch6_%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"/>
      <url>/2019/03/25/SLAM/ch6_%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="2019年3月24日：非线性优化"><a href="#2019年3月24日：非线性优化" class="headerlink" title="2019年3月24日：非线性优化"></a>2019年3月24日：非线性优化</h2><a id="more"></a><h2 id="状态估计问题"><a href="#状态估计问题" class="headerlink" title="状态估计问题"></a>状态估计问题</h2><h3 id="最大后验和最大似然"><a href="#最大后验和最大似然" class="headerlink" title="最大后验和最大似然"></a>最大后验和最大似然</h3><p>经典SLAM模型：</p><p><img src="https://s2.ax1x.com/2019/03/27/AdUOzD.jpg" alt="AdUOzD.jpg"></p><p>观测方程：</p><p><img src="https://s2.ax1x.com/2019/03/27/AdULRO.jpg" alt="AdULRO.jpg"></p><p>考虑数据受噪声影响:</p><p><img src="https://s2.ax1x.com/2019/03/27/AdUbi6.jpg" alt="AdUbi6.jpg"></p><p>状态估计问题：</p><ul><li>扩展卡尔曼滤波器（EKF）：关心当前时刻的状态估计X<sub>k</sub>,而对之前的状态则不多考虑。</li><li><p>非线性优化方法:使用所有时刻采集到的数据进行状态估计。（主流方法)</p><ul><li><p><strong>似然：在现在的位姿下，可能产生怎样的观测数据</strong></p></li><li><p><strong>最大似然估计（Maximize Likelihood Estimation,MLE)：在什么样的状态下，最可能产生现在观测到的数据</strong></p></li><li><p><strong>求解最大后验概率 - 最大化似然和先验的乘积</strong></p></li><li><strong>arg maxP(z|x) —— 最大似然估计</strong></li></ul></li></ul><p><img src="https://s2.ax1x.com/2019/03/27/AdUvsH.jpg" alt="AdUvsH.jpg"></p><h3 id="最小二乘"><a href="#最小二乘" class="headerlink" title="最小二乘"></a>最小二乘</h3><p><img src="https://s2.ax1x.com/2019/03/27/AdUjQe.png" alt="AdUjQe.png"></p><ul><li>最小化负对数：对等式两边同时取负对数 -ln(f(x))</li></ul><p><img src="https://s2.ax1x.com/2019/03/27/AdaSeA.png" alt="AdaSeA.png"></p><p><img src="https://s2.ax1x.com/2019/03/27/Ada9ot.jpg" alt="Ada9ot.jpg"></p><p><img src="https://s2.ax1x.com/2019/03/27/AdUxLd.jpg" alt="AdUxLd.jpg"></p><ul><li><p>总体意义下的最小二乘问题（Least Square Problem）</p><ul><li>最优解等价于状态的最大似然估计。</li><li>但由于噪声存在使得估计的轨迹和地图代入SLAM运动、观测方程时不会完美成立 —— 需要把状态的估计值进行微调，使得整体误差下降（有限度，会到达一个极小值）。</li></ul></li><li><p>SLAM中的最小二乘问题——(6.12)式为目标函数</p><ul><li>总体状态变量维数高，每个误差项简单（仅与一两个状态变量有关)</li><li>每个误差项是一个小规模的约束，称每个误差项对应的优化变量为参数块（Parameter Block)</li><li>线性近似、雅可比矩阵</li><li>稀疏性</li><li>李代数-无约束</li><li>平方形式（二范数）度量误差 - 欧氏空间中距离的平方</li></ul></li></ul><h2 id="非线性最小二乘"><a href="#非线性最小二乘" class="headerlink" title="非线性最小二乘"></a>非线性最小二乘</h2><p>不方便直接求解的最小二乘问题使用<strong>迭代</strong>优化：</p><p><img src="https://s2.ax1x.com/2019/03/27/AdapdI.jpg" alt="AdapdI.jpg"></p><p>问题： 确定增量<strong>ΔX<sub>k</sub></strong></p><h3 id="一阶和二阶梯度法"><a href="#一阶和二阶梯度法" class="headerlink" title="一阶和二阶梯度法"></a>一阶和二阶梯度法</h3><ol><li>最速下降法（一阶）、牛顿法（二阶）<ul><li>将目标函数在x附近进行泰勒展开</li><li>参数：雅可比矩阵J、海塞（Hessian）矩阵H、步长 λ</li><li>选择保留泰勒展开的一阶/二阶项 —— 对应一阶梯度法/二阶梯度法</li><li>问题：过于贪心，容易走出锯齿路线，增加迭代次数</li></ul></li></ol><h3 id="Gauss-Newtown（高斯-牛顿）"><a href="#Gauss-Newtown（高斯-牛顿）" class="headerlink" title="Gauss-Newtown（高斯-牛顿）"></a>Gauss-Newtown（高斯-牛顿）</h3><p>思想：将f（x)进行一阶的泰勒展开（不是目标函数f(x)²）</p><p><img src="https://s2.ax1x.com/2019/03/27/AdaFW8.png" alt="AdaFW8.png"><br><img src="https://s2.ax1x.com/2019/03/27/AdaPFP.png" alt="AdaPFP.png"><br><img src="https://s2.ax1x.com/2019/03/27/AdaEQg.jpg" alt="AdaEQg.jpg"></p><p>问题:</p><ul><li>原则上要求所用的近似H矩阵可逆且正定，但实际上（J<sup>T</sup>J）只有半正定性。</li><li>可能出现J<sup>T</sup>J为奇异矩阵或者病态（ill-condition)的情况，此时增量稳定性较差，导致算法不收敛。</li><li>求出来的步长Δx太大，会导致采用的局部近似不够准确，无法保证迭代的结果是收敛。</li></ul><h3 id="Levenberg-Marquadt"><a href="#Levenberg-Marquadt" class="headerlink" title="Levenberg-Marquadt"></a>Levenberg-Marquadt</h3><p>信赖区域方法（Trust Region Method）：在信赖区域里边，我们认为近似是有效的；出了这个区域，近似可能会出问题。</p><p>确认信赖区域的范围：根据近似模型和实际函数之间的差异来确定，差异小→范围尽可能大；差异大→近似范围缩小</p><p><img src="https://s2.ax1x.com/2019/03/27/AdaASS.jpg" alt="AdaASS.jpg"></p><p><strong>改良后的非线性优化框架:</strong></p><p><img src="https://s2.ax1x.com/2019/03/27/AdaiJf.jpg" alt="AdaiJf.jpg"></p><h2 id="实践（挖坑，且不打算填）"><a href="#实践（挖坑，且不打算填）" class="headerlink" title="实践（挖坑，且不打算填）"></a>实践（挖坑，且不打算填）</h2><h3 id="Ceres"><a href="#Ceres" class="headerlink" title="Ceres"></a>Ceres</h3><p>Ceres库面向通用的最小二乘问题的求解：</p><ul><li>用户定义优化问题，设置选项，输入至Ceres求解</li></ul><hr><h3 id="g2o（General-Graphic-Optimization"><a href="#g2o（General-Graphic-Optimization" class="headerlink" title="g2o（General Graphic Optimization)"></a>g2o（General Graphic Optimization)</h3><p>基于图优化的库。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>酸菜鱼的SLAM之旅（2）</title>
      <link href="/2019/03/24/SLAM/ch5_%E7%9B%B8%E6%9C%BA%E4%B8%8E%E5%9B%BE%E5%83%8F/"/>
      <url>/2019/03/24/SLAM/ch5_%E7%9B%B8%E6%9C%BA%E4%B8%8E%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="2019年3月24日：相机与图像"><a href="#2019年3月24日：相机与图像" class="headerlink" title="2019年3月24日：相机与图像"></a>2019年3月24日：相机与图像</h2><a id="more"></a><h2 id="相机模型"><a href="#相机模型" class="headerlink" title="相机模型"></a>相机模型</h2><p>keyword：针孔模型、畸变、内参数</p><hr><p>插一点小知识：</p><ul><li><p>Markdown语法上下标：</p><p>  H<sub>2</sub>O &amp; a<sup>T</sup></p><pre><code>H&lt;sub&gt;2&lt;/sub&gt;O  //下标a&lt;sup&gt;T&lt;/sup&gt;   //上标</code></pre></li><li><p><a href="https://www.jianshu.com/p/a0aa94ef8ab2" target="_blank" rel="noopener">MarkDown输入数学公式</a></p></li><li><p>让MarkdownPad显示数学公式</p></li></ul><p>在MarkdownPad中，点击”Tools &gt; Options &gt; Advanced &gt; HTML Head Editor”，这个是自定义头文件。添加下列内容：  </p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&apos;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&apos;&gt;&lt;/script&gt;</code></pre><p>此时需要【F6】进入浏览器模式才能够显示</p><p>离线的话就先把MathJax clone到本地，然后使用绝对路径引用，应该就可以了</p><p>绝对路径加到头文件中，demo如下:</p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;file:\\\D:\software\MathJax\MathJax.js?config=TeX-MML-AM_CHTML-full&quot;&gt;&lt;/script&gt;</code></pre><hr><h3 id="针孔相机模型"><a href="#针孔相机模型" class="headerlink" title="针孔相机模型"></a>针孔相机模型</h3><p><img src="https://s2.ax1x.com/2019/03/27/AdUu8O.jpg" alt="AdUu8O.jpg"></p><p>相机坐标系为O-x-y-z，习惯上z轴指向相机前方，x向右，y向下。（也就是这幅图相当于成像平面为相机的显示屏，光心O为相机的镜头。）</p><p>P为现实中的空间点，坐标为【X，Y，Z】<sup>T</sup>，（在相机坐标系中）</p><p>而P’为它在成像平面的坐标，【X’,Y’,Z’】<sup>T</sup>（在成像平面中，即图上的O-x’-y’-z’）</p><p>图上f为焦距，Z为P点在现实中的Z轴的位置</p><p>根据三角形相似关系得到两个坐标之间的关系（负号表示成像倒立）</p><blockquote><p>$$\frac{Z}{f} = - \frac{X}{X’} = -\frac{Y}{Y’}$$</p></blockquote><p>简化模型可以把成像平面对称到相机前方，也就是</p><p><img src="https://s2.ax1x.com/2019/03/27/AdUe56.jpg" alt="AdUe56.jpg"></p><p>此时式子变为</p><blockquote><p>$$\frac{Z}{f} = \frac{X}{X’} = -\frac{Y}{Y’}$$</p></blockquote><p>设在物理成像平面上固定着一个像素平面： o-u-v，像素平面上可以得到P’的像素坐标：[u,v]<sup>T</sup></p><p>像素坐标系通常的定义方式是：原点o′位于图像的左上角，u轴向右与x轴平行，v轴向下与y轴平行。像素坐标系与成像平面之间，相差了一个<strong>缩放</strong>和一个<strong>原点的平移</strong>。</p><p><img src="https://s2.ax1x.com/2019/03/27/AdUZUx.png" alt="AdUZUx.png"></p><p>（5.6）中的P - 相机坐标 - 相机的世界坐标（Pw） - 可以得到相机的位姿（由旋转矩阵<strong>R</strong> 和 平移向量 <strong>t</strong>来描述）</p><p>因此 <strong>外参</strong> 为相机的位姿 <strong>R</strong> ， <strong>t</strong></p><p><img src="https://s2.ax1x.com/2019/03/27/AdUAbR.jpg" alt="AdUAbR.jpg"><br>归一化处理：</p><p>归一化平面：</p><p>归一化坐标：</p><hr><h3 id="畸变"><a href="#畸变" class="headerlink" title="畸变"></a>畸变</h3><p>获得更好的成像效果 - 相机前方加透镜 - 对成像过程光线传播造成影响：</p><ol><li>透镜自身的形状对光线传播的影响</li><li>是在机械组装过程中，透镜和成像平面不可能完全平行，这也会使得光线穿过透镜投影到成像面时的位置发生变化。</li></ol><ul><li>径向畸变：由透镜形状引起的畸变<ul><li>桶形畸变：由于图像放大率随着离光轴的距离增加而减小</li><li>枕型畸变：由于图像放大率随着离光轴的距离增加而增加</li></ul></li></ul><p><img src="https://s2.ax1x.com/2019/03/27/AdUVV1.jpg" alt="AdUVV1.jpg"></p><p>径向畸变的纠正模型:用多项式函数来描述前后的坐标变化</p><p><img src="https://s2.ax1x.com/2019/03/27/AdUnPK.jpg" alt="AdUnPK.jpg"></p><ul><li>切向畸变：由于透镜和成像面没有严格平行</li></ul><p><img src="https://s2.ax1x.com/2019/03/27/AdUK2D.png" alt="AdUK2D.png"></p><p><img src="https://s2.ax1x.com/2019/03/27/AdUMxe.jpg" alt="AdUMxe.jpg"></p><p>可以合并进行同时纠正（也就是把两个纠正式相加），最理论的情况下用到了5个畸变项（径向<em>3 + 切向 </em> 2），实际情况下可以灵活选择其中几项。所有的纠正都在归一化平面上完成。</p><p><img src="https://s2.ax1x.com/2019/03/27/AdU1rd.jpg" alt="AdU1rd.jpg"><br><img src="https://s2.ax1x.com/2019/03/27/AdUlKH.jpg" alt="AdUlKH.jpg"></p><p>!仅通过一个像素无法确定空间点的具体位置，因为从相机光心到归一化平面连线上的所有点都可以投影到该像素上。只有P的深度确定时才能够知道确切的空间位置。</p><ul><li>能否知道确切的空间位置<ul><li>针孔相机模型    （X）</li><li>双目相机模型    （√）</li><li>RGB-D相机模型  （√）</li></ul></li></ul><h3 id="双目相机模型"><a href="#双目相机模型" class="headerlink" title="双目相机模型"></a>双目相机模型</h3><p>原理：根据左右眼看到的景物差异（<strong>视差</strong>）来判断物体与我们的距离</p><p><img src="https://s2.ax1x.com/2019/03/27/AdUGVI.png" alt="AdUGVI.png"></p><ul><li>基线：两个相机的光圈中心的距离（Baseline，用符号b表示)</li><li>视差：左右图横坐标之差（U<sub>L</sub> - U<sub>R</sub>)</li><li>视差越大，距离越近</li><li>双目深度理论上的最大值（当视差为1个像素） - f<sub>b</sub></li><li>基线越长，双目最大能测到的距离越远</li><li>反光可能会扰乱测距</li></ul><h3 id="RGB-D相机模型"><a href="#RGB-D相机模型" class="headerlink" title="RGB-D相机模型"></a>RGB-D相机模型</h3><p>原理*2：向探测目标发射红外光，根据返回的图案/飞行时间计算距离</p><ol><li>结构光原理：通过红外结构光返回的图案来测量像素距离</li><li>飞行时间法（Time-of-flight，ToF）原理：向目标发送脉冲光，根据发送到返回之间的光束飞行时间测量像素距离<br><img src="https://s2.ax1x.com/2019/03/27/AdUYIP.jpg" alt="AdUYIP.jpg"></li></ol><p>问题:</p><ol><li>使用范围有限制，会收到日光或者其他传感器发射的红外光干扰，因此不能在室外使用</li><li>同时使用多个RGB-D相机会互相干扰</li><li>投射材质的物体无法接受反射光，因此无法测量这些点的位置（玻璃）</li></ol><h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><p>###灰度图</p><p>每个像素位置（x,y）对应一个灰度值I，因此一张宽为w高为h的图像可以看成一个w*h的矩阵。常见的灰度图中，我们用0-255之间的整数（即一个 unsigned char，一个字节）来表达图像的灰度大小。即我们可以用一个二维数组来表示。</p><p>在图像中，数组的行数（二维数组的第一个下标）表示图像的高度，而列数（第二个下标）表示图像的宽度。</p><p><img src="https://s2.ax1x.com/2019/03/27/AdUJat.jpg" alt="AdUJat.jpg"></p><p>！！！以上图为例，这里要注意，图像的宽度/列数，对应的X轴；图像的行数/高度，对应Y轴。也就是说，取坐标应该是：</p><pre><code>unsigned char pixel = image[y][x] //位于（x,y)处的像素，对应I（x,y)的读数</code></pre><ul><li>灰度像素用八位整数记录（0-255）  unsigned char</li><li>RGB-D相机深度图记录距离，用十六位整数 unsigned short</li><li>彩色图像引入通道（channel）的概念，记录R,G,B三个数值，每一个数值称为一个通道。每个通道使用9位整数表示，也就是一个像素占据24位空间。</li><li>在OpenCV的彩色图像中，通道的默认顺序是B，G，R。前8位代表蓝色，中间8位代表绿色，后8位代表红色。</li><li>如果还需要表达图像的透明度，可以使用R,G,B,A四个通道表示</li></ul><hr><h2 id="OpenCV使用实践（占坑）"><a href="#OpenCV使用实践（占坑）" class="headerlink" title="OpenCV使用实践（占坑）"></a>OpenCV使用实践（占坑）</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>酸菜鱼的SLAM之旅（1）</title>
      <link href="/2019/03/23/SLAM/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/03/23/SLAM/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>key: Ubuntu的配置和Makefile实践</p><a id="more"></a><hr><h2 id="2019年3月23日：Ubuntu环境配置"><a href="#2019年3月23日：Ubuntu环境配置" class="headerlink" title="2019年3月23日：Ubuntu环境配置"></a>2019年3月23日：Ubuntu环境配置</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>一开始我以为之前用ubuntu上过程设跑过C，配置过环境，应该没啥问题的，所以看了看十四讲的实践部分，感觉不就调两个库的事情吗，就直接跳过了。今天想起来，准备用自己的电脑run一遍，一用起来才发现关于ubuntu的知识都忘光了，环境居然只有gcc，cpp都编译不了，很难受。所以写点东西记录一下，下次要是又忘光了还可以看。</p></blockquote><hr><h3 id="Ubuntu基本命令"><a href="#Ubuntu基本命令" class="headerlink" title="Ubuntu基本命令"></a>Ubuntu基本命令</h3><p>ubuntu的系统命令基本以<code>sudo apt-get</code>前缀，下面以我痛苦的安装过程记录一些可能有用的命令：</p><p>安装命令</p><pre><code>sudo apt-get install g++  //安装软件g++</code></pre><p>移除命令</p><pre><code>sudo apt-get remove g++  //卸载</code></pre><p>检查更新</p><pre><code>sudo apt-get update //好像是检查装了的软件和当前发行版本，拉下来一个软件列表</code></pre><p>升级</p><pre><code>sudo apt-get upgrade //升级软件</code></pre><p>切换到root用户（虽然我不知道为啥root还是有些文件夹会被拒绝访问？）</p><pre><code>sudo su -  //需要输密码 占个坑，以后看看关于root、777的内容</code></pre><p>查看当前系统版本</p><pre><code>lsb_release -a</code></pre><hr><p>然后我insatll g++的时候，提示一堆什么破依赖关系不对，而且还不让我破坏。我真的吃柠檬了。然后上网疯狂搜，解决办法是【换源 + aptitude】</p><p>换源方法参考的是<a href="https://blog.csdn.net/fei20140908/article/details/78952341" target="_blank" rel="noopener">这个大佬</a>，反正大概就是系统设置 - 软件与更新 - 服务器选其他 - 查找最快源 - 找到之后设置成这个源，其实我也不知道有没有用，感觉迟早有用。</p><p>然后aptitude是一个提供解决依赖关系的程序</p><p>先安装一下</p><pre><code>sudo apt-get install aptitude</code></pre><p>然后用它来解决你的安装问题</p><pre><code>sudo aptitude install g++ //我是装g++啦</code></pre><p>然后会刷刷刷一大堆信息，最后给出一个提示办法，选择是[y/n/q]：</p><ul><li>选择y就是执行当前方案（它给我提供的第一个方案是啥也不做，然后告诉我解决问题啦，我：？？？）</li><li>n是拒绝当前方案，然后会提供下一个方案，反正我解决上面提到的sb依赖问题的方法是【降低装了的软件的版本】的那个方案，最后搞定了</li><li>q原来是quit的意思，我还以为是啥question的派生词，具体解释一下，还是太菜了…</li></ul><p>后面跟着流程走就搞定了</p><p>装完之后<code>-v</code> 看一下是不是装成功了 </p><hr><h3 id="编译-amp-MakeFile（占坑）"><a href="#编译-amp-MakeFile（占坑）" class="headerlink" title="编译&amp;MakeFile（占坑）"></a>编译&amp;MakeFile（占坑）</h3><ul><li>以后更新点关于makefile的</li><li>被自己菜哭了</li></ul><p>我凉了..为什么cd到out文件的目录下，执行命令还是</p><pre><code>//已经cd到a.out的目录下了a.out //a.out：未找到命令./a.out  //fuck you g++</code></pre><hr><h4 id="编译运行过程"><a href="#编译运行过程" class="headerlink" title="编译运行过程"></a>编译运行过程</h4><p>先创建一个生成makeFile文件的文件(CMakeLists.txt)，内容如下（选择使用，非一定全部）:</p><pre><code># makeFile名字叫CMakeLists.txt  大小写敏感 名字后缀敏感# 声明要求的cmake 最低版本cmake_minimum_required( VERSION 2.8 )# 声明一个cmake 工程project( HelloSLAM )# 添加一个可执行程序# 语法：add_executable( 程序名源代码文件）add_executable( a a.cpp ) #a为生成的程序名，a.cpp为源文件# 添加一个库#hello为库名，iamlib是源文件，里面没有main函数，只有一些定义好的函数或者变量add_library(hello iamlib.cpp)  #静态库add_libray(hello_shared SHARED iamlib.cpp) #动态库#将生成的库hello链接到可执行程序a中，此时a就可以调用hello中的函数了target_link_libraries(a hello) </code></pre><p>这里插一段书里面对动态库和静态库的解释：</p><blockquote><p>在Linux 中，库文件分成静态库和共享库两种。静态库以.a 作为后缀名，共享库以.so结尾。所有库都是一些函数打包后的集合，差别在于静态库每次被调用都会生成一个副本，而共享库则只有一个副本，更省空间。</p></blockquote><p>同时，为了使用这些库，还需要自己定义一个头文件，头文件里就是库里面的函数名，demo如下：</p><pre><code>#ifndef LIBHELLOSLAM_H_#define LIBHELLOSLAM_H_    void printHello();#endif</code></pre><p>之后在cpp里面引入这个头文件好像就可以调用里面的函数了。</p><p>然后调用cmake分析当前工程，生成makefile</p><pre><code>cmake .  //先cd到代码的当前目录</code></pre><p>然后使用生成的makeFile生成可执行文件</p><pre><code>make  //就是这个指令</code></pre><p>然后就生成了一个可执行文件，（占坑： a 和 a.out 的区别）</p><pre><code>./a  //运行</code></pre><p>十四讲还给出一个大佬做法，用于快捷删除编译的中间文件。大概就是新建一个目录然后对目录上一层进行cmake，这样子中间文件就都生成在当前目录了，最后make完再删掉就是了。</p><pre><code>mkdir buildcd buildcmake ..make</code></pre><hr><h3 id="Kdevelop使用"><a href="#Kdevelop使用" class="headerlink" title="Kdevelop使用"></a>Kdevelop使用</h3><p>安装东西使用aptitude感觉会比较靠谱</p><pre><code>sudo aptitude install kdevelop //选择第二个降版本的解决方案</code></pre><p>然后用法跟普通IDE差不多，不过添加工程文件好像是自己先写好CmakeList.txt之后，从导入工程-&gt;导入这个CmakeList.txt就可以了，以这个文件夹为根目录创建cpp和h文件，然后好像会自动进里一个build文件夹，然后【F8】就可以把项目run起来了（前提是cpp和h，CMakeLists都是正确的。</p><p>如果想使用debug模式（可以单步执行），需要在CmakeLists里面加入这一句：</p><pre><code>set( CMAKE_BUILD_TYPE &quot;Debug&quot;) //我是加到了工程名下面</code></pre><p>然后想run起来程序，还需要配置，打开【运行】 - 【配置启动器】 - 【Add New-应用程序（左上角加号)】 - 【工程目标选到可执行文件下】 - 【配置相干参数】（我好像是按了F8之后就会提示要这样子做）</p><p>搞定上面那一步之后，主界面的【Execute】就是直接跑，【Debug】就是设置断点模式单步进入，断点需要自己设置在代码每一行的左侧，然后就可以使用【Debug】。在Debug模式中，【F10】是单步运行，【F11】是单步跟进，【F12】是单步跳出，左边还能看到属性的值（看变量值这个真的舒服)。</p><p>(PS:然后我查了查，发现所有的IDE都可以，DEV是调试过程中选中那个变量然后右边【查看变量】，然后左边的窗口就会显示这个变量当前的值了，虽然看多维数组的时候有点麻烦，但好歹能看?)</p><p>(PSS:在今天以前，我一直是用cout来查看变量的值的，dbq，我真的太菜了）</p><p><a href="https://imgchr.com/i/AYk1xI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/24/AYk1xI.jpg" alt="AYk1xI.jpg"></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记（1）</title>
      <link href="/2019/03/21/vueLearning/vueLearning1/"/>
      <url>/2019/03/21/vueLearning/vueLearning1/</url>
      
        <content type="html"><![CDATA[<p>我是一条酸菜鱼。</p><a id="more"></a><p><a href="http://http://www.runoob.com/w3cnote/vue2-start-coding.html" target="_blank" rel="noopener">环境配置教程</a></p><p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">官方教程</a></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><img src="http://www.runoob.com/wp-content/uploads/2016/10/1476690217-1155-854231-1d2947692fba4957.png" alt></p><h3 id="配置淘宝镜像"><a href="#配置淘宝镜像" class="headerlink" title="配置淘宝镜像"></a>配置淘宝镜像</h3><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><h3 id="安装相关环境-node-js、cnpm、vue-cli"><a href="#安装相关环境-node-js、cnpm、vue-cli" class="headerlink" title="安装相关环境: node.js、cnpm、vue-cli"></a>安装相关环境: node.js、cnpm、vue-cli</h3><pre><code>npm -g install npm  //更新npm到最新版本cnpm install wekpack -g  npm install vue-cli -g </code></pre><h3 id="新建vue项目流程"><a href="#新建vue项目流程" class="headerlink" title="新建vue项目流程"></a>新建vue项目流程</h3><pre><code>vue init wekpack-simple &lt;name&gt;  //新建vue项目npm install //安装项目依赖cnpm install vue-router vue-resource --save //安装路由模块和网络请求模块npm run dev</code></pre><p>（webstorm好像有点牛逼?验证sysu邮箱可以免费用）</p><p>（感觉sublime + livereload好像也差不多）</p><hr><h3 id="Vue格式"><a href="#Vue格式" class="headerlink" title="Vue格式"></a>Vue格式</h3><pre><code>&lt;template&gt; -&gt; html&lt;script&gt; -&gt; js&lt;style&gt; -&gt; css</code></pre><hr><h2 id="简单语法"><a href="#简单语法" class="headerlink" title="简单语法"></a>简单语法</h2><p><a href="https://cn.vuejs.org/v2/guide/index.html" target="_blank" rel="noopener">官网教程</a></p><ul><li>基于HTML语法</li><li>声明式地绑定DOM和底层Vue实例</li><li>模板编译成虚拟DOM渲染函数（render fun）</li></ul><p>###vue文件</p><ul><li><p>html:</p><pre><code>&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;   //div的id属性，用于css编辑，与web一致&lt;div id=&quot;app-6&quot;&gt;&lt;p&gt;{{ abc }}&lt;/p&gt;   //第一种元素绑定方法，abc为变量名，script中可直接调用（Mustache语法，双大括号）&lt;span v-bind:title=&quot;new2&quot;&gt; //第二种元素绑定方法，new2为变量名，script中直接调用put here&lt;/span&gt;&lt;br/&gt;&lt;button v-on:click=&quot;change&quot;&gt;click here&lt;/button&gt;//与方法绑定，跟C#差不多&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></li></ul><ul><li>script</li></ul><pre><code>export default {  name: &apos;app&apos;,  //给整个vue组件定义变量名，可调用  data () { //vue实例中引用到的变量名    return {      msg: &apos;Welcome to Your Vue.js App&apos;,      abc: &apos;something&apos;,      new2: &apos;currentTime: &apos; + new Date().toLocaleString()}  },  methods: { //vue实例中使用到的函数（方法）    change: function(){      this.abc = &quot;you&quot;    }  }}</code></pre><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>Mustache - 双大括号，绑定的数据对象上msg属性发生改变时，此处改变。</p><pre><code>&lt;span&gt;Message: {{ msg }}&lt;/span&gt;</code></pre><p>使用双大括号会将数据解释成普通文本（如代码)。需要输出真正的HTML，要用v-html指令</p><pre><code>&lt;p&gt;Using mustaches: {{ rawHtml }}&lt;/p&gt; //输出文本&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; //改变样式</code></pre><blockquote><p>你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。</p></blockquote><ul><li><p>ustache 语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令：</p>  <div v-bind:id="dynamicId"></div></li></ul><p>在布尔特性的情况下，它们的存在即暗示为 true，v-bind 工作起来略有不同，在这个例子中：</p><pre><code>&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;</code></pre><p>如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled 特性甚至不会被包含在渲染出来的<code>&lt;button&gt;</code>元素中。</p><p>（突然发现md好像可以支持部分html，<button> 比如这样 </button>)</p><h3 id="vue指令"><a href="#vue指令" class="headerlink" title="vue指令"></a>vue指令</h3><blockquote><p>指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式。vue指令可以直接嵌在html的元素里面中去，也就是直接在元素中加入这一条属性，使用demo如下：</p></blockquote><pre><code>&lt;div id=&quot;app-6&quot;&gt;  &lt;p&gt;{{ message }}&lt;/p&gt;  &lt;input v-model=&quot;message&quot;&gt; //双向绑定，vue指令在这里使用&lt;/div&gt;var app6 = new Vue({  el: &apos;#app-6&apos;,  data: {message: &apos;Hello Vue!&apos;  }})    </code></pre><p>指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p><p>一些vue指令：</p><pre><code>v-bind:title = &quot;abc&quot;  //将元素节点的title 绑定 data中变量名为abc的变量v-if=&quot;a&quot;  //通过控制a，可以控制元素v-for = &quot;i in a&quot;   //循环处理a数组中的元素i的属性v-on:click = &quot;method&quot;  //v-on用于监听DOM事件//click操作调用method函数 click应该可以替换成其他操作v-model = &quot;abc&quot;  //实现表单输入(或其它元素）和应用状态之间的双向绑定v-once //执行一次性地插值</code></pre><p><strong>动态参数</strong></p><p>应该就是v-指令后面可以连接一个用方括号括起来的JS表达式（变量名），使得绑定的参数可以更灵活地动态调整。</p><p>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p><pre><code>&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;</code></pre><p>这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data 属性 attributeName，其值为 “href”，那么这个绑定将等价于 v-bind:href 。</p><p>详见<a href="https://cn.vuejs.org/v2/guide/syntax.html" target="_blank" rel="noopener">教程</a></p><p><strong>一些约束</strong></p><ul><li>动态参数的值应该是一个字符串，异常状态下是 null。（赋值null可以移除绑定？）</li><li>语法约束，某些字符（空格、引号）可能无效</li><li>浏览器会把特性名全部强制转换为小写，使用大写变量可能会出现问题</li><li>修饰符（半角句号 . 指明的特殊后缀)</li></ul><p>E: .prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：</p><pre><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;</code></pre><ul><li><p>缩写: Vue 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写：</p><pre><code>&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;--------------------------&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</code></pre></li></ul><h3 id="Vue实例中js使用"><a href="#Vue实例中js使用" class="headerlink" title="Vue实例中js使用"></a>Vue实例中js使用</h3><ul><li>可以绑定简单的属性键值</li><li>包括单个表达式，非语句 </li></ul><pre><code> //不生效 * 2{{var a = 1}}  {{ if (ok) { return message } }}</code></pre><hr><h3 id="关于-new-vue-和-export-default-的区别"><a href="#关于-new-vue-和-export-default-的区别" class="headerlink" title="关于 new vue 和 export default 的区别"></a>关于 new vue 和 export default 的区别</h3><blockquote><hr><p>在main.js当中已经有一个new vue了。作为被main.js  import的APP.vue ，App.vue当中应当有export default，这样才能在main.js中引入（也就是import）APP.vue当中的内容。</p></blockquote><blockquote><p>new vue是生成Vue根实例，而export default则是用来导出的。export default相当于提供一个接口给外界，让外界（这里也就是main.js）来引入使用。</p></blockquote><blockquote><p>在不使用App.vue 文件时，我们是通过 Vue 构造函数（new vue）创建一个 Vue 根实例来启动vuejs 项目，Vue 构造函数接受一个对象，这个对象有一些配置属性 el, data, component, template 等，从而对整个应用提供支持。</p></blockquote><blockquote><p>而现在我们的vue项目建好之后，有.vue也有.js，此时，在App.vue文件中，export default 后面的对象就相当于 new Vue() 构造函数中的接受的对象。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计—hw3</title>
      <link href="/2019/03/13/swsadHw/swsadhw3/"/>
      <url>/2019/03/13/swsadHw/swsadhw3/</url>
      
        <content type="html"><![CDATA[<h3 id="【简答题】"><a href="#【简答题】" class="headerlink" title="【简答题】"></a>【简答题】</h3><p><strong>1.简述瀑布模型、增量模型、螺旋模型（含原型方法）的优缺点（从项目特点、风险特征、人力资源利用角度思考）</strong></p><a id="more"></a><ul><li><p>瀑布模型:</p><ul><li>简述：瀑布模型设置了一系列的阶段，按顺序进行开发，项目开发进程从一个阶段流动到下一个阶段，形式上与物理世界中的瀑布非常相像。同时，每个阶段都会产生循环反馈，对临近阶段进行影响。</li><li>优点：<ul><li>降低软件开发的复杂程度，提高软件开发过程的透明性；同时，由于开发的基本流程和活动都是易理解的，因此提高了软件开发过程的可管理性。</li><li>推迟软件实现，强调在软件实现前必须进行分析和设计工作。</li><li>以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，保证了阶段之间的正确衔接，能够及时发现并纠正开发过程中存在的缺陷，使产品达到预期的质量要求。</li></ul></li><li>缺点：<ul><li>强调过程活动的线性顺序，因此理论上需要保证需求明确，且短期内可获得，每个阶段是无差错的。</li><li>缺乏灵活性，尤其无法解决软件需求不明确或不准确的问题。同时，在后期发现需求问题，更改的工作量十分巨大。</li><li>风险控制能力较弱，当前面需求模糊/前方成果不完善，会对后阶段产生巨大影响。</li><li>瀑布模型中的软件活动是文档驱动的，当阶段之间规定过多的文档时，会极大地增加系统的工作量。</li><li>管理人员如果仅仅以文档的完成情况来评估项目完成进度，往往会产生错误的结论，容易被人为误导。</li></ul></li></ul></li><li><p>增量模型:</p><ul><li>简述：增量模型是把待开发的软件系统模块化，将每个模块作为一个增量组件，分批次地分析、设计、编码和测试这些组块，具有一个递增式的开发过程。</li><li>优点：<ul><li>将待开发的软件系统模块化，可以分批次地提交软件产品，进行迭代式的开发，遵循“先做出来可以用的软件，再把软件做好。”的原则，因此对开发方较友好。</li><li>由于软件产品模块化交付，因此用户可以及时了解软件项目的进展并给出反馈，使得用户可以及时了解到项目进展，提升其在软件开发阶段的参与度和对项目的信息。</li><li>开发顺序灵活，开发人员可以对组件的实现顺序进行选择和优先级排序，先完成需求稳定的核心组件。当组件的优先级发生变化时，还能及时地对实现顺序进行调整。</li><li>降低了软件开发的风险，出现在组件中的错误可以被灵活解决，而不会对整个软件系统造成巨大的影响。</li></ul></li><li>缺点:<ul><li>待开发的软件系统需要可以被模块化；使用增量模型对难以模块化的软件系统进行开发会导致很多的问题：如模块划分，功能交付等。</li><li>增量粒度难以选择。</li><li>为了将软件系统分成多个模块，需要增加额外的工作量。</li></ul></li></ul></li><li><p>螺旋模型（含原型方法）：</p><ul><li>简述：螺旋模型采用周期性的方法进行开发，以进化的开发方式为中心，在不断迭代的过程中完成开发，且强调风险分析。</li><li><p>优点：</p><ul><li>设计上具有灵活性，可以在项目的各个阶段中或是下一次迭代中完成变更，可以不需要在一开始就给出具体明确的需求。</li><li>以小的分段来构造大型的系统，易于计算成本。</li><li>进行了风险分析，使得项目具有更高的可靠性。</li><li>由于快速原型法需要客户使用并提供反馈，因此提升了客户的参与度，保证了项目与客户需求是一致的，项目是可控的。同时提升了客户对项目的信心，对开发团队的认可。</li></ul></li><li><p>缺点：</p><ul><li>没有明确的项目终点，需要根据项目的具体进度进行判断。</li><li>建设周期长，可能导致软件开发的需求或核心技术与现实产生差距，无法满足当前用户的需求。</li><li>需要使用户确信这种模型的开发方法的结果是可以控制的。</li></ul></li></ul></li></ul><p><strong>2.简述统一过程三大特点，与面向对象的方法有什么关系？</strong></p><p>统一过程（Unified Process，UP）是一种以用例驱动的、以体系结构为核心的、迭代和增量的软件过程模型。由UML方法和工具支持，广泛应用于各类面向对象项目。<br>统一过程的三大特点分别是：</p><ol><li>软件开发是一个迭代的过程，是一种受控的迭代和增量式开发。</li><li>软件开发是由用例（Use Case）驱动的，也就是通过测试来推动整个开发过程的进行，在测试中完成需求分析、设计、质量控制等过程。这为整个开发过程提供了高效的驱动力。</li><li>软件开发是以体系结构为核心的。</li></ol><p><strong>3.简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？</strong></p><p>UP项目将其工作和迭代组织为四个主要阶段： </p><ol><li>初始（Inception）：大体上的构想、业务案例、范围和模糊评估。 <ul><li>里程碑：生命周期目标里程碑，包括一些重要的文档，如：项目构想(Vision)、原始用例模型、原始业务风险评估、一个或者多个原型、原始业务案例等。需要对这些文档进行评审，以确定正确理解用例需求、项目风险评估合理、阶段计划可行等。 </li></ul></li><li>细化（Elaboration）：已精化的构想、核心架构的迭代实现、高风险的解决、确定大多数需求和范围以及进行更为实际的评估。 <ul><li>里程碑：生命周期体系结构(Lifecycle Architecture) 里程碑。包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等。通过评审确定软件体系结构已经稳定、高风险的业务需求和技术机制已经解决、修订的项目计划可行等。 </li></ul></li><li>构造（Construction）：对遗留下来的风险较低和比较简单的元素进行迭代实现，准备部署。 <ul><li>里程碑：初始运行能力(Initial Operational Capability) 里程碑。包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署。此刻，要确定软件、环境、用户是否可以开始系统的运行。 </li></ul></li><li>移交（Transition）：进行beta测试和部署。 <ul><li>里程碑：产品发布(Product Release) 里程碑。确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周期。在一些情况下这个里程碑可能与下一个周期的初始阶段的相重合。</li></ul></li></ol><p>下图提供了一个可视化的循环过程：<br><img src="https://img-blog.csdnimg.cn/20190313144706784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1llem8xMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>4.软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？</strong></p><p>当企业使用UP进行软件开发时，基于UP迭代式、增量式的开发特点，整个开发过程可以被划分为几个固定的阶段和多次迭代的过程。也就是说，整个开发过程被划分成了固定的开发周期，因此企业就可以按照固定的节奏进行软件生产，也可以得到预期的生产周期并以此来形成一个发布软件产品的固定周期。<br>UP本身的特性，使得其可应用于各种领域的软件开发和不同的项目规模。其带来的好处有：</p><ul><li>企业可以将项目格式化、流程化，并对每一个流程标定固定的工作内容，使得整个系统架构更具有鲁棒性。</li><li>项目管理者以及客户都可以更了解开发进度、存在的问题和预期的目标，有利于开发者和使用者的交流，使得项目开发不会与需求偏差过大</li><li>开发过程可以进行风险分析和需求理解，降低了项目失败的概率</li></ul><hr><p>###【实践题】</p><p>了解使用 TAPD 的最佳实践</p><ul><li>比较完善 backlog 支持（树结构）</li><li>迭代（sprint）安排</li><li>较好的缺陷管理</li><li>Kanban</li><li>统计</li></ul><p>###【大作业准备】</p><ul><li>按大作业要求组件团队、思考项目题目与内容</li><li>将团队暂时分为技术研究、业务调研两个部分<ul><li>技术团队初步确定技术方法，力争做一些技术原型，如 基于 MVC 框架的的用户登陆实现</li><li>业务调研团队调查竞争性产品，分析它们的基础、共性业务以及竞争优势</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计—hw2</title>
      <link href="/2019/03/09/swsadHw/swsadhw2/"/>
      <url>/2019/03/09/swsadHw/swsadhw2/</url>
      
        <content type="html"><![CDATA[<h3 id="【简答题】"><a href="#【简答题】" class="headerlink" title="【简答题】"></a>【简答题】</h3><p><strong>1.用简短的语言给出对分析、设计的理解。</strong></p><p>分析就是对用户给出的软件功能等方面的需求进行系统的研究，识别出主号问题，确定待开发软件的功能、性能、接口、数据、界面等具体的细节要求。<br>设计就是基于需求分析中得到的需求，构造出目标系统的逻辑模型，最终得到一个可供编码过程参考的设计模型文档。</p><blockquote><p>软件分析不是发现更多的功能与需求，而是确认有效的功能与需求，去伪存真不断满足客户需要。软件设计也不是追求最先进技术，而是控制变化附加的成本，使得软件生产的预算、时间等能在掌控之中。</p></blockquote><a id="more"></a><hr><p><strong>2.用一句话描述面向对象的分析与设计的优势。</strong></p><p>面向对象的分析与设计能够通过分析现实世界中存在的问题，并构建相对应的问题模型，保持了他们的结构、关系和行为模式，具有易理解和易维护的特性。</p><hr><p><strong>3.简述 UML（统一建模语言）的作用。考试考哪些图？</strong></p><p>UML（Unified Modeling Language）用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品。 它可以将面向对象分析（OOA）和面向对象设计（OOD）使用统一定义的符号表示出来，并将对象自身的属性、对象与对象之间的关联关系可视化，提升项目结构的可读性。</p><p>考试的重点图形: </p><p>图形化的表示机制，十多种视图，分4类：</p><ul><li>用例图：用户角度：功能、执行者</li><li>静态图：系统静态结构<ul><li>类图：概念及关系</li><li>对象图：某种状态或时间段内，系统中活跃的对象及其关系</li><li>包图：描述系统的分解结构</li></ul></li><li>行为图：系统的动态行为<ul><li>交互图：描述对象间的消息传递<ul><li>顺序图：强调对象间消息发送的时序</li><li>合作图：强调对象间的动态协作关系</li></ul></li><li>状态图：对象的动态行为。状态-事件-状态迁移-响应动作</li><li>活动图：描述系统为完成某功能而执行的操作序列</li></ul></li><li>实现图：描述系统的组成和分布状况<ul><li>构件图：组成部件及其关系</li><li>部署图：物理体系结构及与软件单元的对应关系</li></ul></li></ul><hr><p><strong>4.从软件本质的角度，解释软件范围（需求）控制的可行性</strong></p><p>软件的本质包括复杂性、一致性、可变性和不可视性。基于IEEE中给出的软件特点：</p><blockquote><ul><li>Software requirements are prone to frequent change</li><li>In many cases, requirements allocated to software must be renegotiated and reprioritized</li><li>Small changes to software can have large negative effects（There are no small software changes） </li></ul></blockquote><p>对于软件的需求可能会因为不一致、不可使、易于变化的环境而更改，需求的更改会带来软件的改动，这就可能会产生巨大的负面影响，包括开发难度的增加，开发周期的增长等。为了尽可能避免以上情况的发生，我们必须对软件需求进行范围的划定和控制。即在需求分析与设计的过程中，我们必须在给定的范围内围绕软件开发的成本进行调控，允许范围内、不造成巨大影响的需求变更和迭代，最终保证软件开发周期和成本是可控的，在约定的时间内交付出可满足客户的软件成品。因此，软件范围需求控制是可行且必须的。</p><hr><p>###【看板使用练习】<br><a href="https://imgchr.com/i/AmZyQJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmZyQJ.jpg" alt="AmZyQJ.jpg"></a><br><a href="https://imgchr.com/i/AmZvY8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmZvY8.md.png" alt="AmZvY8.md.png"></a></p><p>###【UML绘图工具练习】</p><p>图选自  《UML和模式应用（中文第三版）》 P193  </p><p> <strong>图16-16 UML中的关联类</strong><br><a href="https://imgchr.com/i/AmVzrR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmVzrR.jpg" alt="AmVzrR.jpg"></a></p><p><strong>图16-17 表示单实例类</strong><br><a href="https://imgchr.com/i/AmZSq1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmZSq1.jpg" alt="AmZSq1.jpg"></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计—hw1</title>
      <link href="/2019/03/06/swsadHw/swsadhw1/"/>
      <url>/2019/03/06/swsadHw/swsadhw1/</url>
      
        <content type="html"><![CDATA[<h3 id="【简答题】"><a href="#【简答题】" class="headerlink" title="【简答题】"></a>【简答题】</h3><p><strong>1.软件工程的定义</strong></p><blockquote><p>Software engineering is “(1) the application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software, that is, the application of engineering to software,” and “(2) the study of approaches as in (1).” –– IEEE Standard 610.12</p></blockquote><p>软件工程的定义： </p><ul><li>(1) 将系统化、规范化、可度量的方法应用与软件的开发、运行和维护-的过程，即将工程化应用于软件中。 </li><li>(2) 对(1)中所述方法的研究。</li></ul><p>软件工程知识体系:</p><ul><li>以高质量为目标，研究软件生产的过程模型、方法和工具</li></ul><a id="more"></a><hr><p><strong>2.解释导致 software crisis 本质原因、表现，述说克服软件危机的方法</strong><br>软件危机（Software Crisis）是一个早期的计算机科学用语，指的是在给定时间内编写出可用和高效的程序的困难性。现在引申至指软件在开发和维护过程中出现的一系列严重的问题。<br>在1972年，Edsger Dijkstra 指出计算能力约强大，编程越是大问题。因此导致软件危机的本质原因是计算机计算能力的迅速增长，以及计算机能力增长而导致软件需要处理和解决的问题具有更大的复杂性。也就是计算机计算能力的提高超过了程序员能够高效利用计算机的能力。<br>软件危机的主要表现有：</p><ul><li>进行了超预算的项目</li><li>项目长期无法完成</li><li>软件非常低效</li><li>软件质量低下</li><li>软件经常与用户的需求不匹配</li><li>项目难以管理</li><li>程序代码的后期维护存在困难</li><li>软件无法完成并交付</li></ul><hr><p><strong>3.软件生命周期</strong></p><p>软件生命周期（Software Development LifeCycle）是指软件的产生直到成熟的全部过程。早期的软件生命周期受到瀑布模型的影响，因此通常定义为：</p><blockquote><p>软件从计划、需求开始，经历分析设计、实现、部署、维护，直到最后逐渐消亡的。</p></blockquote><p>因此，现在对软件生命周期及软件生命周期模型采用如下定义：</p><ul><li>软件生命周期是指软件的产生直到成熟的全部过程。</li><li>软件生命周期模型是指人们为开发更好的软件而归纳总结的软件生命周期的典型实践参考。</li></ul><p>根据GB/T 8567的定义，软件生命周期分为以下6个阶段：</p><ul><li>可行性分析与计划</li><li>需求分析</li><li>设计（概要设计和详细设计）</li><li>编码实现</li><li>测试</li><li>运行和维护</li></ul><p>常见的软件生命周期模型有原型模型、螺旋模型、迭代模型。</p><hr><p><strong>4.SWEBoK 的 15 个知识域（An Overview of the SWEBOK Guide 请中文翻译其名称与简短说明）</strong></p><p>SWEBOK V3中的15个知识域包括：</p><p><strong>11个软件工程实践知识域：</strong></p><ul><li><strong>软件需求 Software requirements</strong><br>真实世界问题而必须展示的特性。软件需求的知识域包括七个子域，即软件需求基础、需求过程、需求获取、需求分析、需求规格说明、需求确认和实践考虑。</li><li><strong>软件设计 Software design</strong><br>根据IEEE [ IEEE 610.12-90] ，设计既是”定义一个系统或组件的体系结构、组件、接口和其他特征的过程”，又是”这个过程的结果”。软件设计的知识域包括六个子域，即软件设计基础、软件设计关键问题、软件结构与体系结构、软件设计质量的分析与评价、软件设计符号、软件设计的策略与方法。</li><li><strong>软件构造 Software construction</strong><br>它指通过编码、验证、单元测试、集成测试和排错的组合，具体创建一个可以工作的、有意义的软件，其知识域包括软件构造基础、管理构造、实际考虑三个子域。</li><li><strong>软件测试 Software testing</strong><br>它是由在有限测试用例集合上，根据期望的行为，对程序的行为进行的动态验证组成， 测试用倒是实际上无限的执行域中适当选择出来的。软件测试包括五个子域，即软件测试基础和测试级别、测试技术、需求分析、与测试相关的度量、测试过程。</li><li><strong>软件维护 Software maintenance</strong><br>软件一旦投入运行，就可能出现异常，运行环境可能发生改变，用户会提出新的需求。生命周期软件维护阶段从软件交付时开始，但是维护活动出现得还要早。软件维护的知识域包括四个子域，即软件维护基础、软件维护的关键问题、维护过程、维护技术。</li><li><strong>软件配置管理 Software configuration management</strong><br>为了系统地控制配置的变更和维护在整个系统生命周期中的完整性和可追踪性，而标志软件在时间上不同点的配置的学科。软件配置管理包括六个子域，即软件配置管理过程管理、软件配置标志、软件配置控制、软件配置状态统计、软件配置审核、软件发行管理和交付。</li><li><strong>软件工程管理 Software engineering management</strong><br>处理软件工程的管理与度量，虽然度量是所有知识域的一个重要方面，但是这里涉及的是度量程序的专题。软件工程管理包括六个子域，即启动和范围定义、软件项目计划、软件项目实施、评审与评价、关闭、软件工程度量。前五个覆盖软件过程工程 管理，第六个描述软件度量的程序。</li><li><strong>软件工程过程 Software engineering process</strong><br>涉及软件工程过程本身的定义、实现、评定、度量、管理、变更和改进。软件工程过程包括四个子域，即过程实施与改变、过程定义、过程评定、过程和产品度量。</li><li><strong>软件工程模型和方法  Software engineering models and methods</strong><br>包括软件工程工具、软件工程方法两个子域。</li><li><strong>软件质量 Software quality</strong><br>处理跨越软件生命周期过程的软件质量的考虑，由于软件质量在软件工程中元处不在，其他知识域也涉及质量 问 题。软件质量包括三个子域，即软件质量基础、软件质量过程、实践考虑。</li><li><strong>软件工程职业实践 Software engineering professional practice</strong></li></ul><p><strong>4个软件工程教育基础知识域：</strong></p><ul><li><strong>软件工程经济学 Software engineering economics</strong></li><li><strong>计算基础 Computing foundations</strong></li><li><strong>数学基础 Mathematical foundations</strong></li><li><strong>工程基础 Engineering foundations</strong></li></ul><hr><p><strong>5.简单解释 CMMI 的五个级别。例如：Level 1 - Initial：无序，自发生产模式。</strong></p><p>能力成熟度模型集成（英语：Capability Maturity Model Integration，简称CMMI或“希迈”）是一种改进过程的方法，其目的是协助提升组织的绩效。</p><p><strong>Level 1 - Initial：初始级。</strong><br>软件过程是无序的，有时甚至是混乱的，对过程几乎没有定义，成功取决于个人努力。管理是反应式的。</p><p><strong>Level 2 - Managed：可管理级。</strong><br>建立了基本的项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。</p><p><strong>Level 3 - Defined：已定义级。</strong><br>已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。</p><p><strong>Level 4 - Quantitatively Managed：量化管理级。</strong><br>分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。</p><p><strong>Level 5 - Optimizing：优化管理级。</strong><br>过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。</p><hr><p><strong>6.用自己语言简述 SWEBok 或 CMMI （约200字）</strong></p><p>SWEBok即软件工程知识体系指南（Guide to the Software Engineering Body of Knowledge)，是一个得到普遍认可的共识性软件工程本体知识结构。（其历史可追溯到1999年4月由发表的《软件工程知识本体结构》报告。报告的发布使人们达成了共识，即建立软件工程本体知识结构是解决如何验证软件工程工程师的资格、如何设置并检验软件工程相关课程等难题的答案。）SWEBok的目的是为软件工程学科的范围提供一致的认识，为支持该学科的本体知识提供指导。SWEBOK V3将软件工程学科的本体知识分为15个知识域，并对每个知识域中的重要概念和区别加以阐述说明。也就是说，SWEBok最大的贡献是将原本混杂的软件工程知识体系化，将原本存在的知识分类整理，最后形成一个具有共识性和方向性的指南。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BringMeFly</title>
      <link href="/2019/02/27/Personal/hello-world/"/>
      <url>/2019/02/27/Personal/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Update it when i have time.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
