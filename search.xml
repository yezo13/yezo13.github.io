<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/04/08/swsadHw/UseCase/"/>
      <url>/2019/04/08/swsadHw/UseCase/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h3><ul><li><p>Actors（参与者）：与系统交互的外部实体（具有某些行为的事物），如person（identified by role），计算机系统，组织。</p><ul><li>Primary actor（主要参与者）：使用服务来满足用户的需求（fullfilled users‘ goals）。（如收银员）<ul><li><strong>Find user goals to drive the use cases.</strong></li></ul></li><li>Supporting actor（协作参与者）：提供服务（通常是电脑，或者是组织/人）。（如收银系统）<ul><li><strong>The purpose is to clarify external interfaces and protocols.</strong></li></ul></li><li>Offstage actor（幕后参与者）：对用例行为有<strong>兴趣</strong>，但不是以上两种actor的一类actor。（如政府的税收部门）</li><li>最特殊的参与者：如系统时钟。</li></ul></li><li><p>场景（scenario）：参与者和系统之间的一系列特定的活动和交互，也称为用例实例（use case instance）。场景是使用系统的一个特定情节或用例的一条执行路径。</p></li><li><p>用例（User Case）是<strong>文本形式的情节描述</strong>，用以说明某参与者使用系统以实现某些目标。用例广泛应用于需求的发现和记录工作中。</p></li><li>用例是是一组相关的<strong>成功和失败的场景</strong>（success and failure scenarios），这些场景是用于描述一个actor使用系统去support一个目标（goal）。</li><li>用例一定是text文档，不会是图表。<strong>Use case modeling</strong>(用例建模） is primarily an act of writing text, not drawing diagrams.</li><li>There is nothing object-oriented（面向对象） about use cases</li><li>Use cases are a key requirements input to classic OOA/D（OOA/D全称面向对象分析方法（Object-Oriented Analysis））。<ul><li>翻译：用例是经典OOA/D的关键需求输入。</li></ul></li></ul><h3 id="用例和用例模型（User-Case-Model）"><a href="#用例和用例模型（User-Case-Model）" class="headerlink" title="用例和用例模型（User-Case Model）"></a>用例和用例模型（User-Case Model）</h3><ul><li>定义：用例模型是所有书面用例的集合；同时，它是系统功能性和环境的模型。</li><li><strong>Use case modeling</strong>(用例建模） is primarily an act of writing text, not drawing diagrams.</li></ul><h3 id="关于用例"><a href="#关于用例" class="headerlink" title="关于用例"></a>关于用例</h3><h4 id="为什么使用用例"><a href="#为什么使用用例" class="headerlink" title="为什么使用用例"></a>为什么使用用例</h4><ul><li>用例使领域专家或者需求提供者自己编写（或参与编写）用例成为可能，并使得这项工作难度降低。</li><li>用例<strong>强调了用户的目标和观点。</strong></li><li>用例能够根据需要对复杂程度和形式化程序进行增减调节。</li><li>用例就是需求，主要是说明系统如何工作的功能性或行为性需求。用例是真正的需求，但不是所有的需求。</li></ul><h3 id="三种常见的用例格式（format）"><a href="#三种常见的用例格式（format）" class="headerlink" title="三种常见的用例格式（format）"></a>三种常见的用例格式（format）</h3><ul><li>Brief (high level)<ul><li>Terse one-paragraph summary, usually of the main success<br>scenario.（简洁的一段式概要，通常用于主成功场景）</li><li>During early requirements analysis, to get a quick sense of subject and scope. May take only a few minutes to create.（在早期需求分析过程中使用，目的是为了快速了解主题和范围。可能只需要几分钟进行编写）</li></ul></li><li>Casual（简便格式）<ul><li>Informal paragraph format. Multiple paragraphs that cover various scenarios.（非正式的段落格式。用几个段落覆盖不同场景）</li><li>When? As above.（时间点同上）</li></ul></li><li>Fully（详述）<ul><li>dressed All steps and variations are written in detail, and there are  supporting sections, such as preconditions and success guarantees.（详细编写所有步骤及各种变化，同时具有补充部分，如前置条件和成功保证）。<ul><li>After many use cases have been identified and written in a brief format, then during the first requirements workshop a few (such as 10%) of the architecturally significant and high-value use cases are written in detail.（在确定并以摘要形式白那些了大量用例后，在第一次需求讨论会中，详细地编写其中少量（例如10%）的具有重要架构意义和高价值的用例）</li></ul></li></ul></li></ul><h3 id="用例测试"><a href="#用例测试" class="headerlink" title="用例测试"></a>用例测试</h3><ul><li>判断一个用例是否有效用例，取决于系统边界、参与者和目标。</li></ul><h4 id="老板测试-The-Boss-Test"><a href="#老板测试-The-Boss-Test" class="headerlink" title="老板测试(The Boss Test)"></a>老板测试(The Boss Test)</h4><p>判断用例与达到可量化价值的结果之间的关系程度。如果一个用例与达到可量化价值的目标之间没有存在强的联系关系，那么这个用例可能无法通过老板测试。</p><h4 id="EBP测试-The-EBP-Test"><a href="#EBP测试-The-EBP-Test" class="headerlink" title="EBP测试(The EBP Test)"></a>EBP测试(The EBP Test)</h4><ul><li>EBP即基本业务过程（Elementary Business Process），是源于业务过程工程领域的术语。</li><li>EBP的定义：<strong>一个人</strong>于<strong>某个时刻</strong>在<strong>一个地点</strong>所执行的任务（A task performed by one person in one place at one time），用以响应业务事件。该任务能够增加可量化的业务价值（measurable business value），并且以持久状态留下数据。</li></ul><h3 id="规模测试-The-Size-Test"><a href="#规模测试-The-Size-Test" class="headerlink" title="规模测试(The Size Test)"></a>规模测试(The Size Test)</h3><ul><li>判断一个用例的规模是否正确。一般来说，用例很少由单独的活动或步骤组成，而是通常包含多个步骤。</li><li>用例建模中的一个常见错误就是仅将一系列相关步骤中的一个步骤（just a single step）定义为用例，这会因规模过小而获得错误的提示。</li></ul><h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>用例图主要用来描述用户、需求、系统功能单元之间的关系。用例图的基本符号及元素如下所示：</p><ol><li>参与者（Actor）：表示与系统或程序进行交互的用户、组织或外部系统。</li><li>用例（Use Case）：外部可用的系统功能，对系统提供的服务进行描述。</li><li><p>子系统（Subsystem）：用来展示系统的一部分功能，这部分功能一般具有紧密的联系。</p><p> <img src="https://img-blog.csdnimg.cn/20190406104159280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1llem8xMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>关系（relation）：用例图中涉及到的关系包括关联、泛化、包含、扩展。</p></li></ol><p><img src="http://www.uml.org.cn/oobject/images/2012091324.png" alt></p><ul><li>关联（Association）：说明了参与者与用例之间的通信，任何一方都可以发送或接受信息，箭头指向的是消息的接收方</li></ul><p><img src="http://www.uml.org.cn/oobject/images/2012091325.png" alt></p><ul><li>泛化（Inheritance）：就是通常理解的继承关系，子用例继承了父用例的所有结构、行为和关系，同时表现出更特别的行为。子用例可以选择使用或者重载父用例的一段行为，而父用例一般是抽象的。</li></ul><p><img src="http://www.uml.org.cn/oobject/images/2012091326.png" alt></p><ul><li>包含（Include）：包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤，箭头指向分解出来的功能用例，旁边需要显式写出该关系（《包含》或者<code>&lt;Includes&gt;</code>）</li></ul><p><img src="http://www.uml.org.cn/oobject/images/2012091327.png" alt></p><ul><li>扩展（Extend）：扩展关系是指当前用例功能的延伸，相当于给当前基础样例提供附加的功能。箭头指向原来的基础样例。</li></ul><p><img src="http://www.uml.org.cn/oobject/images/2012091328.png" alt><br>一些新增的扩展可以看<a href="https://josh-persistence.iteye.com/blog/2031451" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计—hw4</title>
      <link href="/2019/04/04/swsadHw/swsadhw4/"/>
      <url>/2019/04/04/swsadHw/swsadhw4/</url>
      
        <content type="html"><![CDATA[<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><h3 id="1-用例的概念"><a href="#1-用例的概念" class="headerlink" title="1. 用例的概念"></a>1. 用例的概念</h3><p>用例（Use Case），也叫使用案例、用况，是软件工程或系统工程中对系统如何反应外界请求的描述，是一种通过用户的使用场景来获取需求的技术。通俗地讲，用例是<strong>文本形式的情节描述</strong>，用以说明某参与者使用系统以实现某些目标。</p><a id="more"></a><h3 id="2-用例和场景的关系？什么是主场景或-happy-path？"><a href="#2-用例和场景的关系？什么是主场景或-happy-path？" class="headerlink" title="2. 用例和场景的关系？什么是主场景或 happy path？"></a>2. 用例和场景的关系？什么是主场景或 happy path？</h3><p>用例是是一组相关的<strong>成功和失败的场景</strong>（success and failure scenarios），这些场景是用于描述一个actor使用系统去support一个目标（goal）。</p><p>我认为问题这里提到的主场景应该是指书上的<strong>主成功场景（Main Success Scenario）</strong>，也叫做<strong>基本流程（基本事件流，basic flow)、理想路径场景（happy path）</strong>，这是用例最基本的组成部分，它描述了<strong>满足涉众关注点的典型成功路径</strong>。</p><p>主场景通常不包括任何条件或分支，这是为了保持连贯性，并且将所有的条件处理都延迟到扩展部分。通常一个用例具有一个基本流和多个例外流。</p><h3 id="3-用例有哪些形式？"><a href="#3-用例有哪些形式？" class="headerlink" title="3.用例有哪些形式？"></a>3.用例有哪些形式？</h3><ul><li>Brief (high level)<ul><li>Terse one-paragraph summary, usually of the main success<br>scenario.（简洁的一段式概要，通常用于主成功场景）</li><li>During early requirements analysis, to get a quick sense of subject and scope. May take only a few minutes to create.（在早期需求分析过程中使用，目的是为了快速了解主题和范围。可能只需要几分钟进行编写）</li></ul></li><li>Casual（简便格式）<ul><li>Informal paragraph format. Multiple paragraphs that cover various scenarios.（非正式的段落格式。用几个段落覆盖不同场景）</li><li>When? As above.（时间点同上）</li></ul></li><li>Fully（详述）<ul><li>dressed All steps and variations are written in detail, and there are  supporting sections, such as preconditions and success guarantees.（详细编写所有步骤及各种变化，同时具有补充部分，如前置条件和成功保证）。<ul><li>After many use cases have been identified and written in a brief format, then during the first requirements workshop a few (such as 10%) of the architecturally significant and high-value use cases are written in detail.（在确定并以摘要形式白那些了大量用例后，在第一次需求讨论会中，详细地编写其中少量（例如10%）的具有重要架构意义和高价值的用例）</li></ul></li></ul></li></ul><h3 id="4-对于复杂业务，为什么编制完整用例非常难？"><a href="#4-对于复杂业务，为什么编制完整用例非常难？" class="headerlink" title="4.对于复杂业务，为什么编制完整用例非常难？"></a>4.对于复杂业务，为什么编制完整用例非常难？</h3><p>首先，整个用例编写过程当中，理想路径与扩展场景相结合也只能尽可能满足“几乎”所有涉众所关注的问题，因为有些问题最好是作为非功能性需求在补充规格说明中描述，而不是直接在用例中说明。<br>此外，由于业务的复杂性，在简单的需求讨论和短时间的开发迭代中，一定无法覆盖整个业务的所有需求，因此用例的增加也只能覆盖大部分已出现的情形，而无法完全覆盖所有情景，也就“不完整”。同时，用例可能会遗漏一些关键信息或包含错误的陈述。</p><h3 id="5-什么是用例图？"><a href="#5-什么是用例图？" class="headerlink" title="5.什么是用例图？"></a>5.什么是用例图？</h3><p>用例图是一种优秀的系统语境图（context diagram），也就是说用例图可以展示系统边界、位于边界之外的事物以及系统如何被使用。同时，用例图可以作为沟通的工具，用以概括系统及其参与者的行为。</p><h3 id="6-用例图的基本符号与元素？"><a href="#6-用例图的基本符号与元素？" class="headerlink" title="6.用例图的基本符号与元素？"></a>6.用例图的基本符号与元素？</h3><p>用例图主要用来描述用户、需求、系统功能单元之间的关系。用例图的基本符号及元素如下所示：</p><ol><li>参与者（Actor）：表示与系统或程序进行交互的用户、组织或外部系统。</li><li>用例（Use Case）：外部可用的系统功能，对系统提供的服务进行描述。</li><li><p>子系统（Subsystem）：用来展示系统的一部分功能，这部分功能一般具有紧密的联系。</p><p> <a href="https://imgchr.com/i/A4JbsH" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/08/A4JbsH.md.jpg" alt="A4JbsH.md.jpg"></a></p></li><li><p>关系（relation）：用例图中涉及到的关系包括关联、泛化、包含、扩展。</p></li></ol><p><img src="http://www.uml.org.cn/oobject/images/2012091324.png" alt></p><ul><li>关联（Association）：说明了参与者与用例之间的通信，任何一方都可以发送或接受信息，箭头指向的是消息的接收方</li></ul><p><img src="http://www.uml.org.cn/oobject/images/2012091325.png" alt></p><ul><li>泛化（Inheritance）：就是通常理解的继承关系，子用例继承了父用例的所有结构、行为和关系，同时表现出更特别的行为。子用例可以选择使用或者重载父用例的一段行为，而父用例一般是抽象的。</li></ul><p><img src="http://www.uml.org.cn/oobject/images/2012091326.png" alt></p><ul><li>包含（Include）：包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤，箭头指向分解出来的功能用例，旁边需要显式写出该关系（《包含》或者<code>&lt;Includes&gt;</code>）</li></ul><p><img src="http://www.uml.org.cn/oobject/images/2012091327.png" alt></p><ul><li>扩展（Extend）：扩展关系是指当前用例功能的延伸，相当于给当前基础样例提供附加的功能。箭头指向原来的基础样例。</li></ul><p><img src="http://www.uml.org.cn/oobject/images/2012091328.png" alt></p><h3 id="7-用例图的画法与步骤"><a href="#7-用例图的画法与步骤" class="headerlink" title="7.用例图的画法与步骤"></a>7.用例图的画法与步骤</h3><ol><li>确认系统边界，包括系统名称以及系统的范围（方框所包含的东西)</li></ol><ol start="2"><li>确定参与者，包括:<ul><li>主要参与者：谁将使用系统的主要功能、谁将需要系统的支持以完成工作等</li><li>协作参与者：谁将提供对应的系统功能、谁将维护系统，保证系统处于工作状态等</li><li>幕后参与者：谁会对系统产生的结果感兴趣</li></ul></li></ol><ol start="3"><li><p>根据用户需求识别和创作用例，主要重点在于：</p><ul><li>参与者希望系统提供什么样的功能（用例）</li><li>系统具有哪些功能（用例），如是否支持存储和检索信息</li><li>系统对应的功能由哪些参与者触发</li><li>当系统状态改变时，参与者是否会得到通知</li><li>参与者与事件的对应关系</li><li>是否存在影响系统的外部事件</li></ul></li><li><p>确认用例间的关系，包括关联、包含、扩展和泛化</p></li><li>确定外部接口，如API的调用</li><li>根据上面已经确定的关系已经用例图规范进行用例图的绘制，可以借助例表来详细说明一个较复杂（可能无法只通过用例图说明清楚）的用例</li></ol><h3 id="8-用例图给利益相关人与开发者的价值有哪些？"><a href="#8-用例图给利益相关人与开发者的价值有哪些？" class="headerlink" title="8.用例图给利益相关人与开发者的价值有哪些？"></a>8.用例图给利益相关人与开发者的价值有哪些？</h3><ul><li>用例<strong>强调了用户的目标和观点</strong>，使得用户能够更多地参与到系统的设计当中去，保证系统按照用户的需求进行设计。而用例图则将用例图形化、具象化了，使得整个系统中用例、参与者之间的关系更加清晰地表达出来。</li><li>用例能够根据需要对复杂程度和形式化程序进行增减调节，即能够响应用户（利益相关人)提出的需求，而用例图则使得这种调节更加便利，可以通过修改图形间的关系实现。</li><li>用例图使得开发者能够更明确地获得需求，更好地理解需求。</li><li>用例图可以指导开发和测试，同时可以在整个过程中对其他工作流起到指导作用。</li></ul><h2 id="2、建模练习题（用例模型）"><a href="#2、建模练习题（用例模型）" class="headerlink" title="2、建模练习题（用例模型）"></a>2、建模练习题（用例模型）</h2><h3 id="选择2-3个你熟悉的类似业务的在线服务系统（或移动-APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求："><a href="#选择2-3个你熟悉的类似业务的在线服务系统（或移动-APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求：" class="headerlink" title="选择2-3个你熟悉的类似业务的在线服务系统（或移动 APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求："></a>选择2-3个你熟悉的类似业务的在线服务系统（或移动 APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求：</h3><ul><li>请使用用户的视角，描述用户目标或系统提供的服务</li><li>粒度达到子用例级别，并用 include 和 exclude 关联它们</li><li>请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例</li><li>尽可能识别外部系统和服务</li></ul><p>这是一个在线民宿租赁网站的用例模型：</p><p><a href="https://imgchr.com/i/A4JxFP" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/08/A4JxFP.md.jpg" alt="A4JxFP.md.jpg"></a></p><p>这是一个演出门票销售网站的用例模型：</p><p><img src="https://s2.ax1x.com/2019/04/12/AqlAl6.png" alt="AqlAl6.png"></p><h3 id="然后，回答下列问题："><a href="#然后，回答下列问题：" class="headerlink" title="然后，回答下列问题："></a>然后，回答下列问题：</h3><h3 id="为什么相似系统的用例图是相似的？"><a href="#为什么相似系统的用例图是相似的？" class="headerlink" title="为什么相似系统的用例图是相似的？"></a>为什么相似系统的用例图是相似的？</h3><p>因为相似的系统中，用户预期的功能都是相似的，即不同的同类系统一定具有一致基本功能以及带有自己特色的扩展功能。以酒店预订系统为例，使用该系统的用户一般提供时间、地点、价格等信息，利用系统来搜索出符合信息的房间并进行预定，因此所有的系统都需要包括这样的功能，才能够满足用户的需求。因此，相似的系统一定会有相似的功能，也就具有相似的actor、use case和associate，因此也就具有相似的用例图。</p><h3 id="如果是定旅馆业务，请对比-Asg-RH-用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术。"><a href="#如果是定旅馆业务，请对比-Asg-RH-用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术。" class="headerlink" title="如果是定旅馆业务，请对比 Asg_RH 用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术。"></a>如果是定旅馆业务，请对比 Asg_RH 用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术。</h3><p>对比Asg_RH与airbnb的用例图，可以对比发现技术的创新具有以下角度：</p><ol><li>可以从时代特性和对应的用户需求出发。如现在是一个快节奏的时代，用户追求效率和便利的操作。对比airbnb和asg_rh，airbnb的操作无疑更加简单快捷，且具有一个更优秀的过滤系统，提供了多种条件来供用户对房源进行过滤，使得用户更高效地挑选到自己心仪的房源，很大程度地提升了用户的使用体验。</li><li>从业务创新出发。对比传统的酒店预定系统只能够预定房间，airbnb考虑到了用户属性的多样性，即他们本身也可能具有闲置的房源，扩充了软件使用者的属性，使user可以在租客和租户的身份之间自由切换，提供了更多的功能选择。</li><li>从用户信息保护和反馈出发。首先，airbnb较传统的订旅馆业务而言，对用户的信息作出了更好的保护，如只有在预定房间之后才知道房间的准确定位，这无疑是对民宿类的房间信息有了更好的保护。其次，airbnb提供了双向的评价，即用户和提供住宿的组织在完成一次交易后是互相评价的，这样有效地筛选出了优质的用户和租赁方。</li><li>从吸引用户的角度出发。airbnb通过合理分析用户的上传数据，提供了一些“猜你喜欢”的功能以及活动奖励，有效地提升了用户粘性以及软件对用户的吸引力。</li></ol><h3 id="如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用"><a href="#如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用" class="headerlink" title="如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用"></a>如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用</h3><p>使用不同颜色背景的用例图表示不同层次和方式的创新思路，使得其在系统中的作用能够直观体现。</p><h3 id="请使用-SCRUM-方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表"><a href="#请使用-SCRUM-方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表" class="headerlink" title="请使用 SCRUM 方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表"></a>请使用 SCRUM 方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表</h3><p>Product Backlog 是 Scrum 的核心，也是一切的起源。从根本上说，它就是一个需求、或故事、或特性等组成的列表，按照重要性的级别进行了排序。它里面包含的是客户想要的东西，并用客户的术语加以描述。我们叫它故事（Story），有时候也叫做 Backlog 条目。 一般包括以下字段：</p><ul><li>ID：统一标识符，就是个自增长的数字而已。以防重命名故事以后找不到它们。</li><li>Name（名称）：简短的、描述性的故事名。比如“查看你自己的交易明细”。它必须要含义明确，这样开发人员和产品负责人才能大致明白我们说的是什么东西，跟其他故事区分开。它一般由2到10个字组成。</li><li>Importance（重要性）：产品负责人评出一个数值，指示这个故事有多重要。例如10或150。分数越高越重要。</li><li>Initial Estimate（初始估算）：团队的初步估算，表示与其他故事相比，完成该故事所需的工作量。最小的单位是故事点（story point），一般大致相当于一个“一个人一天理想的工作量（man-day）”。</li><li>How to demo（如何做演示）：它大略描述了这个故事应该如何在 sprint 演示上进行示范，本质就是一个简单的测试规范。“先这样做，然后那样做，就应该得到……的结果”。</li></ul><table><thead><tr><th style="text-align:left">ID</th><th style="text-align:right">Name</th><th style="text-align:center">Imp</th><th style="text-align:center">Est</th><th style="text-align:center">How to demo</th><th style="text-align:center">Notes</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:right">搜索房源</td><td style="text-align:center">90</td><td style="text-align:center">20</td><td style="text-align:center">用户输入目的地，选择入住和离开日期、入住人数、等信息，点击搜索，系统智能推荐房源</td><td style="text-align:center">需要使用 GPS 定位系统的 API 来确定用户当前位置以及目的城市的位置；需要实现完善的表单提交功能。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:right">预定房源</td><td style="text-align:center">100</td><td style="text-align:center">25</td><td style="text-align:center">用户在推荐的房源中挑选出心仪的房源并输入信息进行预定</td><td style="text-align:center">需要有优秀的筛选过滤算法。需要实现全面的排序功能。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:right">支付订单</td><td style="text-align:center">80</td><td style="text-align:center">15</td><td style="text-align:center">用户支付已经提交的订单，并获取房源的具体位置信息</td><td style="text-align:center">需要有优秀的状态判断算法，能够实时更新用户订单状态并提供反馈。需要调用第三方的支付API。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:right">评价订单</td><td style="text-align:center">80</td><td style="text-align:center">25</td><td style="text-align:center">用户和房源方对已完成的订单进行双向评价。</td><td style="text-align:center">需要使用完备的评价系统，注意保护双方评价的真实性和隐私性。</td></tr></tbody></table><h3 id="根据任务4，参考使用用例点估算软件成本，给出项目用例点的估算"><a href="#根据任务4，参考使用用例点估算软件成本，给出项目用例点的估算" class="headerlink" title="根据任务4，参考使用用例点估算软件成本，给出项目用例点的估算"></a>根据任务4，参考<a href="https://www.ibm.com/developerworks/cn/rational/edge/09/mar09/collaris_dekker/index.html" target="_blank" rel="noopener">使用用例点估算软件成本</a>，给出项目用例点的估算</h3><table><thead><tr><th style="text-align:left">用例</th><th style="text-align:right">业务</th><th style="text-align:center">计算</th><th style="text-align:center">原因</th><th style="text-align:center">UC比重</th></tr></thead><tbody><tr><td style="text-align:left">查找酒店</td><td style="text-align:right">3</td><td style="text-align:center">3</td><td style="text-align:center"></td><td style="text-align:center">简单</td></tr><tr><td style="text-align:left">结果排序</td><td style="text-align:right">3</td><td style="text-align:center">3</td><td style="text-align:center"></td><td style="text-align:center">简单</td></tr><tr><td style="text-align:left">预定酒店</td><td style="text-align:right">6</td><td style="text-align:center">4</td><td style="text-align:center"></td><td style="text-align:center">平均</td></tr><tr><td style="text-align:left">付款</td><td style="text-align:right">3</td><td style="text-align:center">2</td><td style="text-align:center"></td><td style="text-align:center">简单</td></tr><tr><td style="text-align:left">查看定位</td><td style="text-align:right">3</td><td style="text-align:center">3</td><td style="text-align:center"></td><td style="text-align:center">简单</td></tr><tr><td style="text-align:left">推荐</td><td style="text-align:right">5</td><td style="text-align:center">3</td><td style="text-align:center"></td><td style="text-align:center">平均</td></tr><tr><td style="text-align:left">双方评价</td><td style="text-align:right">4</td><td style="text-align:center">3</td><td style="text-align:center"></td><td style="text-align:center">平均</td></tr></tbody></table><hr><h3 id="附录：一个简单的软件规模用例点数计算"><a href="#附录：一个简单的软件规模用例点数计算" class="headerlink" title="附录：一个简单的软件规模用例点数计算"></a>附录：一个简单的软件规模用例点数计算</h3><p>（1）角色复杂度等级划分及计数</p><p>用例点估算法介绍</p><p><img src="http://s7.sinaimg.cn/middle/93c2f670g79fd9d406226&amp;690" alt></p><p> Total UAW  44</p><p>（2）用例复杂度等级划分及计数</p><p>用例点估算法介绍</p><p><img src="http://s15.sinaimg.cn/middle/93c2f670gc3e814d3e0be&amp;690" alt></p><p> Total UUCW   220</p><p>（3）计算未平衡用例点数</p><p>将UAW与UUCW相加得出未平衡用例点数（ Unadjusted Use Case Point ，UUCP）</p><p>UUCP=UAW+UUCW=44+ 220=264</p><p>（4）使用技术复杂度因子平衡</p><p><img src="http://s2.sinaimg.cn/middle/93c2f670gc3e814effa01&amp;690" alt></p><p>用例点估算法介绍<br> TCF = 0.6 + (.01*Total Factor). 图1中, TCF = 1.07</p><p>（5）使用环境复杂度因子平衡<br>用例点估算法介绍</p><p><img src="http://s2.sinaimg.cn/middle/93c2f670g79fd9bb09671&amp;690" alt></p><p> ECF = 1.4 + (-0.03*Total Factor). ECF = 0.62</p><p>（6）软件规模用例点数计算公式如下</p><p>  软件规模举例：UCP=TCF<em>ECF</em>UUCP =1.07<em> 0.62</em>264=175</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Instance Based Classifiers</title>
      <link href="/2019/04/01/deepLearning/IBC/"/>
      <url>/2019/04/01/deepLearning/IBC/</url>
      
        <content type="html"><![CDATA[<p>keyword：IBC、rote-learner、nearest neighbor</p><a id="more"></a><h2 id="分类方法"><a href="#分类方法" class="headerlink" title="分类方法"></a>分类方法</h2><h3 id="KNN算法（k-Nearest-Neighbor"><a href="#KNN算法（k-Nearest-Neighbor" class="headerlink" title="KNN算法（k-Nearest-Neighbor)"></a>KNN算法（k-Nearest-Neighbor)</h3><ul><li>思想：在数据集中找到k个最近的邻居样本，然后通过这些样本的特点来决定当前样本的属性。</li><li>算法概述：当我们需要预测一个新样本的输出时，KNN 算法将会遍历整个数据集来寻找 k 个最接近的样本，或者说是 k 个和新样本最相似的样本。然后，如果是一个回归问题，算法将输出这些样本结果的均值；如果是一个分类问题，算法将会输出出现次数最多的类别。k 的值是用户自己选定的。</li><li>距离计算方法：样本之间的相似度通过计算例如欧几里得距离（Euclidean distance）或者汉明距离（Hamming distance）得到。<ul><li>使用欧式距离计算距离，可能会导致多特点吻合的两个样本 &amp; 多特点都缺失的两个样本的欧式距离计算结果相同，但实际上两者的关联度是不一样的</li></ul></li><li><p>提出权重的概念：权重因子w与距离d之间的关系（西瓜书中）</p><pre><code>w = 1/d²</code></pre></li><li><p>k-近邻算法使用所有的数据作为训练数据集，而不是把数据集分为训练集和测试集。</p></li><li>k的选择：<ul><li>k很小，效果会对样本中的“噪声点”很敏感</li><li>k很大，邻居样本会包括大量的别类的样本点</li></ul></li></ul><ul><li><p>KNN的特点：</p><ul><li>懒惰的学习分类器</li><li>不需要显式地（explicitly）建模</li><li>能够产生任意形状的决策根页面</li><li>能够动态调整样本的变化，结果与样本是交互的（因为它是基于当前信息的）</li><li>选择一个距离度量的方式是很关键的</li><li>?走神了</li></ul></li><li><p>提升KNN效率：</p><ul><li>在计算距离的时候，避免计算所有的object<ul><li>k-d trees</li><li>Fast approximate similarity search</li><li>LSH(Locality Sensitive Hashing）</li></ul></li><li>构造一个更小的数据集，同时保持当前的性能</li><li>移除一些object</li></ul></li></ul><h2 id="聚类方法（clusting"><a href="#聚类方法（clusting" class="headerlink" title="聚类方法（clusting)"></a>聚类方法（clusting)</h2><h3 id="聚类的定义："><a href="#聚类的定义：" class="headerlink" title="聚类的定义："></a>聚类的定义：</h3><p>将一些样本聚类成不同的组（簇）</p><p>分类方法：</p><ul><li>Hard（Crisp）：一个样本只能属于一个组（簇），不能够同时属于多个组</li><li>Soft（Fuzzy）：一个样本可能同时属于多个组，且属于某个组有对应的概率</li></ul><p>聚类的目标：使得簇内的样本很相似（同簇的样本距离尽可能近，不同的簇内的样本的距离尽可能远）</p><p>SSE：Error of Sum of Squares</p><h3 id="outline："><a href="#outline：" class="headerlink" title="outline："></a>outline：</h3><ul><li>待填</li></ul><h3 id="K-means算法"><a href="#K-means算法" class="headerlink" title="K-means算法:"></a>K-means算法:</h3><ul><li>定义:K-means是一个把相似的数据分组的迭代算法。它计算 k 个聚类的重心然后向这个聚类中添加一个数据点，使其与重心的距离最小。</li></ul><p>算法步骤：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171030/f64630dd549a4da1a7127e850ede2108.png" alt></p><p>K-means 算法的步骤</p><ol><li><p>k-means 初始化</p><p> a) 选择一个 k 的值。在这里，我们令 k 等于 3。</p><p> b) 随机地把数据点放到 3 个聚类中。</p><p> c) 分别计算每个聚类的质心。图中红色、蓝色和绿色星星表示每个聚类的质心。</p></li><li><p>把每个观察结果放入一个聚类中</p><p> 重新把每个最靠近质心的点放入聚类中。在这里，上面的 5 个点被放入了蓝色的质心对应的聚类中。按照相同的步骤将点分配给包含红色和绿色质心的聚类。</p></li><li><p>重新计算质心</p><p> 计算每一个新聚类的质心。旧的质心以灰色显示，新的质心以红色、绿色和蓝色星星显示。</p></li><li><p>迭代直到没有新的变化</p><p> 重复步骤二和步骤三，直到数据点不在聚类与聚类之间交换。一旦两次连续的步骤之间没有点的交换，就退出 k-means 算法。</p></li></ol><h3 id="EM-Algorithm"><a href="#EM-Algorithm" class="headerlink" title="EM Algorithm"></a>EM Algorithm</h3><ul><li>最大期望算法（Expectation-maximization algorithm，又译期望最大化算法），是一种迭代方法。</li><li>典型：求解高斯混合模型，隐马尔科夫模型</li><li>算法概述：在统计计算中，最大期望（EM）算法是在概率模型中寻找参数<strong>最大似然估计</strong>或者<strong>最大后验估计</strong>的算法，其中概率模型依赖于无法观测的<strong>隐变量</strong>。最大期望算法经常用在机器学习和计算机视觉的数据聚类（Data Clustering）领域。</li><li><p>最大期望算法经过两个步骤交替进行计算（wiki上)：</p><ul><li>第一步是计算期望（E），利用对隐藏变量的现有估计值，计算其最大似然估计值；</li><li>第二步是最大化（M），最大化在E步上求得的最大似然值来计算参数的值。M步上找到的参数估计值被用于下一个E步计算中，这个过程不断交替进行。</li></ul></li><li><p>EM求解过程（PPT）：</p><ul><li>初始化参数：先初始化正态分布的参数，包括均值和方差</li><li>计算每一个样本更可能属于某个类</li><li>通过分为某个类的样本数来重新估计该分布的参数（最大似然估计），对每个类进行同样操作，更新分布</li><li>此时不同类的分布的概率更改，重复上述步骤直到2参数不发生变化为止</li></ul></li><li><p>中心极限定理：在适当的条件下，大量相互独立随机变量的均值经适当标准化后依分布收敛于正态分布。</p></li><li>Jensen不等式：<ul><li>如果f（x）是凸函数，x是随机变量，则下面的不等式成立：<ul><li><strong>E(f(x)) &gt;= f(E(x))</strong></li><li>E是数学期望<ul><li>对于离散型随机变量，数学期望是求和</li><li>对于连续型随机变量，数学期望是求定积分</li></ul></li></ul></li></ul></li></ul><h3 id="Multivariate-Gaussian-models（多元正态分布）"><a href="#Multivariate-Gaussian-models（多元正态分布）" class="headerlink" title="Multivariate Gaussian models（多元正态分布）"></a>Multivariate Gaussian models（多元正态分布）</h3><ul><li><p>多变量正态分布亦称为多变量高斯分布。</p></li><li><p>先验</p></li><li>后验</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记（3）</title>
      <link href="/2019/03/31/vueLearning/vueLearning3/"/>
      <url>/2019/03/31/vueLearning/vueLearning3/</url>
      
        <content type="html"><![CDATA[<p>我是一条酸菜鱼。</p><a id="more"></a><h2 id="数组用法"><a href="#数组用法" class="headerlink" title="数组用法"></a>数组用法</h2><h3 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h3><ul><li>变异方法（mutation method）：会改变被这些方法调用的原始数组</li><li>非变异方法：不改变原始数组，返回一个新数组</li></ul><p>会触发视图更新的数组变异方法:</p><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul><p>用法如下:</p><pre><code>example1.items.push({ message: &apos;Baz&apos; }) </code></pre><p>由于JS限制导致items[index] = newValue不会被响应</p><p>修改数组元素：</p><pre><code>Vue.set(vm.items,index,newValue)//修改items[index] = newValue别名有：vm.$set(vm.items,indexOfItem,newValue)</code></pre><p>修改数组长度：</p><pre><code>vm.items.splice(newLength)</code></pre><p>显示数组的某些元素：</p><ul><li>第一种方法是可以重新生成一个子数组包括所有需要的元素</li><li><p>第二种方法使用计算属性来进行数组过滤/排序：</p><pre><code>//html        &lt;li v-for=&quot;n in evenNumbers&quot;&gt;{{ n }}&lt;/li&gt;//jsdata: {      numbers: [ 1, 2, 3, 4, 5 ]    },    computed: {      evenNumbers: function () {    return this.numbers.filter(function (number) {      return number % 2 === 0    })      }    }</code></pre></li><li><p>第三种方法是使用一个method方法(在计算属性不适用的情况下）</p><pre><code>//html&lt;li v-for=&quot;n in even(numbers)&quot;&gt;{{ n }}&lt;/li&gt;//jsdata: {  numbers: [ 1, 2, 3, 4, 5 ]},methods: {  even: function (numbers) {    return numbers.filte(function (number) {      return number % 2 === 0    })  }} </code></pre></li></ul><h2 id="更改对象"><a href="#更改对象" class="headerlink" title="更改对象"></a>更改对象</h2><p>类似的原因和方法修改对象属性，对于以下实例：</p><pre><code>var vm = new Vue({  data: {    userProfile: {      name: &apos;Anika&apos;    }  }})//增加属性Vue.set(vm.userProfile,&apos;age&apos;,27)//别名vm.$set(vm.userProfile, &apos;age&apos;, 27)/增加多个属性vm.userProfile = Object.assign({}, vm.userProfile, {  age: 27,  favoriteColor: &apos;Vue Green&apos;})</code></pre><h2 id="组件使用V-for"><a href="#组件使用V-for" class="headerlink" title="组件使用V-for"></a>组件使用V-for</h2><p>包括一个todolist的demo，感觉可以</p><p><a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">vue官方教程</a></p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><p>v-on监听 + 触发方法</p><p>如绑定click事件， v-on:click 可以跟一个method或者一个表达式</p><pre><code>&lt;button v-on:click = &quot;count += 1&quot;&gt; Add 1 &lt;/button&gt; //这是绑定了表达式&lt;button v-on:click = &quot;greet&quot;&gt; add &lt;/button&gt; //这是绑定了method</code></pre><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>修饰符的顺序很重要，用于限制事件发生</p><ul><li>.stop  </li><li>.prevent</li><li>.capture</li><li>.self</li><li>.once</li><li>.passive</li></ul><h2 id="一些表单输入绑定"><a href="#一些表单输入绑定" class="headerlink" title="一些表单输入绑定"></a>一些表单输入绑定</h2><p>单行文本+绑定</p><pre><code>&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;&lt;p&gt;Message is: {{ message }}&lt;/p&gt;</code></pre><p>多行文本+绑定</p><pre><code>&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p style=&quot;white-space: pre-line;&quot;&gt;{{ message }}&lt;/p&gt;&lt;br&gt;&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;</code></pre><p>单个复选框+布尔值</p><pre><code>&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;&lt;label for=&quot;checkbox&quot;&gt;{{ checked }}&lt;/label&gt;</code></pre><p>多个复选框同一数组</p><pre><code>&lt;div id=&apos;example-3&apos;&gt;  &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;  &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;  &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;  &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;  &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;  &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;  &lt;br&gt;  &lt;span&gt;Checked names: {{ checkedNames }}&lt;/span&gt;&lt;/div&gt;    </code></pre><p>还有 单选框 + 选择框 + 多选框</p><p><a href="https://cn.vuejs.org/v2/guide/forms.html" target="_blank" rel="noopener">参考这里</a></p><h3 id="事件修饰符-1"><a href="#事件修饰符-1" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ul><li><p>.lazy：使得输入框中的值发生改变时才进行数据同步，而不是每一次input触发的时候</p><pre><code>&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot; &gt;</code></pre></li><li><p>.number：自动将用户输入值转换为数值类型</p><pre><code>&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</code></pre></li><li><p>.trim：自动过滤用户输入的首位空白字符</p><pre><code>&lt;input v-model.trim=&quot;msg&quot;&gt;</code></pre></li></ul><h2 id="元素进入-离开过渡"><a href="#元素进入-离开过渡" class="headerlink" title="元素进入/离开过渡"></a>元素进入/离开过渡</h2><ul><li>使用transition封装组件</li></ul><p>（vue）过渡的六个class：</p><ol><li><p>v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</p></li><li><p>v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</p></li><li><p>v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。</p></li><li><p>v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</p></li><li><p>v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</p></li><li><p>v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。</p></li></ol><p>使用demo:</p><pre><code>//HTML:&lt;div id=&quot;demo&quot;&gt;  &lt;button v-on:click=&quot;show = !show&quot;&gt;    Toggle  &lt;/button&gt;  &lt;transition name=&quot;fade&quot;&gt;    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;  &lt;/transition&gt;&lt;/div&gt;-----------------------//JS:new Vue({  el: &apos;#demo&apos;,  data: {    show: true  }})-----------------------//CSS:.fade-enter-active, .fade-leave-active {  transition: opacity .5s;}.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ {  opacity: 0;}</code></pre><ul><li>CSS过度：transition in css</li><li>css动画: animation + action</li></ul><p><a href="https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">过度的一些demo</a></p><hr><h3 id="Some-notes："><a href="#Some-notes：" class="headerlink" title="Some notes："></a>Some notes：</h3><ol><li>今天使用github desktop发现无法拉下来新的仓库，想起之前是因为登陆过期的问题，重新登录就可以了。但是这次log out之后发现根本登不上去，后面google说是之前安装的chorme插件adblock把github也屏蔽掉了。解决方法：<strong>管理员权限打开github desktop</strong></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>酸菜鱼的SLAM之旅（6）</title>
      <link href="/2019/03/30/SLAM/ch9_SLAM%E5%89%8D%E7%AB%AF/"/>
      <url>/2019/03/30/SLAM/ch9_SLAM%E5%89%8D%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="2019年3月30日：-SLAM前端设计实践"><a href="#2019年3月30日：-SLAM前端设计实践" class="headerlink" title="2019年3月30日： SLAM前端设计实践"></a>2019年3月30日： SLAM前端设计实践</h2><a id="more"></a><p>keyword：SLAM前端、实践</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>酸菜鱼的SLAM之旅（5）</title>
      <link href="/2019/03/27/SLAM/ch8_%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A12/"/>
      <url>/2019/03/27/SLAM/ch8_%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A12/</url>
      
        <content type="html"><![CDATA[<h2 id="2019年3月27日：视觉里程计-直接法"><a href="#2019年3月27日：视觉里程计-直接法" class="headerlink" title="2019年3月27日：视觉里程计 - 直接法"></a>2019年3月27日：视觉里程计 - 直接法</h2><a id="more"></a><p>keyword：直接法、光流法、g2o</p><h2 id="直接法"><a href="#直接法" class="headerlink" title="直接法"></a>直接法</h2><h3 id="特征点法的一些问题"><a href="#特征点法的一些问题" class="headerlink" title="特征点法的一些问题:"></a>特征点法的一些问题:</h3><ul><li>关键点的提取和描述子的计算很耗时</li><li>只使用特征点丢弃了大部分可能有用的图像信息</li><li>相机有时候会运动到特征缺失的地方，找不到足够的匹配点来计算相机的运动</li></ul><h3 id="解决问题的思路："><a href="#解决问题的思路：" class="headerlink" title="解决问题的思路："></a>解决问题的思路：</h3><ul><li>保留特征点，但只计算关键点，不计算描述子，使用<strong>光流法（Optical Flow）</strong>来跟踪特征点的运动。这样仍然使用特征点，只是将匹配描述子替换成光流跟踪，估计相机运动使用与特征点法<strong>相同</strong>的算法（对极几何、PnP或ICP）。</li><li>只计算关键点，不计算描述子，使用<strong>直接法（Direct Method）</strong>来计算特征点在下一时刻图像的位置。</li><li>不计算关键点和描述子，直接根据图像灰度的差异，<strong>直接</strong>计算相机运动。</li></ul><p>后两种方法都根据图像的<strong>像素灰度信息</strong>来计算相机运动，称为<strong>直接法</strong>。</p><h3 id="两种方法特性比较"><a href="#两种方法特性比较" class="headerlink" title="两种方法特性比较"></a>两种方法特性比较</h3><ul><li>特征点法：<ul><li>特征点看作固定在三维空间的不动点</li><li>根据投影位置，最小化重投影误差（Reprojection error）来优化相机运动</li><li>需要知道空间点在两个相机中投影的精确像素位置（对特征进行匹配和跟踪）</li><li>计算量大，精确</li><li>只能重构稀疏特征点（稀疏地图）</li></ul></li></ul><hr><ul><li>直接法：<ul><li>通过最小化光度误差（Photometric error）求点与点之间的对应关系，不计算关键点和描述子</li><li>根据像素的亮度信息（场景中的明暗变化）估计相机的运动</li><li>分为稀疏、稠密、半稠密三种，具有恢复稠密或半稠密结构的能力</li><li>避免了特征的计算时间和特征缺失的情况，但不够精确</li></ul></li></ul><h2 id="光流"><a href="#光流" class="headerlink" title="光流"></a>光流</h2><blockquote><p>光流是一种描述像素随着时间，在图像之间运动的方法。计算部分像素运动的称为稀疏光流，计算所有像素的称为稠密光流。</p></blockquote><h3 id="Lucas-Kanade光流"><a href="#Lucas-Kanade光流" class="headerlink" title="Lucas-Kanade光流"></a>Lucas-Kanade光流</h3><p>LK光流是稀疏光流的代表，可以在SLAM中用于跟踪特征点的位置。</p><ul><li><p>光流法中假设同一个空间点的像素灰度值，在各个图像中是固定不变的（灰度不变假设),这是一个很强的假设，现实中很可能不成立。</p></li><li><p>LK光流中，认为图像是时间的函数：I(t)</p><ul><li><p>一个在t时刻，位于(x; y) 处的像素，它的<strong>灰度</strong>可以写成</p><pre><code>I(x，y，t）</code></pre></li><li><p>基于灰度不变假设，因此有:对于t时刻位于(x, y) 处的像素，我们设 t + dt 时刻，它运动到 (x + dx; y + dy) 处。</p><pre><code>I(x + dx,y + dy,t + dt) = I(x,y,t)</code></pre></li></ul></li></ul><h4 id="像素运动的计算"><a href="#像素运动的计算" class="headerlink" title="像素运动的计算"></a>像素运动的计算</h4><p><strong>两个假设：</strong></p><ul><li>同一个空间点的像素灰度值，在各个图像中是固定不变的。</li><li>某一个窗口内的像素具有相同的运动</li></ul><p><img src="https://s2.ax1x.com/2019/03/29/ABujFe.jpg" alt="ABujFe.jpg"></p><p><img src="https://s2.ax1x.com/2019/03/29/ABuvJH.jpg" alt="ABuvJH.jpg"></p><h2 id="实践-LK光流"><a href="#实践-LK光流" class="headerlink" title="实践-LK光流"></a>实践-LK光流</h2><ul><li>待填</li></ul><h2 id="直接法（Direct-Methods）"><a href="#直接法（Direct-Methods）" class="headerlink" title="直接法（Direct Methods）"></a>直接法（Direct Methods）</h2><h3 id="直接法的推导"><a href="#直接法的推导" class="headerlink" title="直接法的推导"></a>直接法的推导</h3><p>考虑空间点P和两个时刻的相机。</p><p><img src="https://s2.ax1x.com/2019/03/29/ABuqeK.jpg" alt="ABuqeK.jpg"></p><p><img src="https://s2.ax1x.com/2019/03/29/ABuOoD.jpg" alt="ABuOoD.jpg"></p><p><img src="https://s2.ax1x.com/2019/03/29/ABuLdO.jpg" alt="ABuLdO.jpg"></p><p><img src="https://s2.ax1x.com/2019/03/29/ABuxWd.jpg" alt="ABuxWd.jpg"></p><h3 id="直接法的讨论"><a href="#直接法的讨论" class="headerlink" title="直接法的讨论"></a>直接法的讨论</h3><p>P是一个已知位置的空间点。在直接法的讨论中，我们假定P的深度已知。此时可以分类：</p><ol><li>P来自于<strong>稀疏关键点</strong>，我们称之为稀疏直接法。通常我们使用数百个至上千个关键点，并且像L-K光流那样，假设它周围像素也是不变的。这种稀疏直接法<strong>不必计算描述子</strong>，并且只使用数百个像素，因此<strong>速度最快</strong>，但<strong>只能</strong>计算稀疏的重构。</li><li>P来自部分像素。我们看到式（8.16）中，如果像素梯度为零，整一项雅可比就为零，不会对计算运动增量有任何贡献。因此，可以考虑只使用带有梯度的像素点，<strong>舍弃像素梯度不明显的地方</strong>。这称之为<strong>半稠密（Semi-Dense）的直接法</strong>，可以重构一个半稠密结构。</li><li>P为所有像素，称为稠密直接法。稠密重构需要计算所有像素（一般几十万至几百万个），因此多数不能在现有的CPU上实时计算，需要GPU的加速。但是，如前面所讨论的，<strong>梯度不明显</strong>的点，在运动估计中<strong>不会有太大贡献</strong>，在重构时也会难以估计位置。</li></ol><h2 id="RGB-D直接法实践"><a href="#RGB-D直接法实践" class="headerlink" title="RGB-D直接法实践"></a>RGB-D直接法实践</h2><ul><li>待填</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>酸菜鱼的SLAM之旅（4）</title>
      <link href="/2019/03/27/SLAM/ch7_%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A11/"/>
      <url>/2019/03/27/SLAM/ch7_%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A11/</url>
      
        <content type="html"><![CDATA[<h2 id="2019年3月27日：视觉里程计-特征点法"><a href="#2019年3月27日：视觉里程计-特征点法" class="headerlink" title="2019年3月27日：视觉里程计 - 特征点法"></a>2019年3月27日：视觉里程计 - 特征点法</h2><a id="more"></a><p>keyword：图像特征点、极几何、PNP问题、ICP问题、三角化</p><h2 id="特征点法"><a href="#特征点法" class="headerlink" title="特征点法"></a>特征点法</h2><p>视觉SLAM主要分为视觉前端和优化后端，前端也称为<strong>视觉里程计（VO）</strong>。它根据相邻图像的信息，估计出粗略的相机运动，给后端提供较好的初始值。</p><ul><li>按照是否需要提取特征区分VO的实现方法:<ul><li>需要提取特征：特征点法的前端（主流方法)<ul><li>运行稳定</li><li>对光照、动态物体不敏感</li></ul></li><li>不提取特征：直接法前端</li></ul></li></ul><h3 id="特征点"><a href="#特征点" class="headerlink" title="特征点"></a>特征点</h3><p>VO的主要问题是如何根据图像来估计相机运动。由于图像本身是一个由<strong>亮度和色度组成的矩阵</strong>，因此<strong>很难</strong>直接从矩阵层面考虑运动估计。因此，常见做法如下:</p><ol><li>从图像中选取比较<strong>有代表性</strong>的点，主要体现在这些点在相机视角发生<strong>少量变化</strong>后<strong>保持不变</strong>，即我们在<strong>连续</strong>的各个图像中都能找到<strong>相同的点。</strong></li><li>在这些点的基础上讨论相机的位姿估计问题和这些点的定位问题。</li><li>在经典SLAM模型中，这些有代表性的点称为<strong>路标</strong>；在视觉SLAM中，路标则是指<strong>图像特征（Features）</strong>。</li></ol><blockquote><p>图像特征是一组与计算任务相关的信息，计算任务取决于具体的应用。   —— 维基百科</p></blockquote><ul><li>特征是图像信息的另一种数字表达形式（如单个图像像素也是一种“特征”)</li><li>在OV中，希望特征点在相机运动之后保持稳定。而灰度值（像素)受外界因素影响严重，在不同图像之间变化很大。因此我们需要对图像提取特征点（图像里一些特别的地方）。</li><li>特征点：从不同的图像间存在更强的辨识度，如角点。一种直观的提取特征的方式就是在不同图像间辨认角点（不满足视觉SLAM的需求），确定它们的对应关系。在这种做法中，角点就是所谓的特征。</li></ul><hr><p>CV中设计了比角点更稳定的局部图像特征，需要拥有以下特性：</p><ol><li>可重复性（Repeatability）：相同的“区域”可以在不同的图像中被找到。</li><li>可区别性（Distinctiveness）：不同的“区域”有不同的表达。</li><li>高效率（Efficiency）：同一图像中，特征点的数量应远小于像素的数量。</li><li>本地性（Locality）：特征仅与一小片图像区域相关。</li></ol><p>e.g. SIFT[30], SURF[31], ORB[32]</p><hr><p>特征点由<strong>关键点（Key-point）</strong>和<strong>描述子（Descriptor）</strong>两部分组成。比方说，当我们<br>谈论 SIFT 特征时，是指“提取 SIFT 关键点，并计算 SIFT 描述子”两件事情。</p><p>具体结构如下:</p><ul><li>特征点：<ul><li>关键点 (Key-point)：该特征点在图像里的<strong>位置</strong>，可能包括朝向、大小等信息</li><li>描述子 (Descriptor)：按照某种人为设计的方式描述该关键点<strong>周围像素的信息</strong>。    <ul><li>原则：外观相似的特征应该有相似的描述子</li><li>两个特征点的描述子在<strong>向量空间上的距离相近</strong>，就可以认为它们是<strong>同样</strong>的特征点</li></ul></li></ul></li></ul><p>一些图像特征：</p><ul><li>尺度不变特征转换(SIFT)<ul><li>Scale-invariant feature transform</li><li>是一种机器视觉的算法用来侦测与描述影像中的局部性特征，它在空间尺度中寻找极值点，并提取出其位置、尺度、旋转不变数。</li><li>它充分考虑了在图像变换过程中出现的光照，尺度，旋转等变化，但随之而来的是<strong>极大</strong>的计算量。</li><li>普通PC的CPU还无法实时地计算SIFT特征，进行定位与建图。所以在SLAM中我们甚少使用这种“奢侈”的图像特征。</li><li>通过GPU加速的SIFT可以满足实时计算要求，但成本提升。</li></ul></li></ul><hr><ul><li>FAST<strong>关键点</strong><ul><li>属于计算特别快的一种特征点</li><li>没有描述子，因此不具有方向性</li></ul></li></ul><hr><ul><li>ORB特征<ul><li>Oriented FAST and Rotated BRIEF</li><li>非常具有代表性的实时图像特征，对于实时性要求很高的SLAM来说是一个很好的选择。</li><li>它改进了FAST 检测子[33] 不具有方向性的问题，并采用速度极快的二进制描述子BRIEF，使整个图像特征提取的环节大大加速。</li><li>保持了特征子具有旋转、尺度不变性的同时，速度方面提升明显，是质量与性能之间较号的折中。</li></ul></li></ul><h3 id="ORB特征"><a href="#ORB特征" class="headerlink" title="ORB特征"></a>ORB特征</h3><p>ORB特征的结构如下:</p><ul><li><p>ORB特征</p><ul><li><p>关键点：Oriented FAST， 是一种改进的Fast角点</p></li><li><p>描述子：BRIEF（Binary Robust Independent Elementary Features）</p></li></ul></li></ul><p>提取ORB 特征分为两个步骤：</p><ol><li>FAST 角点提取：找出图像中的” 角点”。相较于原版的FAST, ORB 中计算了特征点的主方向，为后续的BRIEF 描述子增加了旋转不变特性。</li><li>BRIEF 描述子：对前一步提取出特征点的周围图像区域进行描述。</li></ol><h4 id="FAST特征点："><a href="#FAST特征点：" class="headerlink" title="FAST特征点："></a>FAST特征点：</h4><p>(图中显示的就是检测一个像素点P是否FAST点的过程）<br><img src="https://s2.ax1x.com/2019/03/27/Adde1O.png" alt="Adde1O.png"></p><p>FAST是一种角点：</p><ul><li><strong>思想</strong>：如果一个像素与它的邻域的像素差别过大（过亮/过暗），那么它更可能是角点</li><li><strong>方法</strong>：主要检测局部像素灰度变化明显的地方</li><li><strong>优势</strong>：只需要比较像素亮度的大小，速度快</li><li>测试过程前可以进行<strong>预测试操作</strong>，<strong>快速排除绝大多数不是角点的元素</strong>：<ul><li>对于每个像素，直接检测邻域圆上的第1，5，9，13 个像素的亮度。只有当这四个像素中有三个同时大于Ip + T 或小于Ip - T 时，当前像素才有可能是一个角点，否则应该直接排除。</li></ul></li><li><strong>正常检测过程:</strong><ol><li>在图像中选取像素p，假设它的亮度为Ip。</li><li>设置一个阈值T(比如Ip 的20%)。</li><li>以像素p为中心, 选取半径为3的圆上的16 个像素点。</li><li>假如选取的圆上，有连续的N个点的亮度大于Ip + T 或小于Ip - T，那么像素p可以被认为是特征点(N 通常取12，即为FAST-12。其它常用的N取值为9和11，他们分别被称为FAST-9，FAST-11)。</li><li>循环以上四步，对每一个像素执行相同的操作。</li></ol></li><li><strong>FAST角点的一些原始问题:</strong><ul><li>原始Fast角点经常出现“扎堆”现象，即同一片区域出现多个角点，因此需要使用非极大值抑制（Non-maximal suppression），在一定区域内仅保留响应极大值的角点，避免角点集中的问题。</li><li>FAST特征点数量很大且不确定</li><li>FAST角点不具有方向信息</li><li>固定取半径为3的圆，存在尺度问题：远处看着像是角点的地方，接近后看可能就不是角点了</li></ul></li><li><strong>ORB对原始FAST算法的改进</strong><ul><li>先指定最终要提取的角点数量N，对原始FAST角点分别计算Harris响应值，然后选取前N个具有最大响应值的角点，作为最终的角点集合。</li><li>ORB 添加了尺度和旋转的描述。尺度不变性由构建图像金字塔，并在金字塔的每一层上检测角点来实现。</li></ul></li></ul><p><img src="https://s2.ax1x.com/2019/03/27/AddCnJ.jpg" alt="AddCnJ.jpg"></p><hr><h4 id="BRIEF-描述子"><a href="#BRIEF-描述子" class="headerlink" title="BRIEF 描述子"></a>BRIEF 描述子</h4><blockquote><p>BRIEF 是一种二进制描述子，它的描述向量由许多个 0 和 1 组成，这里的 0 和 1 编码了关键点附近两个像素（比如说 p 和q ）的大小关系：如果 p 比 q 大，则取1，反之就取0。如果我们取了128个这样的p，q，最后就得到128维由 0，1 组成的向量。</p></blockquote><ul><li>BRIEF使用了随机选点比较，速度快</li><li>使用二进制表达，存储方便，适用于实时的图像匹配</li><li>原始的BIRIEF描述子不具有旋转不变性，在图像发生旋转时容易丢失</li><li>ORB在FAST特征点提取阶段计算了关键点的方向，所以可以利用方向信息，计算旋转之后的“steer BRIEF”特征，使得ORB的描述子具有较好的旋转不变性</li></ul><h3 id="特征匹配"><a href="#特征匹配" class="headerlink" title="特征匹配"></a>特征匹配</h3><blockquote><p>宽泛地说，特征匹配解决了SLAM中的数据关联问题（data association），即确定当前看到的路标与之前看到的路标之间的对应关系。</p></blockquote><p>考虑两个时刻的图像的匹配问题：</p><ol><li>从两幅图像中分别提取到特征点的集合</li><li>寻找这两个集合元素的对应关系，即特征匹配<ul><li>暴力匹配（Brute-Force Matcher）：对于集合A中的所有元素，依次与集合B中的所有元素进行遍历测量描述子的距离（表示了两个特征点之间的相似程度），排序，选择最近的一个作为匹配点。<ul><li>浮点类型的描述子：使用欧式距离</li><li>二进制的描述子:使用汉明距离（两个二进制串之间不同位数的个数）</li></ul></li><li>快速近似最优邻算法（FLANN）<ul><li>适合匹配点数量极多的情况（暴匹运算量太大）</li></ul></li></ul></li></ol><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><ul><li>待填</li></ul><h2 id="2D-2D-对极几何"><a href="#2D-2D-对极几何" class="headerlink" title="2D-2D:对极几何"></a>2D-2D:对极几何</h2><h3 id="对极约束"><a href="#对极约束" class="headerlink" title="对极约束"></a>对极约束</h3><p><img src="https://s2.ax1x.com/2019/03/27/AddAtx.png" alt="AddAtx.png"><br><img src="https://s2.ax1x.com/2019/03/27/AddpX4.jpg" alt="AddpX4.jpg"></p><p>代数角度解释几何关系的过程：<br><img src="https://s2.ax1x.com/2019/03/27/AddScF.jpg" alt="AddScF.jpg"><br><img src="https://s2.ax1x.com/2019/03/27/AddPB9.jpg" alt="AddPB9.jpg"><br><img src="https://s2.ax1x.com/2019/03/27/Addi7R.jpg" alt="Addi7R.jpg"><br><img src="https://s2.ax1x.com/2019/03/27/AddkA1.jpg" alt="AddkA1.jpg"></p><h3 id="本质矩阵（E，Essential-Matrix）"><a href="#本质矩阵（E，Essential-Matrix）" class="headerlink" title="本质矩阵（E，Essential Matrix）"></a>本质矩阵（E，Essential Matrix）</h3><p><img src="https://s2.ax1x.com/2019/03/27/AddEh6.jpg" alt="AddEh6.jpg"><br><img src="https://s2.ax1x.com/2019/03/27/AddZ9K.jpg" alt="AddZ9K.jpg"><br>求解方法略</p><h3 id="基础矩阵（F，Fundamental-Matrix）"><a href="#基础矩阵（F，Fundamental-Matrix）" class="headerlink" title="基础矩阵（F，Fundamental Matrix）"></a>基础矩阵（F，Fundamental Matrix）</h3><p>求解方法略</p><h3 id="单应矩阵（H，Homography-Matrix）"><a href="#单应矩阵（H，Homography-Matrix）" class="headerlink" title="单应矩阵（H，Homography Matrix）"></a>单应矩阵（H，Homography Matrix）</h3><p>除了基本矩阵和本质矩阵，我们还有一种称为单应矩阵（Homography）H 的东西，它描述了两个平面之间的映射关系。若场景中的特征点都落在同一平面上（比如墙，地面等），则可以通过单应性来进行运动估计。这种情况在无人机携带的俯视相机，或扫地机携带的顶视相机中比较常见。单应矩阵通常描述处于共同平面上的一些点，在两张图像之间的变换关系。</p><p>单应性在SLAM 中具重要意义。当特征点共面，或者相机发生纯旋转的时候，基础矩阵的自由度下降，这就出现了所谓的退化（degenerate）。现实中的数据总包含一些噪声，这时候如果我们继续使用八点法求解基础矩阵，基础矩阵多余出来的自由度将会主要由噪声决定。为了能够避免退化现象造成的影响，通常我们会同时估计基础矩阵F和单应矩阵H，选择重投影误差比较小的那个作为最终的运动估计矩阵。</p><h3 id="实践：通过Essential矩阵求解相机运动"><a href="#实践：通过Essential矩阵求解相机运动" class="headerlink" title="实践：通过Essential矩阵求解相机运动"></a>实践：通过Essential矩阵求解相机运动</h3><ul><li>待填</li></ul><p>程序输出分解得到R，t的四种可能，并使用三角检测角点的深度是否为正选出正确的解。</p><p>（R，t）即从第一个图到第二个图的坐标变换矩阵的参数。</p><ul><li>E（本质矩阵)本身具有<strong>尺度等价性</strong>，认为分解得到的t，R也有尺度等价性。认为t具有一个<strong>尺度</strong>。通常对t进行<strong>归一化</strong>，使它的长度等于1。</li><li>对t的长度的归一化导致了单目视觉的尺度不确定性（Scale Ambiguity)</li><li>在单目视觉中，对两张图像的t归一化，相当于固定了尺度，但不知道实际长度为多少，以此时的t为单位1。这称为单目SLAM的初始化。</li><li>除了对t进行归一化之外，另一种方法是令初始化时所有的特征点平均深度为1，也可以固定一个尺度。</li><li><strong>单目初始化不能只有纯旋转，必须要有一定程度的平移。</strong>如果没有平移，单目将无法初始化。在实践当中，如果初始化时平移太小，会使得位姿求解与三角化结果不稳定，从而导致失败。相对的，如果把相机左右移动而不是原地旋转，就容易让单目SLAM 初始化。因而有经验的SLAM 研究人员，在单目SLAM 情况下，经常选择让相机进行左右平移以顺利地进行初始化。</li><li>给定的点数多于8对时，计算最小二乘解。当可能存在误匹配的情况时，我们会更倾向于使用随机采样一致性（Random Sample Concensus, RANSAC）来求，而不是最小二乘。<ul><li>RANSAC 是一种通用的做法，适用于很多带错误数据的情况，可以处理带有错误匹配的数据。</li></ul></li></ul><h2 id="三角测量（三角化）"><a href="#三角测量（三角化）" class="headerlink" title="三角测量（三角化）"></a>三角测量（三角化）</h2><blockquote><p>三角测量是指，通过在两处观察同一个点的夹角，确定该点的距离。在SLAM中，我们主要用三角化来估计像素点的距离。</p></blockquote><p>三角测量由<strong>平移</strong>得到，纯旋转无法使用三角测量。</p><h2 id="3D-2D：PnP"><a href="#3D-2D：PnP" class="headerlink" title="3D-2D：PnP"></a>3D-2D：PnP</h2><blockquote><p>PnP（Perspective-n-Point）是求解3D 到2D 点对运动的方法。它描述了当我们知道 n 个3D空间点以及它们的投影位置时，如何估计相机所在的位姿。</p></blockquote><p>求解方法:（跳过了）</p><ul><li>P3P:用三对点估计位姿</li><li>DLT：直接线性变换</li><li>EPnp（Efficient PnP）</li><li>UPnP</li><li>BA、非线性优化：构建最小二乘问题并迭代求解（Bundle Adjustment）</li></ul><h2 id="3D-3D：ICP"><a href="#3D-3D：ICP" class="headerlink" title="3D-3D：ICP"></a>3D-3D：ICP</h2><blockquote><p>这个问题可以用<strong>迭代最近点（Iterative Closest Point, ICP）</strong>求解。读者应该注意到，3D-3D 位姿估计问题中，并没有出现相机模型，也就是说，仅考虑两组3D点之间的变换时，和相机并没有关系。</p></blockquote><p>求解方法：</p><ul><li>SVD方法</li><li>非线性优化方法（类似于BA）</li></ul><h2 id="特征点法的缺点："><a href="#特征点法的缺点：" class="headerlink" title="特征点法的缺点："></a>特征点法的缺点：</h2><ol><li>关键点的提取与描述子的计算非常耗时。实践当中，SIFT目前在CPU 上是无法实时计算的，而ORB也需要近20毫秒的计算。如果整个SLAM 以30毫秒/帧的速度运行，那么一大半时间都花在计算特征点上。</li><li>使用特征点时，忽略了除特征点以外的所有信息。一张图像有几十万个像素，而特征点只有几百个。只使用特征点丢弃了大部分可能有用的图像信息。</li><li>相机有时会运动到特征缺失的地方，往往这些地方没有明显的纹理信息。例如，有时我们会面对一堵白墙，或者一个空荡荡的走廓。这些场景下特征点数量会明显减少，我们可能找不到足够的匹配点来计算相机运动。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>支持向量机（SVM)</title>
      <link href="/2019/03/27/deepLearning/SVM/"/>
      <url>/2019/03/27/deepLearning/SVM/</url>
      
        <content type="html"><![CDATA[<p>keyword：SVM（Support Vector Machines），超平面，逻辑回归</p><a id="more"></a><ul><li>向量机的目的：</li><li>超平面：</li><li><p>下确界（lower bound）：S是一个偏序集合（S，≤），存在一个数值l属于K，这个数值l小于或等于S中的任意一个元素的值，则称这个值为S的一个下确界。</p><ul><li>如果l在S中，则称该元素为infimum，（greatest lower bound，最大下确界）</li><li>同理有上确界（supremum)和最小上确界</li></ul></li><li><p>凸函数和凹函数</p></li><li><p>函数对偶（duality）</p><ul><li>通过对偶函数使得求解原函数的最大值/最小值更简单</li><li>对偶函数与原函数的最大值P和最小值D相对应</li><li>可能存在间隔（即P = D）(Duality gap），称为这两个函数是弱对偶成立（weak duality holds)</li><li>同理可得，P - D = 0的两个对偶函数称为强对偶成立（srong duality holds)</li></ul></li></ul><p>（简写英文小课堂:</p><blockquote><p>. E.g. stands for exempli gratia and means “for example.” I.e. is the abbreviation for id est and means “in other words.” </p></blockquote><ul><li><p>objective function 目标函数f（损失函数)</p><ul><li>找出x，满足 f 最小</li><li>同时满足约束(subject to constraints)<ul><li>简写（s.t.)</li></ul></li></ul></li><li><p>feasible region 可行解</p></li><li>拉格朗日乘数<ul><li>Coutour Lines 等高线<ul><li>等高线上的任意一个点的函数取值都是一样的</li><li>the darker the area is，the smaller the value is </li></ul></li><li>vector field 向量场<ul><li>可视化一个函数每一点上的梯度（gradient）</li><li>箭头指向函数在该点增长得最快的方向</li></ul></li><li>将约束函数和原函数的向量场放在同一个图像中，当两个函数的某些向量是方向平行的，</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记（2）</title>
      <link href="/2019/03/27/vueLearning/vueLearning2/"/>
      <url>/2019/03/27/vueLearning/vueLearning2/</url>
      
        <content type="html"><![CDATA[<p>我是一条酸菜鱼。</p><a id="more"></a><h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><h3 id="创建Vue实例"><a href="#创建Vue实例" class="headerlink" title="创建Vue实例"></a>创建Vue实例</h3><ul><li>待补充</li></ul><h3 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h3><p>Vue实例 - Vue的响应式系统：</p><ul><li>data对象中的属性值改变会带来视图的响应</li><li>只有实例创建时data中已存在的属性才是响应式的</li><li>Vue实例自带的实例属性与方法带有前缀$，与用户自定义的属性区分</li><li><p>阻止修改现有的属性 - Object.freeze()(下例）</p><pre><code>//js    var obj = {  foo: &apos;bar&apos;}Object.freeze(obj)new Vue({  el: &apos;#app&apos;,  data: obj})--------------------------------------------//html&lt;div id=&quot;app&quot;&gt;  &lt;p&gt;{{ foo }}&lt;/p&gt;  &lt;!-- 这里的 `foo` 不会更新！ --&gt;  &lt;button v-on:click=&quot;foo = &apos;baz&apos;&quot;&gt;Change it&lt;/button&gt;&lt;/div&gt;</code></pre></li></ul><h2 id="实例生命周期钩子"><a href="#实例生命周期钩子" class="headerlink" title="实例生命周期钩子"></a>实例生命周期钩子</h2><p>Vue的初始化过程：</p><p>生命周期钩子（在vue初始化过程某些阶段运行钩子对应的函数），函数中调用的 this 指向调用它的vue实例。</p><ul><li>created</li><li>mounted</li><li>updated</li><li>destroyed</li></ul><blockquote><p>不要在选项属性或回调上使用箭头函数，比如 created: () =console.log(this.a) 或 vm.$watch(‘a’, newValue =this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到位置，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。</p></blockquote><p>（假装此处有图）</p><hr><h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><ul><li>尽可能使得模板内的表达式是简单的声明式逻辑</li><li>使用计算属性来表达复杂逻辑</li><li>计算属性放在Vue的 computed 分类中，后接一个getter函数用于得到/更新属性的值</li><li>计算属性的使用方法与普通属性一致，可以在模板中绑定</li><li>计算属性基于它们的响应式依赖进行缓存。大概就是计算属性是一个属性（变量），同时由一个函数f得到它的值。当f中使用到的变量（可能是data中的）发生改变时，计算属性就会响应式地更新。类似的，跳过计算属性，在模板绑定一个方法也可以得到同样的效果。区别在于:<ul><li>计算属性依赖于f中的变量，会缓存当前结果，如果f中的变量没有更新，多次访问计算属性会返回缓存的结果，而不需要重新执行计算函数</li><li>函数每次调用都会重新计算，无缓存</li><li>大概是性能开销和空间开销之间的选择</li></ul></li></ul><h4 id="计算属性实例："><a href="#计算属性实例：" class="headerlink" title="计算属性实例："></a>计算属性实例：</h4><pre><code>使用计算属性/使用方法可以达到同样的效果，区别在于有无缓存&lt;div id=&quot;example&quot;&gt;  &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;  &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;  &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage1() }}&quot;&lt;/p&gt;    &lt;/div&gt;var vm = new Vue({  el: &apos;#example&apos;,  data: {    message: &apos;Hello&apos;  },  computed: {    // 计算属性的 getter    reversedMessage: function () {      // `this` 指向 vm 实例      // message不更新，则reversedMessage这个计算属性返回的会是缓存的值      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)    }  }，  methods: {  reversedMessage1: function () {    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)  }}})</code></pre><h4 id="计算属性另一种实例"><a href="#计算属性另一种实例" class="headerlink" title="计算属性另一种实例"></a>计算属性另一种实例</h4><p>在计算属性中加入setter，此时可以使用赋值</p><pre><code>// ...computed: {  fullName: {    // getter    get: function () {      return this.firstName + &apos; &apos; + this.lastName    },    // setter    set: function (newValue) {      var names = newValue.split(&apos; &apos;)      this.firstName = names[0]      this.lastName = names[names.length - 1]    }  }}// ...</code></pre><p>现在再运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。</p><h3 id="侦听属性"><a href="#侦听属性" class="headerlink" title="侦听属性"></a>侦听属性</h3><ul><li>用于观察和响应Vue实例上的数据变动，watch分类中的数据都随着其他数据变动而变动。（容易滥用?)</li><li>更通用的方法来响应数据的变化。</li><li>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</li></ul><p>使用方法与计算属性类似，在watch:{}中添加</p><p>VUE文档中给出的DEMO有一个有意思的API：yesOrNo</p><p>代码在<a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener">这里</a>（拉到最后）</p><hr><h2 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h2><ul><li>组件是可复用的Vue实例，且带有变量名</li><li>每使用一次组件，就创建一个新的实例</li><li>组件中的data需要是一个函数，因此复用时，每个实例维护一个独立的拷贝</li></ul><p>组件的注册：</p><ul><li><p>局部注册</p><pre><code>var ComponentA = { /* ... */ }</code></pre></li><li><p>局部注册的组件在其子组件中不可用，需要引入</p><pre><code>var ComponentA = { /* ... */ }var ComponentB = {  components: {    &apos;component-a&apos;: ComponentA  },  // ...}</code></pre></li></ul><ul><li><p>全局注册：可以用在其被注册之后的任何（通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。</p><pre><code>//一个全局注册的demo //定义一个名为 button-counter 的新组件Vue.component(&apos;button-counter&apos;, {  data: function () {    return {      count: 0    }  },  template: &apos;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me {{ count }} times.&lt;/button&gt;&apos;})</code></pre></li></ul><ul><li>在模块系统中局部注册</li></ul><pre><code>import ComponentA from &apos;./ComponentA&apos;import ComponentC from &apos;./ComponentC&apos;export default {  components: {    ComponentA,    ComponentC  },  // ...}</code></pre><ul><li>基础组件的自动化全局注册</li></ul><p>使用webpack - 使用require.context全局注册通用的基础组件</p><p><a href="https://cn.vuejs.org/v2/guide/components-registration.html" target="_blank" rel="noopener">Here</a></p><ul><li>动态组件切换时会创建新的实例，因此之前第一次创建时没有被缓存。解决问题的方法是使用<keep-alive>元素</keep-alive></li></ul><pre><code>&lt;!-- 失活的组件将会被缓存！--&gt;&lt;keep-alive&gt;  &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;</code></pre><hr><p><strong>插一段软件测试的笔记</strong></p><p>（以表达我对蔡老师课堂的热爱</p><p>软件缺陷记录的5C原则：</p><ul><li>Correct（准确）：每个组成部分的描述准确，不会引起误解； </li><li>Clear（清晰）：每个组成部分的描述清晰，易于理解； </li><li>Concise（简洁）：只包含必不可少的信息，不包括任何多余的内容； </li><li>Complete（完整）：包含复现该缺陷的完整步骤和其他本质信息； </li><li>Consistent（一致）：按照一致的格式书写全部缺陷报告。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>酸菜鱼的梯度下降法学习</title>
      <link href="/2019/03/25/deepLearning/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
      <url>/2019/03/25/deepLearning/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="2019年3月26日：梯度下降法求解多元线性模型"><a href="#2019年3月26日：梯度下降法求解多元线性模型" class="headerlink" title="2019年3月26日：梯度下降法求解多元线性模型"></a>2019年3月26日：梯度下降法求解多元线性模型</h2><a id="more"></a><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>探讨使用梯度下降法（随机梯度下降法）的多变量线性回归模型，损失函数、梯度下降法的收敛、过拟合问题和学习率等之间的关系。</p><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>请在文件夹“作业2”中下载文件名为<strong>“dataForTraining.txt”</strong>的文件。该文件包含广东省广州市海珠区的房价信息，里面包含<strong>50</strong>个训练样本数据。文件有三列，第一列对应<strong>房的面积</strong>（单位：平方米），第二列对应房子距离双鸭山职业技术学院的<strong>距离</strong>（单位：千米），第三列对应房子的<strong>销售价格</strong>（单位：万元）。</p><p>每一行对应一个训练样本。请使用提供的50个训练样本来训练多变量回归模型以便进行<strong>房价预测</strong>，请用（<strong>随机）梯度下降法</strong>的<strong>多变量线性回归模型</strong>进行建模。为了评估训练效果，请文件夹中下载测试数据集“dataForTesting.txt” （该测试文件里的数据跟训练样本具有相同的格式，即第一列对应房子面积，第二列对应距离，第三列对应房子总价）。</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><h3 id="梯度下降法（GD-Gradient-Descent）"><a href="#梯度下降法（GD-Gradient-Descent）" class="headerlink" title="梯度下降法（GD,Gradient Descent）"></a>梯度下降法（GD,Gradient Descent）</h3><p>梯度下降法（批量梯度下降法）的计算过程就是沿梯度下降的方向求解极小值或沿梯度上升方向求解极大值。由于GD在每次计算梯度时都需要遍历所有样本，因此一定保证每次迭代都能沿着极小值的方向迈进，比较稳定，缺点在于每一次迭代的计算量都一样且比较大。</p><h3 id="随机梯度下降法（SGD-Stochastic-Gradient-Descent"><a href="#随机梯度下降法（SGD-Stochastic-Gradient-Descent" class="headerlink" title="随机梯度下降法（SGD,Stochastic Gradient Descent)"></a>随机梯度下降法（SGD,Stochastic Gradient Descent)</h3><p>随机梯度下降法的计算过程与梯度下降法相仿，区别在于SGD每次计算梯度时，只随机的选取一个样本来计算梯度,这样就大大的减小了计算的复杂度。问题在于由于只选择一个样本进行每次的迭代，因此收敛不稳定，且有可能出现朝着反方向迭代的情况，即某一次迭代中出现了负优化。</p><h3 id="小批量梯度下降法（mini-batch）"><a href="#小批量梯度下降法（mini-batch）" class="headerlink" title="小批量梯度下降法（mini-batch）"></a>小批量梯度下降法（mini-batch）</h3><p>在每次迭代的时候选取一部分样本，与随机梯度下降法相比，增强了方向的稳定性。与批量梯度下降法相比，运算量大大减少，运行速度也更快。</p><h3 id="多变量线性回归"><a href="#多变量线性回归" class="headerlink" title="多变量线性回归"></a>多变量线性回归</h3><p>即具有多个自变量且可用线性方程式表达的模型，形如：</p><blockquote><p>h(x)=theta0+theta1<em>x1+theta2</em>x2+theta3*x3</p></blockquote><p>同时，我们可以认为函数的常数项是相当于系数（该常数）始终乘以一个（X<sub>0</sub> == 1),此时这个函数就可以表达成两个一维矩阵之间的相乘，即</p><blockquote><p>h<sub>θ</sub>(x) = θ<sup>T</sup>X</p></blockquote><p>其中θ为参数矩阵，X为系数矩阵</p><h3 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h3><p>均方误差（英语：mean-square error、MSE）是对于无法观察的参数 θ 的一个估计函数T；其定义为：</p><p>$$MSE(T) = E((T-θ²)) = \frac{1}{2N}\sum_{t=1}^{N}(Yestimate - Y)²$$ </p><h2 id="模型训练流程"><a href="#模型训练流程" class="headerlink" title="模型训练流程"></a>模型训练流程</h2><p> 训练流程如下:</p><ol><li><p>先定义训练的迭代次数、学习率、样本数目等训练过程中使用到的参数，在每一次的训练中，根据选择的梯度下降方法（GD/SGD/mini-batch GD）进行训练。</p></li><li><p>进入迭代过程，每一次的训练中，先将模型更新，计算出预测值，根据预测值可以计算出当前模型预测的损失情况，然后再回退到原来前进前的情况，并记录下损失值，由最后的输出可知随着模型的训练损失值下降。然后重新将模型更新，然后得到同样的预测值，然后使用这个预测值与之前定义好的训练集作比较，计算出当前模型判断的准确率（误差），由最后的输出可知这个准确率在训练的过程中逐步上升。这就完成了一次迭代。</p></li><li><p>重复进行n次训练（在上面的代码中训练次数为400次），得到最终的模型。</p></li><li><p>使用测试集对最终的模型进行测试，最后得到这个模型识别测试集的准确率，通过准确率判断训练出来的模型的质量。</p></li></ol><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>模型训练的核心在于两个函数，一个是代价函数，另一个是梯度下降函数。</p><ul><li><p>代价函数（MSE）：计算模型迭代完成后的均方误差作为误差</p><pre><code>def costFunc(X,Y,theta):    inner = np.power((X*theta.T)-Y,2)      return np.sum(inner)/(len(X))  </code></pre></li><li><p>梯度函数：定义了整个迭代的训练过程，输入参数包括（训练样本，初始误差，学习率（步长），迭代次数，使用参数进行训练并迭代，通过代价函数求出当前的误差并记录，完成给定次数的迭代后输出最终的模型参数，训练样本误差，测试样本误差等信息。</p><pre><code>def gradientDescent(X,Y,theta,lr,iters):    #初始化    temp = np.mat(np.zeros(theta.shape))    trainCost = []    testCost = []    index = []    thetaNums = int(theta.shape[1]) #系数的个数    #迭代过程    for i in range(iters):        error = (X*theta.T-Y) #计算误差        for j in range(thetaNums): #三个系数            #np.multiply：数组和矩阵对应位置相乘，输出与相乘数组/矩阵的大小一致            derivativeInner = np.multiply(error,X[:,j]) #求导数            #得到当前的参数            temp[0,j] = theta[0,j] - (lr*np.sum(derivativeInner)/len(X))        theta = temp #将参数更新        if(i % 100000 == 0):            index.append(i);            trainCost.append(costFunc(X,Y,theta))            testCost.append(costFunc(Xtest,Ytest,theta))    return theta,trainCost,testCost,index</code></pre></li></ul><p>-</p><p>其余如文件读写，作图等功能可见源码注释。</p><hr><h3 id="exercise1："><a href="#exercise1：" class="headerlink" title="exercise1："></a>exercise1：</h3><blockquote><p>你需要用多少个参数来训练该线性回归模型？请使用梯度下降方法训练。训练时，请把迭代次数设成1500000，学习率设成0.00015，参数都设成0.0。在训练的过程中，每迭代100000步，计算训练样本对应的误差，和使用当前的参数得到的测试样本对应的误差。请画图显示迭代到达100000步、200000步、… … 1500000时对应的训练样本的误差和测试样本对应的误差（图可以手画，或者用工具画图）。从画出的图中，你发现什么？请简单分析。</p></blockquote><h3 id="ANS1："><a href="#ANS1：" class="headerlink" title="ANS1："></a>ANS1：</h3><p>我定义的梯度下降模型使用了<strong>5个参数</strong>来训练这个线性模型（实际函数中有7个参数是因为我为了方便处理，将训练集和测试集的X和Y分开输入了），分别是：</p><ul><li>训练集（X，Y）</li><li>测试集（Xtest，Ytest）</li><li>初始系数（theta，都设为0）</li><li>学习率（lr，learning rate）</li><li>迭代次数（iters）</li></ul><p>同时，训练后的模型输出四个参数，分别是：</p><ul><li>最终系数（resultTheta)</li><li>一组训练集误差（trainCost）</li><li>一组测试集误差（testCost）</li><li>下标（按照题目要求用于记录误差所在的迭代次数，每十万次）</li></ul><p>按照给定的要求进行150W次的迭代，每10W次迭代对两种误差都进行一次记录，得到结果如下图（为了图显示的美观，因此将float格式的误差转换成了int的格式，即去掉了小数部分）：</p><p><img src="https://s2.ax1x.com/2019/03/26/AU4ryn.png" alt="AU4ryn.png"></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4wWQ.png" alt="AU4wWQ.png"></p><p>其中，第一张图是使用训练集计算出的误差，第二张图是使用测试集中训练得到的误差。通过数值可以看出，由于一开始设置的初始参数为【0，0，0】，因此得到的误差与其他误差相比十分大，导致整体图的结构看不出正确误差的走向，因此去掉第一个点重新作图，得到图像如下：</p><p><img src="https://s2.ax1x.com/2019/03/26/AU40zj.png" alt="AU40zj.png"><br><img src="https://s2.ax1x.com/2019/03/26/AU4aFS.png" alt="AU4aFS.png"></p><p>可以看到，对于训练集，其误差在每10W次迭代中是下降且趋于收敛，在50W次迭代的时候达到极小值3，而且之后迭代中一直保持这个误差不变，此时<strong>由图看到的训练效果较好</strong>，可以认为梯度下降法达到了<strong>收敛</strong>。同时，参考测试集，误差是在20W次迭代的时候达到一个低值（119），然后继续迭代后误差反而<strong>上升</strong>了，最后稳定在133左右。基于此，我认为以题目给定的数值作为参数输入，最后得到的模型是<strong>过拟合</strong>的，具体体现在<strong>训练集的表现很好，但测试集的表现一般</strong>。</p><hr><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2:"></a>Exercise 2:</h3><blockquote><p>现在，你改变学习率，比如把学习率改成0.0002（此时，你可以保持相同的迭代次数也可以改变迭代次数），然后训练该回归模型。你有什么发现？请简单分析。</p></blockquote><h3 id="ANS2"><a href="#ANS2" class="headerlink" title="ANS2:"></a>ANS2:</h3><p>改变学习率为0.0002后初始化模型并重新训练，得到的参数基本都是无意义的（除了第一个误差参数为10W+外，其余的均为NAN），显示运算的溢出。而修改学习率为更低的参数，效果不太明显，只能勉强看出学习率会影响训练的进度，对结果影响不大。后面经过讨论得知，这是由于训练过程中，参数没有进行正则化的原因，优化后得到更好的效果，可以看出，针对SD而言，当学习率上升时，模型训练速度提高。</p><p>同时，我使用了另外一门课《人工神经网络》中的作业作为例子，使用控制变量法对学习率进行了进一步的测试，得到结果如下图所示：（其中loss是损失函数，即误差；acc值则为得到的结果的准确率，计算方法相当于用模型得到的结果 <strong>Y<sub>cal</sub></strong> 除以正确结果<strong>Y<sub>correct</sub></strong>。</p><p><strong>可以看出，学习率会影响梯度下降法的性能，学习率数值大时可以使得模型迅速往理想模型移动，即误差值的收敛速率较快，系数在比较少的迭代次数中就会到达较好的数值，但同时过大的学习率会导致学习的不稳定，即两种数值都会出现较大幅度的波动，即学习的方式比较激进；即而学习率过小则导致训练需要的时间过长，即两种数值虽然往好的方向变化，但变化得很慢。</strong></p><p><strong>学习率设置为100（过高）</strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4WYF.png" alt="AU4WYF.png"><img src="https://s2.ax1x.com/2019/03/26/AU4goT.png" alt="AU4goT.png"></p><p><strong>学习率设置为e<sup>-10</sup>(过低）</strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU46e0.png" alt="AU46e0.png"><img src="https://s2.ax1x.com/2019/03/26/AU4RFU.png" alt="AU4RFU.png"></p><p><strong>学习率设置为e<sup>-1</sup></strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4DQs.png" alt="AU4DQs.png"><img src="https://s2.ax1x.com/2019/03/26/AU4dJg.png" alt="AU4dJg.png"></p><p><strong>学习率设置为e<sup>-2</sup></strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4cwV.png" alt="AU4cwV.png"><img src="https://s2.ax1x.com/2019/03/26/AU4sLq.png" alt="AU4sLq.png"></p><p>学习率的变化对loss值和accuracy值的影响都主要体现在这两种数值下降的加速度（幅度）以及出现波动的幅度与频率。以上面的训练为例子：</p><ol><li><p>当学习率过高时（100），loss的图像呈现了较大幅度上下震荡的现象，loss值方差较大，但此时loss值的单个数值和均值都较小，最高点在300左右而最低点在50左右；accuracy值则很快到达了接近0.9的高值，但同时出现大幅度震荡，数值的方差较大，且在趋于稳定的过程中仍然时常出现波动到数值为0.4这样的情况。导致这种现象的原因是因为学习率过高导致了学习的不稳定性，有时候会往错误方向快速前进，导致了极端情况的出现。</p></li><li><p>当学习率过低（1e-10）时，loss图像视觉上有较大幅度的震荡，但实际上震荡范围很小（1030-1060，方差小），而数值均值很大，在1145左右；accuracy值则一直没有变化。这种现象出现的原因是学习率过低导致模型的学习效率很低，往正确模型前进的速度过慢，模型识别能力没有明显提升，因此正确率没有提升，错误率一直很高。</p></li><li><p>当学习率适中（1e-1,1e-2,1e-3）时，学习率的上升会加快训练的进程，体现在两种曲线梯度的上升，更快地趋向稳定和理想，但偶尔会出现震荡的情况。根据参数调试，我认为1e-2是比较理想的学习率。同时，上面训练函数的定义部分注释掉了一个动态调整学习率的过程，具体表现为每经过一百次训练，学习率就变为原来的1/10，这有助于后期模型训练得到的结果趋于稳定。</p></li></ol><hr><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3:"></a>Exercise 3:</h3><blockquote><p>现在，我们使用其他方法来获得最优的参数。你是否可以用<strong>随机梯度下降法</strong>获得最优的参数？请使用随机梯度下降法画出迭代次数（每K次，这里的K你自己设定）与训练样本和测试样本对应的误差的图。比较Exercise 1中的实验图，请总结你的发现。</p></blockquote><h3 id="ANS3"><a href="#ANS3" class="headerlink" title="ANS3:"></a>ANS3:</h3><p>使用随机梯度下降法，即每次迭代只使用训练集中的一组数据作为输入参数来进行梯度的计算，得到的图像如下:</p><p><strong>迭代次数为15W，每1W求一次误差</strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU44SJ.png" alt="AU44SJ.png"></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4fW4.png" alt="AU4fW4.png"></p><p><strong>迭代次数为150W，每10W求一次误差</strong></p><p><img src="https://s2.ax1x.com/2019/03/26/AU45l9.png" alt="AU45l9.png"></p><p><img src="https://s2.ax1x.com/2019/03/26/AU4IyR.png" alt="AU4IyR.png"></p><p>由图可得，使用随机梯度下降法（即每次只抽取一个样本），可以很快<strong>接近</strong>最优的参数（<strong>通过数值判定</strong>），但在接近最优解的同时，依然可能出现较大的波动，这是由于其“冒进”的特性决定的；由于只取一个值，因此随机性更大，很可能出现向着反方向前进的情况，此时误差值反而会上升。所以我认为，用随机梯度下降法可以很快获得<strong>接近最优的参数</strong>，但很可能是一个局部最优解，需要通过<strong>大量的迭代</strong>才能确定<strong>确切的全局最优解</strong>。</p><p>通过对比，我们不难看出不同的batchSize（每次迭代的取样个数）实际上对应着三种不同的梯度下降法，分别是：</p><ul><li>SD（梯度下降法，batchSize = 样本个数</li><li>小批量梯度下降法（mini-batch, batchSize in [1,max))</li><li>SGD（随机梯度下降法，batchSize = 1）</li></ul><p>这三种方法按照上面的顺序，对模型训练的影响分别为：训练速度递增，训练稳定性递减（即出现波动的可能性递增）。</p><ol><li><p>当batchSize上升时，计算复杂度上升，运行速度下降，运行稳定性很好；当batchSize的值取的是样本长度时，模型在运算过程中持续向最优解接近，几乎没有出现错误的前进时刻，但优化的速度较慢，而且可能出现停滞；这是因为SD（批量梯度下降法）一定能够沿着最小值的方向迈进，比较稳定，但每一次计算梯度都需要遍历所有的样本，计算量比较大。</p></li><li><p>当batchSize下降时，计算复杂度下降，运行速度上升，运行随机性增长；当batchSize的值取1时，模型在迭代的训练中快速接近理想状态，但在到达较优解时会出现较大幅度的波动；这是因为SGD（随机梯度下降法)虽然具有运算速度较快的优点，但有可能跳出局部最优解，每次迈向的方向不稳定，甚至有可能向反方向迈进。</p></li><li><p>基于这个变化特性，每次计算梯度的时候选取一部分样本来进行计算，在保证方向的基本稳定的同时又减少了计算量，提升了运行速度，也就是采用mini-batch GD是一个更优的选择。</p></li></ol><h2 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h2><h3 id="批归一化（BN-Batch-Normalization）"><a href="#批归一化（BN-Batch-Normalization）" class="headerlink" title="批归一化（BN,Batch Normalization）"></a>批归一化（BN,Batch Normalization）</h3><p><a href="https://www.cnblogs.com/skyfsm/p/8453498.html" target="_blank" rel="noopener">原文在这</a></p><blockquote><p>BN是由Google于2015年提出，这是一个深度神经网络训练的技巧，它不仅可以加快了模型的收敛速度，而且更重要的是在一定程度缓解了深层网络中“梯度弥散”的问题，从而使得训练深层网络模型更加容易和稳定。</p></blockquote><h4 id="what"><a href="#what" class="headerlink" title="what"></a>what</h4><p>BN就是对每一批数据进行归一化（把数据映射到0～1范围之内处理），就是对训练的每一批数据先进行标准的归一化（减均值除方差）得到0-1分布，然后再进行尺度变换和偏移，使得样本效果更好。</p><h4 id="when"><a href="#when" class="headerlink" title="when"></a>when</h4><p>我们可以在网络中任意一层进行归一化处理</p><h4 id="how"><a href="#how" class="headerlink" title="how"></a>how</h4><p><img src="https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180219084749642-1647361064.png" alt></p><p>BN步骤主要分为4步：</p><ol><li>求每一个训练批次数据的均值</li><li>求每一个训练批次数据的方差</li><li>使用求得的均值和方差对该批次的训练数据做归一化，获得0-1分布。其中ε是为了避免除数为0时所使用的微小正数。</li><li>尺度变换和偏移：将xi乘以γ调整数值大小，再加上β增加偏移后得到yi，这里的γ是尺度因子，β是平移因子。这一步是BN的精髓，由于归一化后的xi基本会被限制在正态分布下，使得网络的表达能力下降。为解决该问题，我们引入两个新的参数：γ,β。 γ和β是在训练时网络自己学习得到的。</li></ol><h4 id="why"><a href="#why" class="headerlink" title="why"></a>why</h4><p><img src="https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180219084810095-616879424.png" alt><br><img src="https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180219084820533-1615172856.png" alt></p><ul><li>标准的归一化操作将可能处于梯度很小的区域的数据移动到梯度更大的区域中，可以对抗梯度消失的现象。对每一层数据都进行这样的操作，那么数据总是分布在变化敏感的区域，使得训练效率提升。</li><li>由于归一化操作得到的分布是正态分布，对某些训练样本的特征分布表现不好，即削弱了网络的性能；因此此加入BN中第四步的尺度变换和偏移，利用优化变一下方差大小和均值位置，使得新的分布更切合数据的真实分布，保证模型的非线性表达能力。</li></ul><h4 id="CNN中的BN"><a href="#CNN中的BN" class="headerlink" title="CNN中的BN"></a>CNN中的BN</h4><p>注意前面写的都是对于一般情况，对于卷积神经网络有些许不同。因为卷积神经网络的特征是对应到一整张特征响应图上的，所以做BN时也应以响应图为单位而不是按照各个维度。比如在某一层，batch大小为m，响应图大小为w×h，则做BN的数据量为m×w×h。</p><p>BN在深层神经网络的作用非常明显：若神经网络训练时遇到收敛速度较慢，或者“梯度爆炸”等无法训练的情况发生时都可以尝试用BN来解决。同时，常规使用情况下同样可以加入BN来加速模型训练，甚至提升模型精度</p><h3 id="GN-Group-normalization"><a href="#GN-Group-normalization" class="headerlink" title="(GN,Group normalization)"></a>(GN,Group normalization)</h3><h4 id="BN的一些问题："><a href="#BN的一些问题：" class="headerlink" title="BN的一些问题："></a>BN的一些问题：</h4><ul><li>BN全名是Batch Normalization，见名知意，其是一种归一化方式，而且是以batch的维度做归一化，那么问题就来了，此归一化方式对batch是independent的，过小的batch size会导致其性能下降，一般来说每GPU上batch设为32最合适，但是对于一些其他深度学习任务batch size往往只有1-2，比如目标检测，图像分割，视频分类上，输入的图像数据很大，较大的batchsize显存吃不消。</li><li>另外，Batch Normalization是在batch这个维度上Normalization，但是这个维度并不是固定不变的，比如训练和测试时一般不一样，一般都是训练的时候在训练集上通过滑动平均预先计算好平均-mean，和方差-variance参数，在测试的时候，不在计算这些值，而是直接调用这些预计算好的来用，但是，当训练数据和测试数据分布有差别是时，训练机上预计算好的数据并不能代表测试数据，这就导致在训练，验证，测试这三个阶段存在inconsistency。</li></ul><p>GN将所有channel进行分组，如下图就是将6个channel分成了2个group，1个group有3个channel。</p><p><img src="https://pic4.zhimg.com/80/v2-fad3333df9a87c1c4f1db4b20557da6f_hd.jpg" alt></p><blockquote><p>从左到右一次是BN，LN，IN，GN<br>众所周知，深度网络中的数据维度一般是[N, C, H, W]或者[N, H, W，C]格式，N是batch size，H/W是feature的高/宽，C是feature的channel，压缩H/W至一个维度，其三维的表示如上图，假设单个方格的长度是1，那么其表示的是[6, 6，<em>, </em> ]</p></blockquote><ul><li>BN在batch的维度上norm，归一化维度为[N，H，W]，对batch中对应的channel归一化；</li><li>LN避开了batch维度，归一化的维度为[C，H，W]；</li><li>IN 归一化的维度为[H，W]；</li><li>而GN介于LN和IN之间，其首先将channel分为许多组（group），对每一组做归一化，及先将feature的维度由[N, C, H, W]reshape为[N, G，C//G , H, W]，归一化的维度为[C//G , H, W]</li></ul><p><strong>主要优点</strong></p><ul><li>卷积提取的特征本身分类，并不是完全独立的，某些特征具有相同的分布，因此可以使用group分割样本。</li><li>GN对batch size的鲁棒性更强，GN的归一化方式避开了batch size对模型的影响。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/35005794" target="_blank" rel="noopener">解读原文</a></p><h3 id="归一化、正则化、标准化"><a href="#归一化、正则化、标准化" class="headerlink" title="归一化、正则化、标准化"></a>归一化、正则化、标准化</h3><p>很混乱，关于三者的参考链接</p><p><a href="https://zhuanlan.zhihu.com/p/29957294" target="_blank" rel="noopener">某个学习笔记</a></p><p><a href="https://www.zhihu.com/question/20467170" target="_blank" rel="noopener">某个话题</a></p><ul><li>归一化：一般就是将数据映射到指定的范围，如将数据全部映射到[0,1]区间。对数据的数值范围进行特定缩放，但不改变其数据分布的一种线性特征变换。<ul><li>英文称呼<ul><li>Rescaling</li><li>min-max normalization</li><li>mean normalization</li></ul></li><li>作用：使得特征之间的不同数值不会影响权重</li><li>做法：最简单的是将一组数据分别除以他们的和</li><li>例子：<ul><li>Min-max归一化</li><li><img src="https://www.zhihu.com/equation?tex=x_%7Bnew%7D%3D%5Cfrac%7Bx-x_%7Bmin%7D%7D%7Bx_%7Bmax%7D-x_%7Bmin%7D%7D" alt></li><li>mean normalization</li><li><img src="https://www.zhihu.com/equation?tex=x%5E%7B%27%7D+%3D+%5Cfrac%7Bx-mean%28x%29%7D%7Bmax%28x%29-min%28x%29%7D+" alt></li></ul></li></ul></li></ul><hr><ul><li><p>标准化:对数据的分布的进行转换，使其符合某种分布（比如正态分布）的一种非线性特征变换。</p><ul><li>英文:<ul><li>Normalization</li><li>standardization</li><li>Z-score normalization</li></ul></li><li>标准化后的数据更容易得出最优参数，计算出目标函数的最小值，加速收敛</li><li>做法：将数据减去均值再除以标准差</li><li>例子：<ul><li>Standardization(Z-score normalization) </li><li><img src="https://www.zhihu.com/equation?tex=+x%5E%7B%27%7D+%3D+%5Cfrac%7Bx-mean%28x%29%7D%7B%5Csigma%7D" alt></li></ul></li></ul></li></ul><hr><ul><li>正则化：不太懂<ul><li>英文：regularization</li><li>作用：避免过拟合的产生和减少网络误差。选择经验风险与模型复杂度同时较小的模型。</li><li>做法：<ul><li><img src="https://www.zhihu.com/equation?tex=J%28w%2Cb%29%3D+%5Cfrac%7B1%7D%7Bm%7D+%5Csum_%7Bi%3D1%7D%5E%7Bm%7DL%28f%28x%29%2Cy%29%2B%5Clambda+R%28f%29" alt></li><li>其中，第 1 项是经验风险，第 2 项是正则项， λ≥0 为调整两者之间关系的系数。</li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>酸菜鱼的SLAM之旅（3）</title>
      <link href="/2019/03/25/SLAM/ch6_%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"/>
      <url>/2019/03/25/SLAM/ch6_%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="2019年3月24日：非线性优化"><a href="#2019年3月24日：非线性优化" class="headerlink" title="2019年3月24日：非线性优化"></a>2019年3月24日：非线性优化</h2><a id="more"></a><h2 id="状态估计问题"><a href="#状态估计问题" class="headerlink" title="状态估计问题"></a>状态估计问题</h2><h3 id="最大后验和最大似然"><a href="#最大后验和最大似然" class="headerlink" title="最大后验和最大似然"></a>最大后验和最大似然</h3><p>经典SLAM模型：</p><p><img src="https://s2.ax1x.com/2019/03/27/AdUOzD.jpg" alt="AdUOzD.jpg"></p><p>观测方程：</p><p><img src="https://s2.ax1x.com/2019/03/27/AdULRO.jpg" alt="AdULRO.jpg"></p><p>考虑数据受噪声影响:</p><p><img src="https://s2.ax1x.com/2019/03/27/AdUbi6.jpg" alt="AdUbi6.jpg"></p><p>状态估计问题：</p><ul><li>扩展卡尔曼滤波器（EKF）：关心当前时刻的状态估计X<sub>k</sub>,而对之前的状态则不多考虑。</li><li><p>非线性优化方法:使用所有时刻采集到的数据进行状态估计。（主流方法)</p><ul><li><p><strong>似然：在现在的位姿下，可能产生怎样的观测数据</strong></p></li><li><p><strong>最大似然估计（Maximize Likelihood Estimation,MLE)：在什么样的状态下，最可能产生现在观测到的数据</strong></p></li><li><p><strong>求解最大后验概率 - 最大化似然和先验的乘积</strong></p></li><li><strong>arg maxP(z|x) —— 最大似然估计</strong></li></ul></li></ul><p><img src="https://s2.ax1x.com/2019/03/27/AdUvsH.jpg" alt="AdUvsH.jpg"></p><h3 id="最小二乘"><a href="#最小二乘" class="headerlink" title="最小二乘"></a>最小二乘</h3><p><img src="https://s2.ax1x.com/2019/03/27/AdUjQe.png" alt="AdUjQe.png"></p><ul><li>最小化负对数：对等式两边同时取负对数 -ln(f(x))</li></ul><p><img src="https://s2.ax1x.com/2019/03/27/AdaSeA.png" alt="AdaSeA.png"></p><p><img src="https://s2.ax1x.com/2019/03/27/Ada9ot.jpg" alt="Ada9ot.jpg"></p><p><img src="https://s2.ax1x.com/2019/03/27/AdUxLd.jpg" alt="AdUxLd.jpg"></p><ul><li><p>总体意义下的最小二乘问题（Least Square Problem）</p><ul><li>最优解等价于状态的最大似然估计。</li><li>但由于噪声存在使得估计的轨迹和地图代入SLAM运动、观测方程时不会完美成立 —— 需要把状态的估计值进行微调，使得整体误差下降（有限度，会到达一个极小值）。</li></ul></li><li><p>SLAM中的最小二乘问题——(6.12)式为目标函数</p><ul><li>总体状态变量维数高，每个误差项简单（仅与一两个状态变量有关)</li><li>每个误差项是一个小规模的约束，称每个误差项对应的优化变量为参数块（Parameter Block)</li><li>线性近似、雅可比矩阵</li><li>稀疏性</li><li>李代数-无约束</li><li>平方形式（二范数）度量误差 - 欧氏空间中距离的平方</li></ul></li></ul><h2 id="非线性最小二乘"><a href="#非线性最小二乘" class="headerlink" title="非线性最小二乘"></a>非线性最小二乘</h2><p>不方便直接求解的最小二乘问题使用<strong>迭代</strong>优化：</p><p><img src="https://s2.ax1x.com/2019/03/27/AdapdI.jpg" alt="AdapdI.jpg"></p><p>问题： 确定增量<strong>ΔX<sub>k</sub></strong></p><h3 id="一阶和二阶梯度法"><a href="#一阶和二阶梯度法" class="headerlink" title="一阶和二阶梯度法"></a>一阶和二阶梯度法</h3><ol><li>最速下降法（一阶）、牛顿法（二阶）<ul><li>将目标函数在x附近进行泰勒展开</li><li>参数：雅可比矩阵J、海塞（Hessian）矩阵H、步长 λ</li><li>选择保留泰勒展开的一阶/二阶项 —— 对应一阶梯度法/二阶梯度法</li><li>问题：过于贪心，容易走出锯齿路线，增加迭代次数</li></ul></li></ol><h3 id="Gauss-Newtown（高斯-牛顿）"><a href="#Gauss-Newtown（高斯-牛顿）" class="headerlink" title="Gauss-Newtown（高斯-牛顿）"></a>Gauss-Newtown（高斯-牛顿）</h3><p>思想：将f（x)进行一阶的泰勒展开（不是目标函数f(x)²）</p><p><img src="https://s2.ax1x.com/2019/03/27/AdaFW8.png" alt="AdaFW8.png"><br><img src="https://s2.ax1x.com/2019/03/27/AdaPFP.png" alt="AdaPFP.png"><br><img src="https://s2.ax1x.com/2019/03/27/AdaEQg.jpg" alt="AdaEQg.jpg"></p><p>问题:</p><ul><li>原则上要求所用的近似H矩阵可逆且正定，但实际上（J<sup>T</sup>J）只有半正定性。</li><li>可能出现J<sup>T</sup>J为奇异矩阵或者病态（ill-condition)的情况，此时增量稳定性较差，导致算法不收敛。</li><li>求出来的步长Δx太大，会导致采用的局部近似不够准确，无法保证迭代的结果是收敛。</li></ul><h3 id="Levenberg-Marquadt"><a href="#Levenberg-Marquadt" class="headerlink" title="Levenberg-Marquadt"></a>Levenberg-Marquadt</h3><p>信赖区域方法（Trust Region Method）：在信赖区域里边，我们认为近似是有效的；出了这个区域，近似可能会出问题。</p><p>确认信赖区域的范围：根据近似模型和实际函数之间的差异来确定，差异小→范围尽可能大；差异大→近似范围缩小</p><p><img src="https://s2.ax1x.com/2019/03/27/AdaASS.jpg" alt="AdaASS.jpg"></p><p><strong>改良后的非线性优化框架:</strong></p><p><img src="https://s2.ax1x.com/2019/03/27/AdaiJf.jpg" alt="AdaiJf.jpg"></p><h2 id="实践（挖坑，且不打算填）"><a href="#实践（挖坑，且不打算填）" class="headerlink" title="实践（挖坑，且不打算填）"></a>实践（挖坑，且不打算填）</h2><h3 id="Ceres"><a href="#Ceres" class="headerlink" title="Ceres"></a>Ceres</h3><p>Ceres库面向通用的最小二乘问题的求解：</p><ul><li>用户定义优化问题，设置选项，输入至Ceres求解</li></ul><hr><h3 id="g2o（General-Graphic-Optimization"><a href="#g2o（General-Graphic-Optimization" class="headerlink" title="g2o（General Graphic Optimization)"></a>g2o（General Graphic Optimization)</h3><p>基于图优化的库。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>酸菜鱼的SLAM之旅（2）</title>
      <link href="/2019/03/24/SLAM/ch5_%E7%9B%B8%E6%9C%BA%E4%B8%8E%E5%9B%BE%E5%83%8F/"/>
      <url>/2019/03/24/SLAM/ch5_%E7%9B%B8%E6%9C%BA%E4%B8%8E%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="2019年3月24日：相机与图像"><a href="#2019年3月24日：相机与图像" class="headerlink" title="2019年3月24日：相机与图像"></a>2019年3月24日：相机与图像</h2><a id="more"></a><h2 id="相机模型"><a href="#相机模型" class="headerlink" title="相机模型"></a>相机模型</h2><p>keyword：针孔模型、畸变、内参数</p><hr><p>插一点小知识：</p><ul><li><p>Markdown语法上下标：</p><p>  H<sub>2</sub>O &amp; a<sup>T</sup></p><pre><code>H&lt;sub&gt;2&lt;/sub&gt;O  //下标a&lt;sup&gt;T&lt;/sup&gt;   //上标</code></pre></li><li><p><a href="https://www.jianshu.com/p/a0aa94ef8ab2" target="_blank" rel="noopener">MarkDown输入数学公式</a></p></li><li><p>让MarkdownPad显示数学公式</p></li></ul><p>在MarkdownPad中，点击”Tools &gt; Options &gt; Advanced &gt; HTML Head Editor”，这个是自定义头文件。添加下列内容：  </p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&apos;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&apos;&gt;&lt;/script&gt;</code></pre><p>此时需要【F6】进入浏览器模式才能够显示</p><p>离线的话就先把MathJax clone到本地，然后使用绝对路径引用，应该就可以了</p><p>绝对路径加到头文件中，demo如下:</p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;file:\\\D:\software\MathJax\MathJax.js?config=TeX-MML-AM_CHTML-full&quot;&gt;&lt;/script&gt;</code></pre><hr><h3 id="针孔相机模型"><a href="#针孔相机模型" class="headerlink" title="针孔相机模型"></a>针孔相机模型</h3><p><img src="https://s2.ax1x.com/2019/03/27/AdUu8O.jpg" alt="AdUu8O.jpg"></p><p>相机坐标系为O-x-y-z，习惯上z轴指向相机前方，x向右，y向下。（也就是这幅图相当于成像平面为相机的显示屏，光心O为相机的镜头。）</p><p>P为现实中的空间点，坐标为【X，Y，Z】<sup>T</sup>，（在相机坐标系中）</p><p>而P’为它在成像平面的坐标，【X’,Y’,Z’】<sup>T</sup>（在成像平面中，即图上的O-x’-y’-z’）</p><p>图上f为焦距，Z为P点在现实中的Z轴的位置</p><p>根据三角形相似关系得到两个坐标之间的关系（负号表示成像倒立）</p><blockquote><p>$$\frac{Z}{f} = - \frac{X}{X’} = -\frac{Y}{Y’}$$</p></blockquote><p>简化模型可以把成像平面对称到相机前方，也就是</p><p><img src="https://s2.ax1x.com/2019/03/27/AdUe56.jpg" alt="AdUe56.jpg"></p><p>此时式子变为</p><blockquote><p>$$\frac{Z}{f} = \frac{X}{X’} = -\frac{Y}{Y’}$$</p></blockquote><p>设在物理成像平面上固定着一个像素平面： o-u-v，像素平面上可以得到P’的像素坐标：[u,v]<sup>T</sup></p><p>像素坐标系通常的定义方式是：原点o′位于图像的左上角，u轴向右与x轴平行，v轴向下与y轴平行。像素坐标系与成像平面之间，相差了一个<strong>缩放</strong>和一个<strong>原点的平移</strong>。</p><p><img src="https://s2.ax1x.com/2019/03/27/AdUZUx.png" alt="AdUZUx.png"></p><p>（5.6）中的P - 相机坐标 - 相机的世界坐标（Pw） - 可以得到相机的位姿（由旋转矩阵<strong>R</strong> 和 平移向量 <strong>t</strong>来描述）</p><p>因此 <strong>外参</strong> 为相机的位姿 <strong>R</strong> ， <strong>t</strong></p><p><img src="https://s2.ax1x.com/2019/03/27/AdUAbR.jpg" alt="AdUAbR.jpg"><br>归一化处理：</p><p>归一化平面：</p><p>归一化坐标：</p><hr><h3 id="畸变"><a href="#畸变" class="headerlink" title="畸变"></a>畸变</h3><p>获得更好的成像效果 - 相机前方加透镜 - 对成像过程光线传播造成影响：</p><ol><li>透镜自身的形状对光线传播的影响</li><li>是在机械组装过程中，透镜和成像平面不可能完全平行，这也会使得光线穿过透镜投影到成像面时的位置发生变化。</li></ol><ul><li>径向畸变：由透镜形状引起的畸变<ul><li>桶形畸变：由于图像放大率随着离光轴的距离增加而减小</li><li>枕型畸变：由于图像放大率随着离光轴的距离增加而增加</li></ul></li></ul><p><img src="https://s2.ax1x.com/2019/03/27/AdUVV1.jpg" alt="AdUVV1.jpg"></p><p>径向畸变的纠正模型:用多项式函数来描述前后的坐标变化</p><p><img src="https://s2.ax1x.com/2019/03/27/AdUnPK.jpg" alt="AdUnPK.jpg"></p><ul><li>切向畸变：由于透镜和成像面没有严格平行</li></ul><p><img src="https://s2.ax1x.com/2019/03/27/AdUK2D.png" alt="AdUK2D.png"></p><p><img src="https://s2.ax1x.com/2019/03/27/AdUMxe.jpg" alt="AdUMxe.jpg"></p><p>可以合并进行同时纠正（也就是把两个纠正式相加），最理论的情况下用到了5个畸变项（径向<em>3 + 切向 </em> 2），实际情况下可以灵活选择其中几项。所有的纠正都在归一化平面上完成。</p><p><img src="https://s2.ax1x.com/2019/03/27/AdU1rd.jpg" alt="AdU1rd.jpg"><br><img src="https://s2.ax1x.com/2019/03/27/AdUlKH.jpg" alt="AdUlKH.jpg"></p><p>!仅通过一个像素无法确定空间点的具体位置，因为从相机光心到归一化平面连线上的所有点都可以投影到该像素上。只有P的深度确定时才能够知道确切的空间位置。</p><ul><li>能否知道确切的空间位置<ul><li>针孔相机模型    （X）</li><li>双目相机模型    （√）</li><li>RGB-D相机模型  （√）</li></ul></li></ul><h3 id="双目相机模型"><a href="#双目相机模型" class="headerlink" title="双目相机模型"></a>双目相机模型</h3><p>原理：根据左右眼看到的景物差异（<strong>视差</strong>）来判断物体与我们的距离</p><p><img src="https://s2.ax1x.com/2019/03/27/AdUGVI.png" alt="AdUGVI.png"></p><ul><li>基线：两个相机的光圈中心的距离（Baseline，用符号b表示)</li><li>视差：左右图横坐标之差（U<sub>L</sub> - U<sub>R</sub>)</li><li>视差越大，距离越近</li><li>双目深度理论上的最大值（当视差为1个像素） - f<sub>b</sub></li><li>基线越长，双目最大能测到的距离越远</li><li>反光可能会扰乱测距</li></ul><h3 id="RGB-D相机模型"><a href="#RGB-D相机模型" class="headerlink" title="RGB-D相机模型"></a>RGB-D相机模型</h3><p>原理*2：向探测目标发射红外光，根据返回的图案/飞行时间计算距离</p><ol><li>结构光原理：通过红外结构光返回的图案来测量像素距离</li><li>飞行时间法（Time-of-flight，ToF）原理：向目标发送脉冲光，根据发送到返回之间的光束飞行时间测量像素距离<br><img src="https://s2.ax1x.com/2019/03/27/AdUYIP.jpg" alt="AdUYIP.jpg"></li></ol><p>问题:</p><ol><li>使用范围有限制，会收到日光或者其他传感器发射的红外光干扰，因此不能在室外使用</li><li>同时使用多个RGB-D相机会互相干扰</li><li>投射材质的物体无法接受反射光，因此无法测量这些点的位置（玻璃）</li></ol><h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><p>###灰度图</p><p>每个像素位置（x,y）对应一个灰度值I，因此一张宽为w高为h的图像可以看成一个w*h的矩阵。常见的灰度图中，我们用0-255之间的整数（即一个 unsigned char，一个字节）来表达图像的灰度大小。即我们可以用一个二维数组来表示。</p><p>在图像中，数组的行数（二维数组的第一个下标）表示图像的高度，而列数（第二个下标）表示图像的宽度。</p><p><img src="https://s2.ax1x.com/2019/03/27/AdUJat.jpg" alt="AdUJat.jpg"></p><p>！！！以上图为例，这里要注意，图像的宽度/列数，对应的X轴；图像的行数/高度，对应Y轴。也就是说，取坐标应该是：</p><pre><code>unsigned char pixel = image[y][x] //位于（x,y)处的像素，对应I（x,y)的读数</code></pre><ul><li>灰度像素用八位整数记录（0-255）  unsigned char</li><li>RGB-D相机深度图记录距离，用十六位整数 unsigned short</li><li>彩色图像引入通道（channel）的概念，记录R,G,B三个数值，每一个数值称为一个通道。每个通道使用9位整数表示，也就是一个像素占据24位空间。</li><li>在OpenCV的彩色图像中，通道的默认顺序是B，G，R。前8位代表蓝色，中间8位代表绿色，后8位代表红色。</li><li>如果还需要表达图像的透明度，可以使用R,G,B,A四个通道表示</li></ul><hr><h2 id="OpenCV使用实践（占坑）"><a href="#OpenCV使用实践（占坑）" class="headerlink" title="OpenCV使用实践（占坑）"></a>OpenCV使用实践（占坑）</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>酸菜鱼的SLAM之旅（1）</title>
      <link href="/2019/03/23/SLAM/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/03/23/SLAM/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>key: Ubuntu的配置和Makefile实践</p><a id="more"></a><hr><h2 id="2019年3月23日：Ubuntu环境配置"><a href="#2019年3月23日：Ubuntu环境配置" class="headerlink" title="2019年3月23日：Ubuntu环境配置"></a>2019年3月23日：Ubuntu环境配置</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>一开始我以为之前用ubuntu上过程设跑过C，配置过环境，应该没啥问题的，所以看了看十四讲的实践部分，感觉不就调两个库的事情吗，就直接跳过了。今天想起来，准备用自己的电脑run一遍，一用起来才发现关于ubuntu的知识都忘光了，环境居然只有gcc，cpp都编译不了，很难受。所以写点东西记录一下，下次要是又忘光了还可以看。</p></blockquote><hr><h3 id="Ubuntu基本命令"><a href="#Ubuntu基本命令" class="headerlink" title="Ubuntu基本命令"></a>Ubuntu基本命令</h3><p>ubuntu的系统命令基本以<code>sudo apt-get</code>前缀，下面以我痛苦的安装过程记录一些可能有用的命令：</p><p>安装命令</p><pre><code>sudo apt-get install g++  //安装软件g++</code></pre><p>移除命令</p><pre><code>sudo apt-get remove g++  //卸载</code></pre><p>检查更新</p><pre><code>sudo apt-get update //好像是检查装了的软件和当前发行版本，拉下来一个软件列表</code></pre><p>升级</p><pre><code>sudo apt-get upgrade //升级软件</code></pre><p>切换到root用户（虽然我不知道为啥root还是有些文件夹会被拒绝访问？）</p><pre><code>sudo su -  //需要输密码 占个坑，以后看看关于root、777的内容</code></pre><p>查看当前系统版本</p><pre><code>lsb_release -a</code></pre><hr><p>然后我insatll g++的时候，提示一堆什么破依赖关系不对，而且还不让我破坏。我真的吃柠檬了。然后上网疯狂搜，解决办法是【换源 + aptitude】</p><p>换源方法参考的是<a href="https://blog.csdn.net/fei20140908/article/details/78952341" target="_blank" rel="noopener">这个大佬</a>，反正大概就是系统设置 - 软件与更新 - 服务器选其他 - 查找最快源 - 找到之后设置成这个源，其实我也不知道有没有用，感觉迟早有用。</p><p>然后aptitude是一个提供解决依赖关系的程序</p><p>先安装一下</p><pre><code>sudo apt-get install aptitude</code></pre><p>然后用它来解决你的安装问题</p><pre><code>sudo aptitude install g++ //我是装g++啦</code></pre><p>然后会刷刷刷一大堆信息，最后给出一个提示办法，选择是[y/n/q]：</p><ul><li>选择y就是执行当前方案（它给我提供的第一个方案是啥也不做，然后告诉我解决问题啦，我：？？？）</li><li>n是拒绝当前方案，然后会提供下一个方案，反正我解决上面提到的sb依赖问题的方法是【降低装了的软件的版本】的那个方案，最后搞定了</li><li>q原来是quit的意思，我还以为是啥question的派生词，具体解释一下，还是太菜了…</li></ul><p>后面跟着流程走就搞定了</p><p>装完之后<code>-v</code> 看一下是不是装成功了 </p><hr><h3 id="编译-amp-MakeFile（占坑）"><a href="#编译-amp-MakeFile（占坑）" class="headerlink" title="编译&amp;MakeFile（占坑）"></a>编译&amp;MakeFile（占坑）</h3><ul><li>以后更新点关于makefile的</li><li>被自己菜哭了</li></ul><p>我凉了..为什么cd到out文件的目录下，执行命令还是</p><pre><code>//已经cd到a.out的目录下了a.out //a.out：未找到命令./a.out  //fuck you g++</code></pre><hr><h4 id="编译运行过程"><a href="#编译运行过程" class="headerlink" title="编译运行过程"></a>编译运行过程</h4><p>先创建一个生成makeFile文件的文件(CMakeLists.txt)，内容如下（选择使用，非一定全部）:</p><pre><code># makeFile名字叫CMakeLists.txt  大小写敏感 名字后缀敏感# 声明要求的cmake 最低版本cmake_minimum_required( VERSION 2.8 )# 声明一个cmake 工程project( HelloSLAM )# 添加一个可执行程序# 语法：add_executable( 程序名源代码文件）add_executable( a a.cpp ) #a为生成的程序名，a.cpp为源文件# 添加一个库#hello为库名，iamlib是源文件，里面没有main函数，只有一些定义好的函数或者变量add_library(hello iamlib.cpp)  #静态库add_libray(hello_shared SHARED iamlib.cpp) #动态库#将生成的库hello链接到可执行程序a中，此时a就可以调用hello中的函数了target_link_libraries(a hello) </code></pre><p>这里插一段书里面对动态库和静态库的解释：</p><blockquote><p>在Linux 中，库文件分成静态库和共享库两种。静态库以.a 作为后缀名，共享库以.so结尾。所有库都是一些函数打包后的集合，差别在于静态库每次被调用都会生成一个副本，而共享库则只有一个副本，更省空间。</p></blockquote><p>同时，为了使用这些库，还需要自己定义一个头文件，头文件里就是库里面的函数名，demo如下：</p><pre><code>#ifndef LIBHELLOSLAM_H_#define LIBHELLOSLAM_H_    void printHello();#endif</code></pre><p>之后在cpp里面引入这个头文件好像就可以调用里面的函数了。</p><p>然后调用cmake分析当前工程，生成makefile</p><pre><code>cmake .  //先cd到代码的当前目录</code></pre><p>然后使用生成的makeFile生成可执行文件</p><pre><code>make  //就是这个指令</code></pre><p>然后就生成了一个可执行文件，（占坑： a 和 a.out 的区别）</p><pre><code>./a  //运行</code></pre><p>十四讲还给出一个大佬做法，用于快捷删除编译的中间文件。大概就是新建一个目录然后对目录上一层进行cmake，这样子中间文件就都生成在当前目录了，最后make完再删掉就是了。</p><pre><code>mkdir buildcd buildcmake ..make</code></pre><hr><h3 id="Kdevelop使用"><a href="#Kdevelop使用" class="headerlink" title="Kdevelop使用"></a>Kdevelop使用</h3><p>安装东西使用aptitude感觉会比较靠谱</p><pre><code>sudo aptitude install kdevelop //选择第二个降版本的解决方案</code></pre><p>然后用法跟普通IDE差不多，不过添加工程文件好像是自己先写好CmakeList.txt之后，从导入工程-&gt;导入这个CmakeList.txt就可以了，以这个文件夹为根目录创建cpp和h文件，然后好像会自动进里一个build文件夹，然后【F8】就可以把项目run起来了（前提是cpp和h，CMakeLists都是正确的。</p><p>如果想使用debug模式（可以单步执行），需要在CmakeLists里面加入这一句：</p><pre><code>set( CMAKE_BUILD_TYPE &quot;Debug&quot;) //我是加到了工程名下面</code></pre><p>然后想run起来程序，还需要配置，打开【运行】 - 【配置启动器】 - 【Add New-应用程序（左上角加号)】 - 【工程目标选到可执行文件下】 - 【配置相干参数】（我好像是按了F8之后就会提示要这样子做）</p><p>（！！！！我佛啦，原来在这里，浪费了20mins）<br><img src="https://s2.ax1x.com/2019/04/02/Acuyoq.md.jpg" alt="Acuyoq.md.jpg"></p><p>PS:在配置启动器的那一项中可以输入预先设置的参数以及选择路径，选择路径就是为了使得程序能够找到你需要处理的文件，如TXT或者img。</p><p>搞定上面那一步之后，主界面的【Execute】就是直接跑，【Debug】就是设置断点模式单步进入，断点需要自己设置在代码每一行的左侧，然后就可以使用【Debug】。在Debug模式中，【F10】是单步运行，【F11】是单步跟进，【F12】是单步跳出，左边还能看到属性的值（看变量值这个真的舒服)。</p><p>(PS:然后我查了查，发现所有的IDE都可以，DEV是调试过程中选中那个变量然后右边【查看变量】，然后左边的窗口就会显示这个变量当前的值了，虽然看多维数组的时候有点麻烦，但好歹能看?)</p><p>(PSS:在今天以前，我一直是用cout来查看变量的值的，dbq，我真的太菜了）</p><p><a href="https://imgchr.com/i/AYk1xI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/24/AYk1xI.jpg" alt="AYk1xI.jpg"></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记（1）</title>
      <link href="/2019/03/21/vueLearning/vueLearning1/"/>
      <url>/2019/03/21/vueLearning/vueLearning1/</url>
      
        <content type="html"><![CDATA[<p>我是一条酸菜鱼。</p><a id="more"></a><p><a href="http://http://www.runoob.com/w3cnote/vue2-start-coding.html" target="_blank" rel="noopener">环境配置教程</a></p><p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">官方教程</a></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><img src="http://www.runoob.com/wp-content/uploads/2016/10/1476690217-1155-854231-1d2947692fba4957.png" alt></p><h3 id="配置淘宝镜像"><a href="#配置淘宝镜像" class="headerlink" title="配置淘宝镜像"></a>配置淘宝镜像</h3><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><h3 id="安装相关环境-node-js、cnpm、vue-cli"><a href="#安装相关环境-node-js、cnpm、vue-cli" class="headerlink" title="安装相关环境: node.js、cnpm、vue-cli"></a>安装相关环境: node.js、cnpm、vue-cli</h3><pre><code>npm -g install npm  //更新npm到最新版本cnpm install wekpack -g  npm install vue-cli -g </code></pre><h3 id="新建vue项目流程"><a href="#新建vue项目流程" class="headerlink" title="新建vue项目流程"></a>新建vue项目流程</h3><pre><code>vue init wekpack-simple &lt;name&gt;  //新建vue项目npm install //安装项目依赖cnpm install vue-router vue-resource --save //安装路由模块和网络请求模块npm run dev</code></pre><p>（webstorm好像有点牛逼?验证sysu邮箱可以免费用）</p><p>（感觉sublime + livereload好像也差不多）</p><hr><h3 id="Vue格式"><a href="#Vue格式" class="headerlink" title="Vue格式"></a>Vue格式</h3><pre><code>&lt;template&gt; -&gt; html&lt;script&gt; -&gt; js&lt;style&gt; -&gt; css</code></pre><hr><h2 id="简单语法"><a href="#简单语法" class="headerlink" title="简单语法"></a>简单语法</h2><p><a href="https://cn.vuejs.org/v2/guide/index.html" target="_blank" rel="noopener">官网教程</a></p><ul><li>基于HTML语法</li><li>声明式地绑定DOM和底层Vue实例</li><li>模板编译成虚拟DOM渲染函数（render fun）</li></ul><p>###vue文件</p><ul><li><p>html:</p><pre><code>&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;   //div的id属性，用于css编辑，与web一致&lt;div id=&quot;app-6&quot;&gt;&lt;p&gt;{{ abc }}&lt;/p&gt;   //第一种元素绑定方法，abc为变量名，script中可直接调用（Mustache语法，双大括号）&lt;span v-bind:title=&quot;new2&quot;&gt; //第二种元素绑定方法，new2为变量名，script中直接调用put here&lt;/span&gt;&lt;br/&gt;&lt;button v-on:click=&quot;change&quot;&gt;click here&lt;/button&gt;//与方法绑定，跟C#差不多&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></li></ul><ul><li>script</li></ul><pre><code>export default {  name: &apos;app&apos;,  //给整个vue组件定义变量名，可调用  data () { //vue实例中引用到的变量名    return {      msg: &apos;Welcome to Your Vue.js App&apos;,      abc: &apos;something&apos;,      new2: &apos;currentTime: &apos; + new Date().toLocaleString()}  },  methods: { //vue实例中使用到的函数（方法）    change: function(){      this.abc = &quot;you&quot;    }  }}</code></pre><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>Mustache - 双大括号，绑定的数据对象上msg属性发生改变时，此处改变。</p><pre><code>&lt;span&gt;Message: {{ msg }}&lt;/span&gt;</code></pre><p>使用双大括号会将数据解释成普通文本（如代码)。需要输出真正的HTML，要用v-html指令</p><pre><code>&lt;p&gt;Using mustaches: {{ rawHtml }}&lt;/p&gt; //输出文本&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; //改变样式</code></pre><blockquote><p>你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。</p></blockquote><ul><li><p>ustache 语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令：</p>  <div v-bind:id="dynamicId"></div></li></ul><p>在布尔特性的情况下，它们的存在即暗示为 true，v-bind 工作起来略有不同，在这个例子中：</p><pre><code>&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;</code></pre><p>如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled 特性甚至不会被包含在渲染出来的<code>&lt;button&gt;</code>元素中。</p><p>（突然发现md好像可以支持部分html，<button> 比如这样 </button>)</p><h3 id="vue指令"><a href="#vue指令" class="headerlink" title="vue指令"></a>vue指令</h3><blockquote><p>指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式。vue指令可以直接嵌在html的元素里面中去，也就是直接在元素中加入这一条属性，使用demo如下：</p></blockquote><pre><code>&lt;div id=&quot;app-6&quot;&gt;  &lt;p&gt;{{ message }}&lt;/p&gt;  &lt;input v-model=&quot;message&quot;&gt; //双向绑定，vue指令在这里使用&lt;/div&gt;var app6 = new Vue({  el: &apos;#app-6&apos;,  data: {message: &apos;Hello Vue!&apos;  }})    </code></pre><p>指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p><p>一些vue指令：</p><pre><code>v-bind:title = &quot;abc&quot;  //将元素节点的title 绑定 data中变量名为abc的变量v-if=&quot;a&quot;  //通过控制a，可以控制元素v-else-if &amp; v-else //同样的裸绩v-for = &quot;i in a&quot;   //循环处理a数组中的元素i的属性v-on:click = &quot;method&quot;  //v-on用于监听DOM事件//click操作调用method函数 click应该可以替换成其他操作v-model = &quot;abc&quot;  //实现表单输入(或其它元素）和应用状态之间的双向绑定v-once //执行一次性地插值</code></pre><p>一些指令的属性：</p><ul><li>v-if和v-show<ul><li>v-if只会在指令的表达式返回truthy值的时候渲染，也就是切换过程中条件块内的事件监听器和子组件是会被销毁和重建的</li><li>而v-show的元素始终会被渲染并保留在DOM中，它只负责切换元素的css属性display</li><li>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</li></ul></li><li>v-if和v-for最好不用一起使用，v-for比v-if会具有更高的优先级    </li><li><p>v-for的一些语法</p><pre><code>v-for = &quot;item in items&quot; //遍历数组使用v-for = &quot;item of items&quot; //使用of代替in作为分隔符v-for = &quot;(item,index) in items&quot;//可选的第二个参数，当前项的索引v-for = (value,key) in object //key-value值对</code></pre></li></ul><p>  其中item是数组元素迭代的别名，items是源数据数组</p><p><strong>动态参数</strong></p><p>应该就是v-指令后面可以连接一个用方括号括起来的JS表达式（变量名），使得绑定的参数可以更灵活地动态调整。</p><p>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p><pre><code>&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;</code></pre><p>这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data 属性 attributeName，其值为 “href”，那么这个绑定将等价于 v-bind:href 。</p><p>详见<a href="https://cn.vuejs.org/v2/guide/syntax.html" target="_blank" rel="noopener">教程</a></p><p><strong>一些约束</strong></p><ul><li>动态参数的值应该是一个字符串，异常状态下是 null。（赋值null可以移除绑定？）</li><li>语法约束，某些字符（空格、引号）可能无效</li><li>浏览器会把特性名全部强制转换为小写，使用大写变量可能会出现问题</li><li>修饰符（半角句号 . 指明的特殊后缀)</li></ul><p>E: .prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：</p><pre><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;</code></pre><ul><li><p>缩写: Vue 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写：</p><pre><code>&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;--------------------------&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</code></pre></li></ul><h3 id="Vue实例中js使用"><a href="#Vue实例中js使用" class="headerlink" title="Vue实例中js使用"></a>Vue实例中js使用</h3><ul><li>可以绑定简单的属性键值</li><li>包括单个表达式，非语句 </li></ul><pre><code> //不生效 * 2{{var a = 1}}  {{ if (ok) { return message } }}</code></pre><hr><h3 id="关于-new-vue-和-export-default-的区别"><a href="#关于-new-vue-和-export-default-的区别" class="headerlink" title="关于 new vue 和 export default 的区别"></a>关于 new vue 和 export default 的区别</h3><blockquote><hr><p>在main.js当中已经有一个new vue了。作为被main.js  import的APP.vue ，App.vue当中应当有export default，这样才能在main.js中引入（也就是import）APP.vue当中的内容。</p></blockquote><blockquote><p>new vue是生成Vue根实例，而export default则是用来导出的。export default相当于提供一个接口给外界，让外界（这里也就是main.js）来引入使用。</p></blockquote><blockquote><p>在不使用App.vue 文件时，我们是通过 Vue 构造函数（new vue）创建一个 Vue 根实例来启动vuejs 项目，Vue 构造函数接受一个对象，这个对象有一些配置属性 el, data, component, template 等，从而对整个应用提供支持。</p></blockquote><blockquote><p>而现在我们的vue项目建好之后，有.vue也有.js，此时，在App.vue文件中，export default 后面的对象就相当于 new Vue() 构造函数中的接受的对象。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计—hw3</title>
      <link href="/2019/03/13/swsadHw/swsadhw3/"/>
      <url>/2019/03/13/swsadHw/swsadhw3/</url>
      
        <content type="html"><![CDATA[<h3 id="【简答题】"><a href="#【简答题】" class="headerlink" title="【简答题】"></a>【简答题】</h3><p><strong>1.简述瀑布模型、增量模型、螺旋模型（含原型方法）的优缺点（从项目特点、风险特征、人力资源利用角度思考）</strong></p><a id="more"></a><ul><li><p>瀑布模型:</p><ul><li>简述：瀑布模型设置了一系列的阶段，按顺序进行开发，项目开发进程从一个阶段流动到下一个阶段，形式上与物理世界中的瀑布非常相像。同时，每个阶段都会产生循环反馈，对临近阶段进行影响。</li><li>优点：<ul><li>降低软件开发的复杂程度，提高软件开发过程的透明性；同时，由于开发的基本流程和活动都是易理解的，因此提高了软件开发过程的可管理性。</li><li>推迟软件实现，强调在软件实现前必须进行分析和设计工作。</li><li>以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，保证了阶段之间的正确衔接，能够及时发现并纠正开发过程中存在的缺陷，使产品达到预期的质量要求。</li></ul></li><li>缺点：<ul><li>强调过程活动的线性顺序，因此理论上需要保证需求明确，且短期内可获得，每个阶段是无差错的。</li><li>缺乏灵活性，尤其无法解决软件需求不明确或不准确的问题。同时，在后期发现需求问题，更改的工作量十分巨大。</li><li>风险控制能力较弱，当前面需求模糊/前方成果不完善，会对后阶段产生巨大影响。</li><li>瀑布模型中的软件活动是文档驱动的，当阶段之间规定过多的文档时，会极大地增加系统的工作量。</li><li>管理人员如果仅仅以文档的完成情况来评估项目完成进度，往往会产生错误的结论，容易被人为误导。</li></ul></li></ul></li><li><p>增量模型:</p><ul><li>简述：增量模型是把待开发的软件系统模块化，将每个模块作为一个增量组件，分批次地分析、设计、编码和测试这些组块，具有一个递增式的开发过程。</li><li>优点：<ul><li>将待开发的软件系统模块化，可以分批次地提交软件产品，进行迭代式的开发，遵循“先做出来可以用的软件，再把软件做好。”的原则，因此对开发方较友好。</li><li>由于软件产品模块化交付，因此用户可以及时了解软件项目的进展并给出反馈，使得用户可以及时了解到项目进展，提升其在软件开发阶段的参与度和对项目的信息。</li><li>开发顺序灵活，开发人员可以对组件的实现顺序进行选择和优先级排序，先完成需求稳定的核心组件。当组件的优先级发生变化时，还能及时地对实现顺序进行调整。</li><li>降低了软件开发的风险，出现在组件中的错误可以被灵活解决，而不会对整个软件系统造成巨大的影响。</li></ul></li><li>缺点:<ul><li>待开发的软件系统需要可以被模块化；使用增量模型对难以模块化的软件系统进行开发会导致很多的问题：如模块划分，功能交付等。</li><li>增量粒度难以选择。</li><li>为了将软件系统分成多个模块，需要增加额外的工作量。</li></ul></li></ul></li><li><p>螺旋模型（含原型方法）：</p><ul><li>简述：螺旋模型采用周期性的方法进行开发，以进化的开发方式为中心，在不断迭代的过程中完成开发，且强调风险分析。</li><li><p>优点：</p><ul><li>设计上具有灵活性，可以在项目的各个阶段中或是下一次迭代中完成变更，可以不需要在一开始就给出具体明确的需求。</li><li>以小的分段来构造大型的系统，易于计算成本。</li><li>进行了风险分析，使得项目具有更高的可靠性。</li><li>由于快速原型法需要客户使用并提供反馈，因此提升了客户的参与度，保证了项目与客户需求是一致的，项目是可控的。同时提升了客户对项目的信心，对开发团队的认可。</li></ul></li><li><p>缺点：</p><ul><li>没有明确的项目终点，需要根据项目的具体进度进行判断。</li><li>建设周期长，可能导致软件开发的需求或核心技术与现实产生差距，无法满足当前用户的需求。</li><li>需要使用户确信这种模型的开发方法的结果是可以控制的。</li></ul></li></ul></li></ul><p><strong>2.简述统一过程三大特点，与面向对象的方法有什么关系？</strong></p><p>统一过程（Unified Process，UP）是一种以用例驱动的、以体系结构为核心的、迭代和增量的软件过程模型。由UML方法和工具支持，广泛应用于各类面向对象项目。<br>统一过程的三大特点分别是：</p><ol><li>软件开发是一个迭代的过程，是一种受控的迭代和增量式开发。</li><li>软件开发是由用例（Use Case）驱动的，也就是通过测试来推动整个开发过程的进行，在测试中完成需求分析、设计、质量控制等过程。这为整个开发过程提供了高效的驱动力。</li><li>软件开发是以体系结构为核心的。</li></ol><p><strong>3.简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？</strong></p><p>UP项目将其工作和迭代组织为四个主要阶段： </p><ol><li>初始（Inception）：大体上的构想、业务案例、范围和模糊评估。 <ul><li>里程碑：生命周期目标里程碑，包括一些重要的文档，如：项目构想(Vision)、原始用例模型、原始业务风险评估、一个或者多个原型、原始业务案例等。需要对这些文档进行评审，以确定正确理解用例需求、项目风险评估合理、阶段计划可行等。 </li></ul></li><li>细化（Elaboration）：已精化的构想、核心架构的迭代实现、高风险的解决、确定大多数需求和范围以及进行更为实际的评估。 <ul><li>里程碑：生命周期体系结构(Lifecycle Architecture) 里程碑。包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等。通过评审确定软件体系结构已经稳定、高风险的业务需求和技术机制已经解决、修订的项目计划可行等。 </li></ul></li><li>构造（Construction）：对遗留下来的风险较低和比较简单的元素进行迭代实现，准备部署。 <ul><li>里程碑：初始运行能力(Initial Operational Capability) 里程碑。包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署。此刻，要确定软件、环境、用户是否可以开始系统的运行。 </li></ul></li><li>移交（Transition）：进行beta测试和部署。 <ul><li>里程碑：产品发布(Product Release) 里程碑。确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周期。在一些情况下这个里程碑可能与下一个周期的初始阶段的相重合。</li></ul></li></ol><p>下图提供了一个可视化的循环过程：<br><img src="https://img-blog.csdnimg.cn/20190313144706784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1llem8xMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>4.软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？</strong></p><p>当企业使用UP进行软件开发时，基于UP迭代式、增量式的开发特点，整个开发过程可以被划分为几个固定的阶段和多次迭代的过程。也就是说，整个开发过程被划分成了固定的开发周期，因此企业就可以按照固定的节奏进行软件生产，也可以得到预期的生产周期并以此来形成一个发布软件产品的固定周期。<br>UP本身的特性，使得其可应用于各种领域的软件开发和不同的项目规模。其带来的好处有：</p><ul><li>企业可以将项目格式化、流程化，并对每一个流程标定固定的工作内容，使得整个系统架构更具有鲁棒性。</li><li>项目管理者以及客户都可以更了解开发进度、存在的问题和预期的目标，有利于开发者和使用者的交流，使得项目开发不会与需求偏差过大</li><li>开发过程可以进行风险分析和需求理解，降低了项目失败的概率</li></ul><hr><p>###【实践题】</p><p>了解使用 TAPD 的最佳实践</p><ul><li>比较完善 backlog 支持（树结构）</li><li>迭代（sprint）安排</li><li>较好的缺陷管理</li><li>Kanban</li><li>统计</li></ul><p>###【大作业准备】</p><ul><li>按大作业要求组件团队、思考项目题目与内容</li><li>将团队暂时分为技术研究、业务调研两个部分<ul><li>技术团队初步确定技术方法，力争做一些技术原型，如 基于 MVC 框架的的用户登陆实现</li><li>业务调研团队调查竞争性产品，分析它们的基础、共性业务以及竞争优势</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计—hw2</title>
      <link href="/2019/03/09/swsadHw/swsadhw2/"/>
      <url>/2019/03/09/swsadHw/swsadhw2/</url>
      
        <content type="html"><![CDATA[<h3 id="【简答题】"><a href="#【简答题】" class="headerlink" title="【简答题】"></a>【简答题】</h3><p><strong>1.用简短的语言给出对分析、设计的理解。</strong></p><p>分析就是对用户给出的软件功能等方面的需求进行系统的研究，识别出主号问题，确定待开发软件的功能、性能、接口、数据、界面等具体的细节要求。<br>设计就是基于需求分析中得到的需求，构造出目标系统的逻辑模型，最终得到一个可供编码过程参考的设计模型文档。</p><blockquote><p>软件分析不是发现更多的功能与需求，而是确认有效的功能与需求，去伪存真不断满足客户需要。软件设计也不是追求最先进技术，而是控制变化附加的成本，使得软件生产的预算、时间等能在掌控之中。</p></blockquote><a id="more"></a><hr><p><strong>2.用一句话描述面向对象的分析与设计的优势。</strong></p><p>面向对象的分析与设计能够通过分析现实世界中存在的问题，并构建相对应的问题模型，保持了他们的结构、关系和行为模式，具有易理解和易维护的特性。</p><hr><p><strong>3.简述 UML（统一建模语言）的作用。考试考哪些图？</strong></p><p>UML（Unified Modeling Language）用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品。 它可以将面向对象分析（OOA）和面向对象设计（OOD）使用统一定义的符号表示出来，并将对象自身的属性、对象与对象之间的关联关系可视化，提升项目结构的可读性。</p><p>考试的重点图形: </p><p>图形化的表示机制，十多种视图，分4类：</p><ul><li>用例图：用户角度：功能、执行者</li><li>静态图：系统静态结构<ul><li>类图：概念及关系</li><li>对象图：某种状态或时间段内，系统中活跃的对象及其关系</li><li>包图：描述系统的分解结构</li></ul></li><li>行为图：系统的动态行为<ul><li>交互图：描述对象间的消息传递<ul><li>顺序图：强调对象间消息发送的时序</li><li>合作图：强调对象间的动态协作关系</li></ul></li><li>状态图：对象的动态行为。状态-事件-状态迁移-响应动作</li><li>活动图：描述系统为完成某功能而执行的操作序列</li></ul></li><li>实现图：描述系统的组成和分布状况<ul><li>构件图：组成部件及其关系</li><li>部署图：物理体系结构及与软件单元的对应关系</li></ul></li></ul><hr><p><strong>4.从软件本质的角度，解释软件范围（需求）控制的可行性</strong></p><p>软件的本质包括复杂性、一致性、可变性和不可视性。基于IEEE中给出的软件特点：</p><blockquote><ul><li>Software requirements are prone to frequent change</li><li>In many cases, requirements allocated to software must be renegotiated and reprioritized</li><li>Small changes to software can have large negative effects（There are no small software changes） </li></ul></blockquote><p>对于软件的需求可能会因为不一致、不可使、易于变化的环境而更改，需求的更改会带来软件的改动，这就可能会产生巨大的负面影响，包括开发难度的增加，开发周期的增长等。为了尽可能避免以上情况的发生，我们必须对软件需求进行范围的划定和控制。即在需求分析与设计的过程中，我们必须在给定的范围内围绕软件开发的成本进行调控，允许范围内、不造成巨大影响的需求变更和迭代，最终保证软件开发周期和成本是可控的，在约定的时间内交付出可满足客户的软件成品。因此，软件范围需求控制是可行且必须的。</p><hr><p>###【看板使用练习】<br><a href="https://imgchr.com/i/AmZyQJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmZyQJ.jpg" alt="AmZyQJ.jpg"></a><br><a href="https://imgchr.com/i/AmZvY8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmZvY8.md.png" alt="AmZvY8.md.png"></a></p><p>###【UML绘图工具练习】</p><p>图选自  《UML和模式应用（中文第三版）》 P193  </p><p> <strong>图16-16 UML中的关联类</strong><br><a href="https://imgchr.com/i/AmVzrR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmVzrR.jpg" alt="AmVzrR.jpg"></a></p><p><strong>图16-17 表示单实例类</strong><br><a href="https://imgchr.com/i/AmZSq1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/18/AmZSq1.jpg" alt="AmZSq1.jpg"></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>系统分析与设计—hw1</title>
      <link href="/2019/03/06/swsadHw/swsadhw1/"/>
      <url>/2019/03/06/swsadHw/swsadhw1/</url>
      
        <content type="html"><![CDATA[<h3 id="【简答题】"><a href="#【简答题】" class="headerlink" title="【简答题】"></a>【简答题】</h3><p><strong>1.软件工程的定义</strong></p><blockquote><p>Software engineering is “(1) the application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software, that is, the application of engineering to software,” and “(2) the study of approaches as in (1).” –– IEEE Standard 610.12</p></blockquote><p>软件工程的定义： </p><ul><li>(1) 将系统化、规范化、可度量的方法应用与软件的开发、运行和维护-的过程，即将工程化应用于软件中。 </li><li>(2) 对(1)中所述方法的研究。</li></ul><p>软件工程知识体系:</p><ul><li>以高质量为目标，研究软件生产的过程模型、方法和工具</li></ul><a id="more"></a><hr><p><strong>2.解释导致 software crisis 本质原因、表现，述说克服软件危机的方法</strong><br>软件危机（Software Crisis）是一个早期的计算机科学用语，指的是在给定时间内编写出可用和高效的程序的困难性。现在引申至指软件在开发和维护过程中出现的一系列严重的问题。<br>在1972年，Edsger Dijkstra 指出计算能力约强大，编程越是大问题。因此导致软件危机的本质原因是计算机计算能力的迅速增长，以及计算机能力增长而导致软件需要处理和解决的问题具有更大的复杂性。也就是计算机计算能力的提高超过了程序员能够高效利用计算机的能力。<br>软件危机的主要表现有：</p><ul><li>进行了超预算的项目</li><li>项目长期无法完成</li><li>软件非常低效</li><li>软件质量低下</li><li>软件经常与用户的需求不匹配</li><li>项目难以管理</li><li>程序代码的后期维护存在困难</li><li>软件无法完成并交付</li></ul><hr><p><strong>3.软件生命周期</strong></p><p>软件生命周期（Software Development LifeCycle）是指软件的产生直到成熟的全部过程。早期的软件生命周期受到瀑布模型的影响，因此通常定义为：</p><blockquote><p>软件从计划、需求开始，经历分析设计、实现、部署、维护，直到最后逐渐消亡的。</p></blockquote><p>因此，现在对软件生命周期及软件生命周期模型采用如下定义：</p><ul><li>软件生命周期是指软件的产生直到成熟的全部过程。</li><li>软件生命周期模型是指人们为开发更好的软件而归纳总结的软件生命周期的典型实践参考。</li></ul><p>根据GB/T 8567的定义，软件生命周期分为以下6个阶段：</p><ul><li>可行性分析与计划</li><li>需求分析</li><li>设计（概要设计和详细设计）</li><li>编码实现</li><li>测试</li><li>运行和维护</li></ul><p>常见的软件生命周期模型有原型模型、螺旋模型、迭代模型。</p><hr><p><strong>4.SWEBoK 的 15 个知识域（An Overview of the SWEBOK Guide 请中文翻译其名称与简短说明）</strong></p><p>SWEBOK V3中的15个知识域包括：</p><p><strong>11个软件工程实践知识域：</strong></p><ul><li><strong>软件需求 Software requirements</strong><br>真实世界问题而必须展示的特性。软件需求的知识域包括七个子域，即软件需求基础、需求过程、需求获取、需求分析、需求规格说明、需求确认和实践考虑。</li><li><strong>软件设计 Software design</strong><br>根据IEEE [ IEEE 610.12-90] ，设计既是”定义一个系统或组件的体系结构、组件、接口和其他特征的过程”，又是”这个过程的结果”。软件设计的知识域包括六个子域，即软件设计基础、软件设计关键问题、软件结构与体系结构、软件设计质量的分析与评价、软件设计符号、软件设计的策略与方法。</li><li><strong>软件构造 Software construction</strong><br>它指通过编码、验证、单元测试、集成测试和排错的组合，具体创建一个可以工作的、有意义的软件，其知识域包括软件构造基础、管理构造、实际考虑三个子域。</li><li><strong>软件测试 Software testing</strong><br>它是由在有限测试用例集合上，根据期望的行为，对程序的行为进行的动态验证组成， 测试用倒是实际上无限的执行域中适当选择出来的。软件测试包括五个子域，即软件测试基础和测试级别、测试技术、需求分析、与测试相关的度量、测试过程。</li><li><strong>软件维护 Software maintenance</strong><br>软件一旦投入运行，就可能出现异常，运行环境可能发生改变，用户会提出新的需求。生命周期软件维护阶段从软件交付时开始，但是维护活动出现得还要早。软件维护的知识域包括四个子域，即软件维护基础、软件维护的关键问题、维护过程、维护技术。</li><li><strong>软件配置管理 Software configuration management</strong><br>为了系统地控制配置的变更和维护在整个系统生命周期中的完整性和可追踪性，而标志软件在时间上不同点的配置的学科。软件配置管理包括六个子域，即软件配置管理过程管理、软件配置标志、软件配置控制、软件配置状态统计、软件配置审核、软件发行管理和交付。</li><li><strong>软件工程管理 Software engineering management</strong><br>处理软件工程的管理与度量，虽然度量是所有知识域的一个重要方面，但是这里涉及的是度量程序的专题。软件工程管理包括六个子域，即启动和范围定义、软件项目计划、软件项目实施、评审与评价、关闭、软件工程度量。前五个覆盖软件过程工程 管理，第六个描述软件度量的程序。</li><li><strong>软件工程过程 Software engineering process</strong><br>涉及软件工程过程本身的定义、实现、评定、度量、管理、变更和改进。软件工程过程包括四个子域，即过程实施与改变、过程定义、过程评定、过程和产品度量。</li><li><strong>软件工程模型和方法  Software engineering models and methods</strong><br>包括软件工程工具、软件工程方法两个子域。</li><li><strong>软件质量 Software quality</strong><br>处理跨越软件生命周期过程的软件质量的考虑，由于软件质量在软件工程中元处不在，其他知识域也涉及质量 问 题。软件质量包括三个子域，即软件质量基础、软件质量过程、实践考虑。</li><li><strong>软件工程职业实践 Software engineering professional practice</strong></li></ul><p><strong>4个软件工程教育基础知识域：</strong></p><ul><li><strong>软件工程经济学 Software engineering economics</strong></li><li><strong>计算基础 Computing foundations</strong></li><li><strong>数学基础 Mathematical foundations</strong></li><li><strong>工程基础 Engineering foundations</strong></li></ul><hr><p><strong>5.简单解释 CMMI 的五个级别。例如：Level 1 - Initial：无序，自发生产模式。</strong></p><p>能力成熟度模型集成（英语：Capability Maturity Model Integration，简称CMMI或“希迈”）是一种改进过程的方法，其目的是协助提升组织的绩效。</p><p><strong>Level 1 - Initial：初始级。</strong><br>软件过程是无序的，有时甚至是混乱的，对过程几乎没有定义，成功取决于个人努力。管理是反应式的。</p><p><strong>Level 2 - Managed：可管理级。</strong><br>建立了基本的项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。</p><p><strong>Level 3 - Defined：已定义级。</strong><br>已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。</p><p><strong>Level 4 - Quantitatively Managed：量化管理级。</strong><br>分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。</p><p><strong>Level 5 - Optimizing：优化管理级。</strong><br>过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。</p><hr><p><strong>6.用自己语言简述 SWEBok 或 CMMI （约200字）</strong></p><p>SWEBok即软件工程知识体系指南（Guide to the Software Engineering Body of Knowledge)，是一个得到普遍认可的共识性软件工程本体知识结构。（其历史可追溯到1999年4月由发表的《软件工程知识本体结构》报告。报告的发布使人们达成了共识，即建立软件工程本体知识结构是解决如何验证软件工程工程师的资格、如何设置并检验软件工程相关课程等难题的答案。）SWEBok的目的是为软件工程学科的范围提供一致的认识，为支持该学科的本体知识提供指导。SWEBOK V3将软件工程学科的本体知识分为15个知识域，并对每个知识域中的重要概念和区别加以阐述说明。也就是说，SWEBok最大的贡献是将原本混杂的软件工程知识体系化，将原本存在的知识分类整理，最后形成一个具有共识性和方向性的指南。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BringMeFly</title>
      <link href="/2019/02/27/Personal/hello-world/"/>
      <url>/2019/02/27/Personal/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Update it when i have time.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
